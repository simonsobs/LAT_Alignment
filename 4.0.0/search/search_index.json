{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LAT Alignment","text":"<p>Tools for Large Aperture Telescope (LAT) mirror alignment. While these tools are currently specific to the Simons Observatory LAT, much of the library could be generalized to any telescope alignment.</p> <p>For details on usage please check the guide (WIP! Doesn't exist yet!).</p>"},{"location":"#installation","title":"Installation","text":"<p>Technically after cloning this repository you can just run <code>python lat_alignment/alignment.py PATH/TO/CONFIG</code>, but it is recommended that you install this as a package instead.</p> <p>To do this just run: <code>pip install -e .</code> from the root of this repository.</p> <p>This has two main benefits over running the script directly: 1. It will handle dependencies for you. 2. This sets up an entrypoint called <code>lat_alignment</code> so that you can call the code from anywhere. This is nice because now you can call the code from the measurement directory where you are most likely editing files, saving you the hassle of having to <code>cd</code> or wrangle long file paths.</p>"},{"location":"#bugs-and-feature-requests","title":"Bugs and Feature Requests","text":"<p>For low priority bugs and feature requests submit an issue on the git repo.</p> <p>For higher priority issues (or questions that require an expedient answer) email, Slack, or call me.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you wish to contribute to this repository (either code or adding measurement files) contact me via email or Slack.</p> <p>If you are contributing code please do so by creating a branch and submitting a pull request. Try to keep things as close to PEP8 as possible.</p>"},{"location":"config_file/","title":"Configuration File","text":""},{"location":"config_file/#fields","title":"Fields","text":"<code>mode</code> <p>The alignment mode to use.</p> <p>Possible values are:</p> <ul> <li><code>panel</code>: For aligning panels within one mirror.</li> <li><code>optical</code>: For aligning optical elements relative to each other (as solid bodies).</li> </ul> <code>mirror</code> <p>The mirror that we want to align panels to. Only used if <code>mode</code> is <code>panel</code>.</p> <p>Possible values are:</p> <ul> <li><code>primary</code>: To align the primary mirror.</li> <li><code>secondary</code>: To align the secondary mirror.</li> </ul> <code>align_to</code> <p>Which optical element to keep fixed and align the others to. Only used if <code>mode</code> is <code>optical</code>.</p> <p>Possible values are:</p> <ul> <li><code>primary</code>: To align to the primary mirror.</li> <li><code>secondary</code>: To align to the secondary mirror.</li> <li><code>receiver</code>: To align to the receiver.</li> <li><code>bearing</code>: To align to the bearing.</li> </ul> <code>measurement</code> <p>The path to the photogrammetry data we are using to do the alignment. If this is a relative path it is taken relative to the directory that the configuration file is in.</p> <code>data_dir</code> <p>The path to the data files that define the panel corners and the adjuster positions. If this is a relative path it is taken relative to the directory that the configuration file is in.</p> <p>You genrally don't need to provide this since the package will use its own bundled data files by default.</p> <code>load</code> <p>Additional keyword arguments to pass to <code>io.load_photo</code>.</p> <code>compensate</code> <p>Amount to compensate mirror measurements by in mm. This is for backwards compatiblilty with laser tracker data and is \\(0\\) by default.</p> <code>common_mode</code> <p>Additional keyword arguments to pass to <code>mirror.remove_cm</code></p> <code>adjuster_radius</code> <p>How close to an adjuster a data point needs to be in order for us to use its residual as a secondary correction when computing adjustments. Only used if <code>mode</code> is <code>panel</code>.</p> <p>This is \\(100\\) mm by default.</p> <code>vmax</code> <p>The maximum value to use in the colorbar when plotting mirror surface. The colorbar is symmetric so <code>vmin = -1*vmax</code>.</p> <code>adjust</code> <p>Additional keyword arguments to pass to <code>adjustments.calc_adjustments</code></p> <code>title</code> <p>The title of the measurement. This is used both in plots and in output filenames.</p>"},{"location":"config_file/#example-configuration-files","title":"Example Configuration Files","text":"<p>These are typical configuration files, you usually will not need to touch fields other than the ones shown here.</p>"},{"location":"config_file/#panel-alignment","title":"Panel Alignment","text":"<pre><code>mode: \"panel\"\nmirror: \"secondary\"\nmeasurement: \"data_20240911_1430.csv\"\ntitle: \"M2 20240911 1430\"\nvmax: 50\n</code></pre>"},{"location":"config_file/#optical-element-alignment","title":"Optical Element Alignment","text":"<p>WIP! Check back later!</p>"},{"location":"coordinate_systems/","title":"Coordinate Systems","text":"<p>There are many coordinate systems that have been used to describe the LAT mirror, most of them were used a single time and them replaced. Here we describe the six coordinate systems that are actively used. These six coordinate systems can be organized into two groups: the \"Optical\" coordinate systems and the \"Vertex\" coordinate systems. Each of these groups contains three coordinate systems: \"Global\", \"Primary\", and \"Secondary\"; where \"Global\" is a global reference frame for the whole telescope, \"Primary\" is an internal reference frame for the primary mirror, and \"Secondary\" is an internal reference frame for the secondary mirror.</p> <p>In general this software package does all of its computations in the \"Optical\" systems, but it is useful to understand the \"Vertex\" systems so that one can utilize measurements provided by Vertex.</p> <p>Note that this page is mostly to give the user an understanding of how these coordinate systems are defined. You should never have to transform between them by hand. For that please use the <code>transforms.coord_transform</code> function.</p>"},{"location":"coordinate_systems/#optical-coordinate-systems","title":"Optical Coordinate Systems","text":"<p>The optical coordinate systems are designed to be logical given the optics of the telescope.</p> <p>For \"Primary\" and \"Secondary\" the axis are defined such that:</p> <ul> <li>The \\(x\\) axis changes as the panel column number changes.</li> <li>The \\(y\\) axis changes as the panel row number changes.</li> <li>The \\(z\\) axis is normal to the mirror surfaces.</li> </ul> <p>And the origin is at the center of the mirror surface. The mirror model in <code>mirror.mirror_surface</code> is computed in these coordinates.</p> <p>The directions of the axis relative to the mirror surface is not the same for the two mirrors, check the diagram below to see where they point.</p> <p>The \"Global\" coordinate system is defined such that:</p> <ul> <li>The \\(x\\) axis is tangent to the telescope's azimuth rotation.</li> <li>The \\(y\\) axis points towards the receiver.</li> <li>The \\(z\\) axis points in the direction that light enters the telescope.</li> </ul> <p>And the origin is set so that the origin of the \"Primary\" system lies along the \"Global\" \\(z\\) axis and the origin of the \"Secondary\" system lies along the \"Global\" \\(y\\) axis.</p> <p></p>"},{"location":"coordinate_systems/#vertex-coordinate-systems","title":"Vertex Coordinate Systems","text":"<p>The vertex coordinate systems were developed by Vertex and are used for all of there alignment purposes. If you get data from Vertex it is likely in this format.</p> <p>For \"Primary\" and \"Secondary\" the axis are defined such that:</p> <ul> <li>The \\(x\\) axis changes as the panel row number changes.</li> <li>The \\(y\\) axis changes as the panel column number changes.</li> <li>The \\(z\\) axis is normal to the mirror surfaces.</li> </ul> <p>The origins are the same as in the \"Optical\" coordinate systems. See the diagram below for the orientation of these axes.</p> <p>The \"Global\" coordinate system is defined such that:</p> <ul> <li>The \\(x\\) axis points towards the receiver.</li> <li>The \\(y\\) axis is tangent to the telescope's azimuth rotation.</li> <li>The \\(z\\) axis points out of the telescope.</li> </ul> <p>The origin is offset by 120 mm along the \"Vertex\" \\(x\\) (so the \"Optical\" \\(y\\) axis). The reason for the offset is unclear.</p> <p></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>adjustments</li> <li>alignment</li> <li>fitting</li> <li>io</li> <li>mirror</li> <li>transforms</li> </ul>"},{"location":"reference/adjustments/","title":"adjustments","text":"<p>Calculate adjustments needed to align LAT mirror panel</p> <p>Author: Saianeesh Keshav Haridas</p>"},{"location":"reference/adjustments/#lat_alignment.adjustments.adjustment_fit_func","title":"<code>adjustment_fit_func(pars, can_points, points, adjustors)</code>","text":"<p>Function to minimize when calculating adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>pars</code> <code>NDArray[float32]</code> <p>The parameters to fit for:</p> <ul> <li>dx: Translation in x</li> <li>dy: Translation in y</li> <li>dz: Translation in z</li> <li>thetha_0: Angle to rotate about first adjustor axis</li> <li>thetha_1: Angle to rotate about second adjustor axis</li> <li>z_t: Additional translation to tension the center point</li> </ul> required <code>can_points</code> <code>NDArray[float32]</code> <p>The cannonical positions of the points to align.</p> required <code>points</code> <code>NDArray[float32]</code> <p>The measured positions of the points to align.</p> required <code>adjustors</code> <code>NDArray[float32]</code> <p>The measured positions of the adjustors.</p> required <p>Returns:</p> Name Type Description <code>norm</code> <code>float32</code> <p>The norm of \\(cannonical_positions - transformed_positions\\).</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def adjustment_fit_func(\n    pars: NDArray[np.float32],\n    can_points: NDArray[np.float32],\n    points: NDArray[np.float32],\n    adjustors: NDArray[np.float32],\n) -&gt; np.float32:\n    r\"\"\"\n    Function to minimize when calculating adjustments.\n\n    Parameters\n    ----------\n    pars : NDArray[np.float32]\n        The parameters to fit for:\n\n        * dx: Translation in x\n        * dy: Translation in y\n        * dz: Translation in z\n        * thetha_0: Angle to rotate about first adjustor axis\n        * thetha_1: Angle to rotate about second adjustor axis\n        * z_t: Additional translation to tension the center point\n    can_points : NDArray[np.float32]\n        The cannonical positions of the points to align.\n    points : NDArray[np.float32]\n        The measured positions of the points to align.\n    adjustors : NDArray[np.float32]\n        The measured positions of the adjustors.\n\n    Returns\n    -------\n    norm : np.float32\n        The norm of $cannonical_positions - transformed_positions$.\n    \"\"\"\n    dx, dy, dz, thetha_0, thetha_1, z_t = pars\n    points, adjustors = translate_panel(points, adjustors, dx, dy, dz)\n    points, adjustors = rotate_panel(points, adjustors, thetha_0, thetha_1)\n    points[-1, -1] += z_t\n    return np.linalg.norm(can_points - points)\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.calc_adjustments","title":"<code>calc_adjustments(can_points, points, adjustors, **kwargs)</code>","text":"<p>Calculate adjustments needed to align panel.</p> <p>Parameters:</p> Name Type Description Default <code>can_points</code> <code>NDArray[float32]</code> <p>The cannonical position of the points to align.</p> required <code>points</code> <code>NDArray[float32]</code> <p>The measured positions of the points to align.</p> required <code>adjustors</code> <code>NDArray[float32]</code> <p>The measured positions of the adjustors.</p> required <code>**kwargs</code> <p>Arguments to be passed to <code>scipy.optimize.minimize</code>.</p> <code>{}</code> <code>dx</code> <code>float32</code> <p>The required translation of panel in x.</p> required <code>dy</code> <code>float32</code> <p>The required translation of panel in y.</p> required <code>d_adj</code> <code>NDArray[float32]</code> <p>The amount to move each adjustor.</p> required <code>dx_err</code> <code>float32</code> <p>The error in the fit for <code>dx</code>.</p> required <code>dy_err</code> <code>float32</code> <p>The error in the fit for <code>dy</code>.</p> required <code>d_adj_err</code> <code>NDArray[float32]</code> <p>The error in the fit for <code>d_adj</code>.</p> required Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def calc_adjustments(\n    can_points: NDArray[np.float32],\n    points: NDArray[np.float32],\n    adjustors: NDArray[np.float32],\n    **kwargs,\n) -&gt; Tuple[\n    np.float32,\n    np.float32,\n    NDArray[np.float32],\n    np.float32,\n    np.float32,\n    NDArray[np.float32],\n]:\n    \"\"\"\n    Calculate adjustments needed to align panel.\n\n    Parameters\n    ----------\n    can_points : NDArray[np.float32]\n        The cannonical position of the points to align.\n    points : NDArray[np.float32]\n        The measured positions of the points to align.\n    adjustors : NDArray[np.float32]\n        The measured positions of the adjustors.\n    **kwargs\n        Arguments to be passed to `scipy.optimize.minimize`.\n\n    dx : np.float32\n        The required translation of panel in x.\n    dy : np.float32\n        The required translation of panel in y.\n    d_adj : NDArray[np.float32]\n        The amount to move each adjustor.\n    dx_err : np.float32\n        The error in the fit for `dx`.\n    dy_err : np.float32\n        The error in the fit for `dy`.\n    d_adj_err : NDArray[np.float32]\n        The error in the fit for `d_adj`.\n    \"\"\"\n    res = opt.minimize(\n        adjustment_fit_func, np.zeros(6), (can_points, points, adjustors), **kwargs\n    )\n\n    dx, dy, dz, thetha_0, thetha_1, z_t = res.x\n    _points, _adjustors = translate_panel(points, adjustors, dx, dy, dz)\n    _points, _adjustors = rotate_panel(_points, _adjustors, thetha_0, thetha_1)\n    _adjustors[-1, -1] += z_t\n    d_adj = _adjustors - adjustors\n\n    ftol = 2.220446049250313e-09\n    if \"ftol\" in kwargs:\n        ftol = kwargs[\"ftol\"]\n    perr = np.sqrt(ftol * np.diag(res.hess_inv))\n    dx_err, dy_err, dz_err, thetha_0_err, thetha_1_err, z_t_err = perr\n    _points, _adjustors = translate_panel(points, adjustors, dx_err, dy_err, dz_err)\n    _points, _adjustors = rotate_panel(_points, _adjustors, thetha_0_err, thetha_1_err)\n    _adjustors[-1, -1] += z_t_err\n    d_adj_err = _adjustors - adjustors\n\n    return dx, dy, d_adj[:, 2], dx_err, dy_err, d_adj_err[:, 2]\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.rotate","title":"<code>rotate(point, end_point1, end_point2, theta)</code>","text":"<p>Rotate a point about an axis</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>NDArray[float32]</code> <p>The point to rotate</p> required <code>end_point1</code> <code>NDArray[float32]</code> <p>A point on the axis of rotation</p> required <code>end_point2</code> <code>NDArray[float32]</code> <p>Another point on the axis of rotation</p> required <code>theta</code> <code>float32</code> <p>Angle in radians to rotate by</p> required <p>Returns:</p> Name Type Description <code>point</code> <code>NDArray[float32]</code> <p>The rotated point</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def rotate(\n    point: NDArray[np.float32],\n    end_point1: NDArray[np.float32],\n    end_point2: NDArray[np.float32],\n    theta: np.float32,\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Rotate a point about an axis\n\n    Parameters\n    ----------\n    point : NDArray[np.float32]\n        The point to rotate\n    end_point1 : NDArray[np.float32]\n        A point on the axis of rotation\n    end_point2 : NDArray[np.float32]\n        Another point on the axis of rotation\n    theta: NDArray[np.float32]\n        Angle in radians to rotate by\n\n    Returns\n    -------\n    point : NDArray[np.float32]\n        The rotated point\n    \"\"\"\n    origin = np.mean((end_point1, end_point2))\n    point_0 = point - origin\n    ax = end_point2 - end_point1\n    ax = rot.from_rotvec(theta * ax / np.linalg.norm(ax))\n    point_0 = ax.apply(point_0)\n    return point_0 + origin\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.rotate_panel","title":"<code>rotate_panel(points, adjustors, thetha_0, thetha_1)</code>","text":"<p>Rotate panel about axes created by adjustors.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[float32]</code> <p>Points on panel to rotate.</p> required <code>adjustors</code> <code>NDArray[float32]</code> <p>Adjustor positions.</p> required <code>thetha_0</code> <code>float32</code> <p>Angle to rotate about first adjustor axis</p> required <code>thetha_1</code> <code>np.float32.</code> <p>Angle to rotate about second adjustor axis</p> required <p>Returns:</p> Name Type Description <code>rot_points</code> <code>NDArray[float32]</code> <p>The rotated points.</p> <code>rot_adjustors</code> <code>NDArray[float32]</code> <p>The rotated adjustors.</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def rotate_panel(\n    points: NDArray[np.float32],\n    adjustors: NDArray[np.float32],\n    thetha_0: np.float32,\n    thetha_1: np.float32,\n) -&gt; Tuple[NDArray[np.float32], NDArray[np.float32]]:\n    \"\"\"\n    Rotate panel about axes created by adjustors.\n\n    Parameters\n    ----------\n    points : NDArray[np.float32]\n        Points on panel to rotate.\n    adjustors : NDArray[np.float32]\n        Adjustor positions.\n    thetha_0 : np.float32\n        Angle to rotate about first adjustor axis\n    thetha_1 : np.float32.\n        Angle to rotate about second adjustor axis\n\n    Returns\n    -------\n    rot_points : NDArray[np.float32]\n        The rotated points.\n    rot_adjustors : NDArray[np.float32]\n        The rotated adjustors.\n    \"\"\"\n    rot_points = np.zeros(points.shape, np.float32)\n    rot_adjustors = np.zeros(adjustors.shape, np.float32)\n\n    n_points = len(points)\n    n_adjustors = len(adjustors)\n\n    for i in range(n_points):\n        rot_points[i] = rotate(points[i], adjustors[1], adjustors[2], thetha_0)\n        rot_points[i] = rotate(rot_points[i], adjustors[0], adjustors[3], thetha_1)\n    for i in range(n_adjustors):\n        rot_adjustors[i] = rotate(adjustors[i], adjustors[1], adjustors[2], thetha_0)\n        rot_adjustors[i] = rotate(\n            rot_adjustors[i], adjustors[0], adjustors[3], thetha_1\n        )\n    return rot_points, rot_adjustors\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.translate_panel","title":"<code>translate_panel(points, adjustors, dx, dy, dz)</code>","text":"<p>Translate a panel.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[float32]</code> <p>The points on panel to translate.</p> required <code>adjustors</code> <code>NDArray[float32]</code> <p>Adjustor positions.</p> required <code>dx</code> <code>float32</code> <p>Translation in x.</p> required <code>dy</code> <code>float32</code> <p>Translation in y.</p> required <code>dz</code> <code>float32</code> <p>Translation in z.</p> required <p>Returns:</p> Name Type Description <code>points</code> <code>NDArray[float32]</code> <p>The translated points.</p> <code>adjustors</code> <code>NDArray[float32]</code> <p>The translated adjustors.</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def translate_panel(\n    points: NDArray[np.float32],\n    adjustors: NDArray[np.float32],\n    dx: np.float32,\n    dy: np.float32,\n    dz: np.float32,\n) -&gt; Tuple[NDArray[np.float32], NDArray[np.float32]]:\n    \"\"\"\n    Translate a panel.\n\n    Parameters\n    ----------\n    points : NDArray[np.float32]\n        The points on panel to translate.\n    adjustors : NDArray[np.float32]\n        Adjustor positions.\n    dx : np.float32\n        Translation in x.\n    dy : np.float32\n        Translation in y.\n    dz : np.float32\n        Translation in z.\n\n    Returns\n    -------\n    points : NDArray[np.float32]\n        The translated points.\n    adjustors : NDArray[np.float32]\n        The translated adjustors.\n    \"\"\"\n    translation = np.array((dx, dy, dz))\n    return points + translation, adjustors + translation\n</code></pre>"},{"location":"reference/alignment/","title":"alignment","text":"<p>Main driver script for running the alignment. You typically want to use the <code>lat_alignment</code> entrypoint rather than calling this directly.</p>"},{"location":"reference/alignment/#lat_alignment.alignment.adjust_panel","title":"<code>adjust_panel(panel, mnum, cfg)</code>","text":"<p>Helper function to get the adjustments for a single panel.</p> <p>Parameters:</p> Name Type Description Default <code>panel</code> <code>Panel</code> <p>The mirror panel to adjust.</p> required <code>mnum</code> <code>int</code> <p>The mirror number. 1 for the primary and 2 for the secondary.</p> required <code>cfg</code> <code>dict</code> <p>The configuration dictionairy.</p> required <p>Returns:</p> Name Type Description <code>adjustments</code> <code>NDArray[float32]</code> <p>The adjustments to make for the panel. This is a 17 element array with the following structure: <code>[mnum, panel_row, panel_col, dx, dy, d_adj1, ..., d_adj5, dx_err, dy_err, d_adj1_err, ..., d_adj5_err]</code>.</p> Source code in <code>lat_alignment/alignment.py</code> <pre><code>def adjust_panel(panel: mir.Panel, mnum: int, cfg: dict) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Helper function to get the adjustments for a single panel.\n\n    Parameters\n    ----------\n    panel : mir.Panel\n        The mirror panel to adjust.\n    mnum : int\n        The mirror number.\n        1 for the primary and 2 for the secondary.\n    cfg : dict\n        The configuration dictionairy.\n\n    Returns\n    -------\n    adjustments : NDArray[np.float32]\n        The adjustments to make for the panel.\n        This is a 17 element array with the following structure:\n        `[mnum, panel_row, panel_col, dx, dy, d_adj1, ..., d_adj5, dx_err, dy_err, d_adj1_err, ..., d_adj5_err]`.\n    \"\"\"\n    adjustments = np.zeros(17, np.float32)\n    adjustments[0] = mnum\n    adjustments[1] = panel.row\n    adjustments[2] = panel.col\n    meas_adj = panel.meas_adj.copy()\n    meas_adj[:, 2] += panel.meas_adj_resid\n    meas_surface = panel.meas_surface.copy()\n    meas_surface[:, 2] += panel.meas_adj_resid\n    dy, dy, d_adj, dx_err, dy_err, d_adj_err = adj.calc_adjustments(\n        panel.can_surface, meas_surface, meas_adj, **cfg.get(\"adjust\", {})\n    )\n    adjustments[3:] = np.array(\n        [dy, dy] + list(d_adj) + [dx_err, dy_err] + list(d_adj_err)\n    )\n\n    return adjustments\n</code></pre>"},{"location":"reference/fitting/","title":"fitting","text":"<p>Functions for fitting against the mirror surface.</p>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_fit","title":"<code>mirror_fit(points, a, compensate=0, to_points=True, **kwargs)</code>","text":"<p>Fit points against the mirror surface. Ideally the points should be in the mirror's local coordinate system.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[floating]</code> <p>Array of points to compare against the mirror. Should have shape (npoint, 3).</p> required <code>a</code> <code>NDArray[floating]</code> <p>Coeffecients of the mirror function. Use a_primary for the primary mirror and a_secondary for the secondary.</p> required <code>compensate</code> <code>float</code> <p>Amount to compensate the mirror surface by. This is useful to model things like the surface traced out by an SMR.</p> <code>0.0</code> <code>to_points</code> <code>bool</code> <p>If True, the transform will be inverted to align the model to the points.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments to pass on to scipy.optimize.minimize.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>transform_pars</code> <code>NDArray[floating]</code> <p>Flattened affine transform and shift, has to be 1d for use with minimizers. Will have shape (12,) where the first 9 elements are the flattened affine transform, and the last 3 are the shift in (x, y, z) applied after the affine transform.</p> <code>rms</code> <code>float</code> <p>The RMS error between the transformed points and the model.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_fit(\n    points: NDArray[np.floating],\n    a: NDArray[np.floating],\n    compensate: float = 0,\n    to_points: bool = True,\n    **kwargs,\n) -&gt; tuple[NDArray[np.floating], float]:\n    \"\"\"\n    Fit points against the mirror surface.\n    Ideally the points should be in the mirror's local coordinate system.\n\n    Parameters\n    ----------\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n    a : NDArray[np.floating]\n        Coeffecients of the mirror function.\n        Use a_primary for the primary mirror and a_secondary for the secondary.\n    compensate : float, default: 0.0\n        Amount to compensate the mirror surface by.\n        This is useful to model things like the surface traced out by an SMR.\n    to_points : bool, default: True\n        If True, the transform will be inverted to align the model to the points.\n    **kwargs\n        Additional arguments to pass on to scipy.optimize.minimize.\n\n    Returns\n    -------\n    transform_pars : NDArray[np.floating]\n        Flattened affine transform and shift, has to be 1d for use with minimizers.\n        Will have shape (12,) where the first 9 elements are the flattened affine transform,\n        and the last 3 are the shift in (x, y, z) applied after the affine transform.\n    rms : float\n        The RMS error between the transformed points and the model.\n    \"\"\"\n\n    def _fit_func(transform_pars, points, a, compensate):\n        points_transformed = mirror_transform(transform_pars, points)\n        chisq = mirror_objective(points_transformed, a, compensate)\n        return chisq\n\n    x0 = np.concatenate((np.eye(3).ravel(), np.zeros(3)))\n    res = opt.minimize(_fit_func, x0, args=(points, a, compensate), **kwargs)\n\n    transform_pars = res.x\n    transformed = mirror_transform(transform_pars, points)\n    z = mr.mirror(transformed[:, 0], transformed[:, 1], a, compensate)\n    rms = np.sqrt(np.mean((z - transformed[:, 2]) ** 2))\n\n    if to_points:\n        aff = transform_pars[:9].reshape((3, 3))\n        sft = transform_pars[9:]\n        aff = np.linalg.inv(aff)\n        sft = (-1 * sft) @ aff\n        transform_pars = np.concatenate((aff.ravel(), sft))\n\n    return transform_pars, rms\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_objective","title":"<code>mirror_objective(points, a, compensate=0)</code>","text":"<p>Objective function to minimize when fitting to mirror surface. Essentially just a curvature weighted chisq.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[floating]</code> <p>Array of points to compare against the mirror. Should have shape (npoint, 3).</p> required <code>a</code> <code>NDArray[floating]</code> <p>Coeffecients of the mirror function. Use a_primary for the primary mirror and a_secondary for the secondary.</p> required <code>compensate</code> <code>float</code> <p>Amount to compensate the mirror surface by. This is useful to model things like the surface traced out by an SMR.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>chisq</code> <code>float</code> <p>The value to minimize when fitting to.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_objective(\n    points: NDArray[np.floating], a: NDArray[np.floating], compensate: float = 0\n) -&gt; float:\n    \"\"\"\n    Objective function to minimize when fitting to mirror surface.\n    Essentially just a curvature weighted chisq.\n\n    Parameters\n    ----------\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n    a : NDArray[np.floating]\n        Coeffecients of the mirror function.\n        Use a_primary for the primary mirror and a_secondary for the secondary.\n    compensate : float, default: 0.0\n        Amount to compensate the mirror surface by.\n        This is useful to model things like the surface traced out by an SMR.\n\n    Returns\n    -------\n    chisq : float\n        The value to minimize when fitting to.\n    \"\"\"\n    surface = mr.mirror(points[:, 0], points[:, 1], a, compensate)\n    norm = mr.mirror_norm(points[:, 0], points[:, 1], a)\n    res = (points[:, 2] - surface) * (norm[2] ** 2)\n\n    return res @ res.T\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_transform","title":"<code>mirror_transform(transform_pars, points)</code>","text":"<p>Function to apply an affine transform to the mirror. This is the transform we are fitting for.</p> <p>Parameters:</p> Name Type Description Default <code>transform_pars</code> <code>NDArray[floating]</code> <p>Flattened affine transform and shift, has to be 1d for use with minimizers. Should have shape (12,) where the first 9 elements are the flattened affine transform, and the last 3 are the shift in (x, y, z) applied after the affine transform.</p> required <code>points</code> <code>NDArray[floating]</code> <p>Array of points to compare against the mirror. Should have shape (npoint, 3).</p> required <p>Returns:</p> Name Type Description <code>points_transformed</code> <code>NDArray[floating]</code> <p>Array of transformed points. Will have shape (npoint, 3).</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_transform(\n    transform_pars: NDArray[np.floating], points: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Function to apply an affine transform to the mirror.\n    This is the transform we are fitting for.\n\n    Parameters\n    ----------\n    transform_pars : NDArray[np.floating]\n        Flattened affine transform and shift, has to be 1d for use with minimizers.\n        Should have shape (12,) where the first 9 elements are the flattened affine transform,\n        and the last 3 are the shift in (x, y, z) applied after the affine transform.\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n\n    Returns\n    -------\n    points_transformed : NDArray[np.floating]\n        Array of transformed points.\n        Will have shape (npoint, 3).\n    \"\"\"\n    aff = transform_pars[:9].reshape((3, 3))\n    sft = transform_pars[9:]\n    return points @ aff + sft\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.res_auto_corr","title":"<code>res_auto_corr(residuals)</code>","text":"<p>Compute auto correlation of residuals from fit.</p> <p>Parameters:</p> Name Type Description Default <code>residuals</code> <code>NDArray[floating]</code> <p>Residuals between measured point cloud and fit model.</p> required <p>Returns:</p> Name Type Description <code>ac</code> <code>NDArray[floating]</code> <p>Auto correlation, really just the deviations in mm at each distance scale.</p> <code>ac_dists</code> <code>NDArray[floating]</code> <p>Distance scale of each value in ac.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def res_auto_corr(\n    residuals: NDArray[np.floating],\n) -&gt; tuple[NDArray[np.floating], NDArray[np.floating]]:\n    \"\"\"\n    Compute auto correlation of residuals from fit.\n\n    Parameters\n    ----------\n    residuals : NDArray[np.floating]\n        Residuals between measured point cloud and fit model.\n\n    Returns\n    -------\n    ac : NDArray[np.floating]\n        Auto correlation, really just the deviations in mm at each distance scale.\n    ac_dists : NDArray[np.floating]\n        Distance scale of each value in ac.\n    \"\"\"\n    dists = np.zeros((len(residuals), len(residuals)))\n    res_diff = np.zeros((len(residuals), len(residuals)))\n\n    for i in range(len(residuals)):\n        res1 = residuals[i]\n        for j in range(i):\n            res2 = residuals[j]\n            dist = np.linalg.norm((res1[0] - res2[0], res1[1] - res2[1]))\n            dists[i, j] = dist\n            res_diff[i, j] = abs(res1[2] - res2[2])\n    tri_i = np.tril_indices(len(residuals), k=-1)\n    dists = dists[tri_i]\n    res_diff = res_diff[tri_i]\n    ac, bin_e, _ = binned_statistic(dists, res_diff, bins=100)\n    ac_dists = bin_e[:-1] + np.diff(bin_e) / 2.0\n\n    return ac, ac_dists\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.tension_fit","title":"<code>tension_fit(residuals, **kwargs)</code>","text":"<p>Fit a power law model of tension to a point cloud of residuals.</p> <p>Parameters:</p> Name Type Description Default <code>residuals</code> <code>NDArray[floating]</code> <p>Residuals between measured point cloud and fit model.</p> required <code>**kwargs</code> <p>Arguments to be passed to scipy.optimize.minimize</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tension_pars</code> <code>NDArray[floating]</code> <p>The fit parameters, see docstring of tension_model for details.</p> <code>rms</code> <code>float</code> <p>The rms between the input residuals and the fit model.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def tension_fit(\n    residuals: NDArray[np.floating], **kwargs\n) -&gt; tuple[NDArray[np.floating], float]:\n    \"\"\"\n    Fit a power law model of tension to a point cloud of residuals.\n\n    Parameters\n    ----------\n    residuals : NDArray[np.floating]\n        Residuals between measured point cloud and fit model.\n    **kwargs\n        Arguments to be passed to scipy.optimize.minimize\n\n    Returns\n    -------\n    tension_pars : NDArray[np.floating]\n        The fit parameters, see docstring of tension_model for details.\n    rms : float\n        The rms between the input residuals and the fit model.\n    \"\"\"\n\n    def min_func(pars, residuals):\n        _z = tension_model(*pars[:5], residuals)\n        return np.sqrt(np.mean((residuals[:, 2] - _z) ** 2))\n\n    if \"bounds\" not in kwargs:\n        ptp = np.ptp(residuals[:, 2])\n        bounds = [\n            (np.min(residuals[:, 0]), np.max(residuals[:, 0])),\n            (np.min(residuals[:, 1]), np.max(residuals[:, 1])),\n            (-1 * ptp, ptp),\n            (1e-10, np.inf),\n            (0, np.inf),\n        ]\n        kwargs[\"bounds\"] = bounds\n    x0 = [np.mean(residuals[:, 0]), np.mean(residuals[:, 1]), 0, 1, 0]\n    res = opt.minimize(min_func, x0, (residuals,), **kwargs)\n    return res.x, res.fun\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.tension_model","title":"<code>tension_model(x0, y0, t, a, b, points)</code>","text":"<p>Function to model incorrect panel tensioning. Currently the model used is a radial power law.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>float</code> <p>Center of the power law in x.</p> required <code>y0</code> <code>float</code> <p>Center of the power law in y.</p> required <code>t</code> <code>float.</code> <p>Amplitude of power law, nominally the offset due to tensioning in the center of panel.</p> required <code>a</code> <code>float</code> <p>Base of power law.</p> required <code>b</code> <code>float</code> <p>Exponential scale factor of power law</p> required <code>points</code> <code>NDArray[floating]</code> <p>Points to compute power law at. Only the x and y coordinates are used (first two collumns). So should be (npoint, 2) but (npoint, ndim&gt;2) is also fine.</p> required <p>Returns:</p> Name Type Description <code>z</code> <code>NDArray[floating]</code> <p>Power law model at each xy. Will have shape (npoint,).</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def tension_model(\n    x0: float, y0: float, t: float, a: float, b: float, points: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Function to model incorrect panel tensioning.\n    Currently the model used is a radial power law.\n\n\n    Parameters\n    ----------\n    x0 : float\n        Center of the power law in x.\n    y0 : float\n        Center of the power law in y.\n    t : float.\n        Amplitude of power law,\n        nominally the offset due to tensioning in the center of panel.\n    a : float\n        Base of power law.\n    b : float\n        Exponential scale factor of power law\n    points : NDArray[np.floating]\n        Points to compute power law at.\n        Only the x and y coordinates are used (first two collumns).\n        So should be (npoint, 2) but (npoint, ndim&gt;2) is also fine.\n\n    Returns\n    -------\n    z : NDArray[np.floating]\n        Power law model at each xy.\n        Will have shape (npoint,).\n    \"\"\"\n    # Avoid divide by 0 error\n    if a == 0:\n        return np.zeros(len(points))\n\n    # Compute radius at each point\n    r = np.sqrt((points[:, 0] - x0) ** 2 + (points[:, 1] - y0) ** 2)\n\n    # Return power law\n    return t * (a ** (-b * r))\n</code></pre>"},{"location":"reference/io/","title":"io","text":""},{"location":"reference/io/#lat_alignment.io.load_adjusters","title":"<code>load_adjusters(path, mirror)</code>","text":"<p>Get nominal adjuster locations from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the data file.</p> required <code>mirror</code> <code>str</code> <p>The mirror that these points belong to. Should be either: 'primary' or 'secondary'.</p> <code>'primary'</code> <p>Returns:</p> Name Type Description <code>adjusters</code> <code>dict[tuple[int, int], NDArray[float32]]</code> <p>Nominal adjuster locations. This is indexed by a (row, col) tuple. Each entry is <code>(5, 3)</code> array where each row is an adjuster.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_adjusters(\n    path: str, mirror: str\n) -&gt; dict[tuple[int, int], NDArray[np.float32]]:\n    \"\"\"\n    Get nominal adjuster locations from file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the data file.\n    mirror : str, default: 'primary'\n        The mirror that these points belong to.\n        Should be either: 'primary' or 'secondary'.\n\n    Returns\n    -------\n    adjusters : dict[tuple[int, int], NDArray[np.float32]]\n        Nominal adjuster locations.\n        This is indexed by a (row, col) tuple.\n        Each entry is `(5, 3)` array where each row is an adjuster.\n    \"\"\"\n    if mirror not in [\"primary\", \"secondary\"]:\n        raise ValueError(f\"Invalid mirror: {mirror}\")\n\n    def _transform(coords):\n        coords = np.atleast_2d(coords)\n        coords -= np.array([120, 0, 0])  # cancel out shift\n        return coord_transform(coords, \"va_global\", f\"opt_{mirror}\")\n\n    # TODO: cleaner transform call\n    adjusters = defaultdict(list)\n    c_points = np.genfromtxt(path, dtype=str)\n    for point in c_points:\n        row = point[0][6]\n        col = point[0][7]\n        adjusters[(row, col)] += [_transform(np.array(point[2:], dtype=np.float32))[0]]\n    adjusters = {rc: np.vstack(pts) for rc, pts in adjusters.items()}\n\n    return adjusters\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_corners","title":"<code>load_corners(path)</code>","text":"<p>Get panel corners from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the data file.</p> required <p>Returns:</p> Name Type Description <code>corners</code> <code>dict[tuple[int, int], ndarray[float32]]</code> <p>The corners. This is indexed by a (row, col) tuple. Each entry is <code>(4, 3)</code> array where each row is a corner.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_corners(path: str) -&gt; dict[tuple[int, int], NDArray[np.float32]]:\n    \"\"\"\n    Get panel corners from file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the data file.\n\n    Returns\n    -------\n    corners : dict[tuple[int, int], ndarray[np.float32]]\n        The corners. This is indexed by a (row, col) tuple.\n        Each entry is `(4, 3)` array where each row is a corner.\n    \"\"\"\n    with open(path) as file:\n        corners_raw = yaml.safe_load(file)\n\n    corners = {\n        (panel[7], panel[9]): np.vstack(\n            [np.array(coord.split(), np.float32) for coord in coords]\n        )\n        for panel, coords in corners_raw.items()\n    }\n    return corners\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_photo","title":"<code>load_photo(path, align=True, err_thresh=2, plot=True, **kwargs)</code>","text":"<p>Load photogrammetry data. Assuming first column is target names and next three are (x, y , z).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the photogrammetry data.</p> required <code>align</code> <code>bool</code> <p>If True align using the invar points.</p> <code>True</code> <code>err_thresh</code> <code>float</code> <p>How many times the median photogrammetry error a target need to have to be cut.</p> <code>2</code> <code>plot</code> <code>bool</code> <p>If True display a scatter plot of targets.</p> <code>True</code> <code>**kwargs</code> <p>Arguments to pass to <code>align_photo</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>data</code> <code>dict[str, NDArray[float32]]</code> <p>The photogrammetry data. Dict is indexed by the target names.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_photo(\n    path: str, align: bool = True, err_thresh: float = 2, plot: bool = True, **kwargs\n) -&gt; dict[str, NDArray[np.float32]]:\n    \"\"\"\n    Load photogrammetry data.\n    Assuming first column is target names and next three are (x, y , z).\n\n    Parameters\n    ----------\n    path : str\n        The path to the photogrammetry data.\n    align : bool, default: True\n        If True align using the invar points.\n    err_thresh : float, default: 2\n        How many times the median photogrammetry error\n        a target need to have to be cut.\n    plot: bool, default: True\n        If True display a scatter plot of targets.\n    **kwargs\n        Arguments to pass to `align_photo`.\n\n    Returns\n    -------\n    data : dict[str, NDArray[np.float32]]\n        The photogrammetry data.\n        Dict is indexed by the target names.\n    \"\"\"\n    labels = np.genfromtxt(path, dtype=str, delimiter=\",\", usecols=(0,))\n    coords = np.genfromtxt(path, dtype=np.float32, delimiter=\",\", usecols=(1, 2, 3))\n    errs = np.genfromtxt(path, dtype=np.float32, delimiter=\",\", usecols=(4, 5, 6))\n    msk = (np.char.find(labels, \"TARGET\") &gt;= 0) + (np.char.find(labels, \"CODE\") &gt;= 0)\n\n    labels, coords, errs = labels[msk], coords[msk], errs[msk]\n    err = np.linalg.norm(errs, axis=-1)\n\n    if align:\n        labels, coords, msk = align_photo(labels, coords, **kwargs)\n        err = err[msk]\n    trg_msk = np.char.find(labels, \"TARGET\") &gt;= 0\n    labels = labels[trg_msk]\n    coords = coords[trg_msk]\n    err = err[trg_msk]\n\n    err_msk = err &lt; err_thresh * np.median(err)\n    labels, coords, err = labels[err_msk], coords[err_msk], err[err_msk]\n\n    # Lets find and remove doubles\n    # Dumb brute force\n    edm = make_edm(coords[:, :2])\n    np.fill_diagonal(edm, np.nan)\n    to_kill = []\n    for i in range(len(edm)):\n        if i in to_kill:\n            continue\n        imin = np.nanargmin(edm[i])\n        if edm[i][imin] &gt; 20:\n            continue\n        if err[i] &lt; err[imin]:\n            to_kill += [imin]\n        else:\n            to_kill += [i]\n    msk = ~np.isin(np.arange(len(coords), dtype=int), to_kill)\n    labels, coords = labels[msk], coords[msk]\n\n    if plot:\n        plt.scatter(coords[:, 0], coords[:, 1], c=coords[:, 2], marker=\"x\")\n        plt.colorbar()\n        plt.show()\n\n    data = {label: coord for label, coord in zip(labels, coords)}\n    return data\n</code></pre>"},{"location":"reference/mirror/","title":"mirror","text":"<p>Functions to describe the mirror surface.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel","title":"<code>Panel</code>  <code>dataclass</code>","text":"<p>Dataclass for storing a mirror panel.</p> <p>Attributes:</p> Name Type Description <code>mirror</code> <code>str</code> <p>Which mirror this panel is for. Should be 'primary' or 'secondary'.</p> <code>row</code> <code>int</code> <p>The row of the panel.</p> <code>col</code> <code>int</code> <p>The column of the panel.</p> <code>corners</code> <code>NDArray[float32]</code> <p>Array of panel corners. Should have shape <code>(4, 3)</code>.</p> <code>measurements</code> <code>NDArray[float32]</code> <p>The measurement data for this panel. Should be in the mirror's internal coords. Should have shape <code>(npoint, 3)</code>.</p> <code>nom_adj</code> <code>NDArray[float32]</code> <p>The nominal position of the adjusters in the mirror internal coordinates. Should have shape <code>(5, 3)</code>.</p> <code>compensate</code> <code>float, default: 0</code> <p>The amount (in mm) to compensate the model surface by. This is to account for things like the Faro SMR.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>@dataclass\nclass Panel:\n    \"\"\"\n    Dataclass for storing a mirror panel.\n\n    Attributes\n    ----------\n    mirror : str\n        Which mirror this panel is for.\n        Should be 'primary' or 'secondary'.\n    row : int\n        The row of the panel.\n    col : int\n        The column of the panel.\n    corners : NDArray[np.float32]\n        Array of panel corners.\n        Should have shape `(4, 3)`.\n    measurements : NDArray[np.float32]\n        The measurement data for this panel.\n        Should be in the mirror's internal coords.\n        Should have shape `(npoint, 3)`.\n    nom_adj : NDArray[np.float32]\n        The nominal position of the adjusters in the mirror internal coordinates.\n        Should have shape `(5, 3)`.\n    compensate : float, default: 0\n        The amount (in mm) to compensate the model surface by.\n        This is to account for things like the Faro SMR.\n    \"\"\"\n\n    mirror: str\n    row: int\n    col: int\n    corners: NDArray[np.float32]\n    measurements: NDArray[np.float32]\n    nom_adj: NDArray[np.float32]\n    compensate: float = field(default=0.0)\n    adjuster_radius: float = field(default=50.0)\n\n    def __post_init__(self):\n        self.measurements = np.atleast_2d(self.measurements)\n\n    def __setattr__(self, name, value):\n        if (\n            name == \"nom_adj\"\n            or name == \"mirror\"\n            or name == \"measurements\"\n            or name == \"compensate\"\n        ):\n            self.__dict__.pop(\"can_surface\", None)\n            self.__dict__.pop(\"model\", None)\n            self.__dict__.pop(\"residuals\", None)\n            self.__dict__.pop(\"transformed_residuals\", None)\n            self.__dict__.pop(\"res_norm\", None)\n            self.__dict__.pop(\"rms\", None)\n            self.__dict__.pop(\"meas_surface\", None)\n            self.__dict__.pop(\"meas_adj\", None)\n            self.__dict__.pop(\"meas_adj_resid\", None)\n            self.__dict__.pop(\"model_transformed\", None)\n            self.__dict__.pop(\"_transform\", None)\n        elif name == \"adjuster_radius\":\n            self.__dict__.pop(\"meas_adj_resid\", None)\n        return super().__setattr__(name, value)\n\n    @cached_property\n    def model(self):\n        \"\"\"\n        The modeled mirror surface at the locations of the measurementss.\n        \"\"\"\n        model = self.measurements.copy()\n        model[:, 2] = mirror_surface(model[:, 0], model[:, 1], a[self.mirror])\n        if self.compensate != 0.0:\n            compensation = self.compensate * mirror_norm(\n                model[:, 0], model[:0], a[self.mirror]\n            )\n            model += compensation\n        return model\n\n    @cached_property\n    def _transform(self):\n        return get_rigid(self.model, self.measurements, center_dst=True, method=\"mean\")\n\n    @property\n    def rot(self):\n        \"\"\"\n        Rotation that aligns the model to the measurements.\n        \"\"\"\n        return self._transform[0]\n\n    @property\n    def shift(self):\n        \"\"\"\n        Shift that aligns the model to the measurements.\n        \"\"\"\n        return self._transform[1]\n\n    @cached_property\n    def can_surface(self):\n        \"\"\"\n        Get the cannonical points to define the panel surface.\n        These are the adjuster positions projected only the mirror surface.\n        Note that this is in the nominal coordinates not the measured ones.\n        \"\"\"\n        can_z = mirror_surface(self.nom_adj[:, 0], self.nom_adj[:, 1], a[self.mirror])\n        points = self.nom_adj.copy()\n        points[:, 2] = can_z\n        return points\n\n    @cached_property\n    def meas_surface(self):\n        \"\"\"\n        The cannonical surface transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.can_surface, self.rot, self.shift)\n\n    @cached_property\n    def meas_adj(self):\n        \"\"\"\n        The adjuster points transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.nom_adj, self.rot, self.shift)\n\n    @cached_property\n    def meas_adj_resid(self):\n        \"\"\"\n        A correction that can be applied to `meas_adj` where we compute\n        the average residual of measured points from the transformed model\n        that are within `adjuster_radius` of the adjuster point in `xy`.\n        \"\"\"\n        resid = np.zeros(len(self.meas_adj))\n        for i, adj in enumerate(self.meas_adj):\n            dists = np.linalg.norm(self.measurements[:, :2] - adj[:2], axis=-1)\n            msk = dists &lt;= self.adjuster_radius\n            if np.sum(msk) == 0:\n                continue\n            resid[i] = np.mean(self.transformed_residuals[msk, 2])\n\n        return resid\n\n    @cached_property\n    def model_transformed(self):\n        \"\"\"\n        The model transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.model, self.rot, self.shift)\n\n    @cached_property\n    def residuals(self):\n        \"\"\"\n        Get residuals between model and measurements.\n        \"\"\"\n        return self.measurements - self.model\n\n    @cached_property\n    def transformed_residuals(self):\n        \"\"\"\n        Get residuals between transformed model and measurements.\n        \"\"\"\n        return self.measurements - self.model_transformed\n\n    @cached_property\n    def res_norm(self):\n        \"\"\"\n        Get norm of residuals between transformed model and measurements.\n        \"\"\"\n        return np.linalg.norm(self.residuals, axis=-1)\n\n    @cached_property\n    def rms(self):\n        \"\"\"\n        Get rms between model and measurements.\n        \"\"\"\n        return np.sqrt(np.mean(self.residuals[:, 2].ravel() ** 2))\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.can_surface","title":"<code>can_surface</code>  <code>cached</code> <code>property</code>","text":"<p>Get the cannonical points to define the panel surface. These are the adjuster positions projected only the mirror surface. Note that this is in the nominal coordinates not the measured ones.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_adj","title":"<code>meas_adj</code>  <code>cached</code> <code>property</code>","text":"<p>The adjuster points transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_adj_resid","title":"<code>meas_adj_resid</code>  <code>cached</code> <code>property</code>","text":"<p>A correction that can be applied to <code>meas_adj</code> where we compute the average residual of measured points from the transformed model that are within <code>adjuster_radius</code> of the adjuster point in <code>xy</code>.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_surface","title":"<code>meas_surface</code>  <code>cached</code> <code>property</code>","text":"<p>The cannonical surface transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.model","title":"<code>model</code>  <code>cached</code> <code>property</code>","text":"<p>The modeled mirror surface at the locations of the measurementss.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.model_transformed","title":"<code>model_transformed</code>  <code>cached</code> <code>property</code>","text":"<p>The model transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.res_norm","title":"<code>res_norm</code>  <code>cached</code> <code>property</code>","text":"<p>Get norm of residuals between transformed model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.residuals","title":"<code>residuals</code>  <code>cached</code> <code>property</code>","text":"<p>Get residuals between model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.rms","title":"<code>rms</code>  <code>cached</code> <code>property</code>","text":"<p>Get rms between model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.rot","title":"<code>rot</code>  <code>property</code>","text":"<p>Rotation that aligns the model to the measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.shift","title":"<code>shift</code>  <code>property</code>","text":"<p>Shift that aligns the model to the measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.transformed_residuals","title":"<code>transformed_residuals</code>  <code>cached</code> <code>property</code>","text":"<p>Get residuals between transformed model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.gen_panels","title":"<code>gen_panels(mirror, measurements, corners, adjusters, compensate=0.0, adjuster_radius=50.0)</code>","text":"<p>Use a set of measurements to generate panel objects.</p> <p>Parameters:</p> Name Type Description Default <code>mirror</code> <code>str</code> <p>The mirror these panels belong to. Should be 'primary' or 'secondary'.</p> required <code>measurements</code> <code>dict[str, NDArray[float32]]</code> <p>The photogrammetry data. Dict is data indexed by the target names.</p> required <code>corners</code> <code>dict[tuple[int, int], ndarray[float32]]</code> <p>The corners. This is indexed by a (row, col) tuple. Each entry is <code>(4, 3)</code> array where each row is a corner.</p> required <code>adjusters</code> <code>dict[tuple[int, int], NDArray[float32]]</code> <p>Nominal adjuster locations. This is indexed by a (row, col) tuple. Each entry is <code>(5, 3)</code> array where each row is an adjuster.</p> required <code>compensate</code> <code>float</code> <p>Amount (in mm) to compensate the model surface by. This is to account for things like the faro SMR.</p> <code>0.0</code> <code>adjuster_radius</code> <code>float</code> <p>The radius in XY of points that an adjuster should use to compute a secondary correction on its position. Should be in mm.</p> <code>50.0</code> <p>Returns:</p> Name Type Description <code>panels</code> <code>list[Panels]</code> <p>A list of panels with the transforme initialized to the identity.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def gen_panels(\n    mirror: str,\n    measurements: dict[str, NDArray[np.float32]],\n    corners: dict[tuple[int, int], NDArray[np.float32]],\n    adjusters: dict[tuple[int, int], NDArray[np.float32]],\n    compensate: float = 0.0,\n    adjuster_radius: float = 50.0,\n) -&gt; list[Panel]:\n    \"\"\"\n    Use a set of measurements to generate panel objects.\n\n    Parameters\n    ----------\n    mirror : str\n        The mirror these panels belong to.\n        Should be 'primary' or 'secondary'.\n    measurements : dict[str, NDArray[np.float32]]\n        The photogrammetry data.\n        Dict is data indexed by the target names.\n    corners : dict[tuple[int, int], ndarray[np.float32]]\n        The corners. This is indexed by a (row, col) tuple.\n        Each entry is `(4, 3)` array where each row is a corner.\n    adjusters : dict[tuple[int, int], NDArray[np.float32]]\n        Nominal adjuster locations.\n        This is indexed by a (row, col) tuple.\n        Each entry is `(5, 3)` array where each row is an adjuster.\n    compensate : float, default: 0.0\n        Amount (in mm) to compensate the model surface by.\n        This is to account for things like the faro SMR.\n    adjuster_radius : float, default: 50.0\n        The radius in XY of points that an adjuster should use to\n        compute a secondary correction on its position.\n        Should be in mm.\n\n    Returns\n    -------\n    panels : list[Panels]\n        A list of panels with the transforme initialized to the identity.\n    \"\"\"\n    points = defaultdict(list)\n    # dumb brute force\n    corr = np.arange(4, dtype=int)\n    for _, point in measurements.items():\n        for rc, crns in corners.items():\n            x = crns[:, 0] &gt; point[0]\n            y = crns[:, 1] &gt; point[1]\n            val = x.astype(int) + 2 * y.astype(int)\n            if np.array_equal(np.sort(val), corr):\n                points[rc] += [point]\n                break\n\n    # Now init the objects\n    panels = []\n    for (row, col), meas in points.items():\n        meas = np.vstack(meas, dtype=np.float32)\n        panel = Panel(\n            mirror,\n            row,\n            col,\n            corners[(row, col)],\n            meas,\n            adjusters[(row, col)],\n            compensate,\n            adjuster_radius,\n        )\n        panels += [panel]\n    return panels\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.mirror_norm","title":"<code>mirror_norm(x, y, a)</code>","text":"<p>Analytic form of the vector normal to the mirror surface.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float32]</code> <p>X positions to calculate at in mm.</p> required <code>y</code> <code>NDArray[float32]</code> <p>Y positions to calculate at in mm. Should have the same shape as <code>x</code>.</p> required <code>a</code> <code>NDArray[float32]</code> <p>Coeffecients of the mirror function. Use <code>a_primary</code> for the primary mirror. Use <code>a_secondary</code> for the secondary mirror.</p> required <p>Returns:</p> Name Type Description <code>normals</code> <code>NDArray[float32]</code> <p>Unit vector normal to the mirror surface at each input coordinate. Has shape <code>shape(x) + (3,)</code>.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def mirror_norm(\n    x: NDArray[np.float32], y: NDArray[np.float32], a: NDArray[np.float32]\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Analytic form of the vector normal to the mirror surface.\n\n    Parameters\n    ----------\n    x : NDArray[np.float32]\n        X positions to calculate at in mm.\n    y : NDArray[np.float32]\n        Y positions to calculate at in mm.\n        Should have the same shape as `x`.\n    a : NDArray[np.float32]\n        Coeffecients of the mirror function.\n        Use `a_primary` for the primary mirror.\n        Use `a_secondary` for the secondary mirror.\n\n    Returns\n    -------\n    normals : NDArray[np.float32]\n        Unit vector normal to the mirror surface at each input coordinate.\n        Has shape `shape(x) + (3,)`.\n    \"\"\"\n    Rn = 3000.0\n\n    x_n = np.zeros_like(x)\n    y_n = np.zeros_like(y)\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):\n            if i != 0:\n                x_n += a[i, j] * (x ** (i - 1)) / (Rn**i) * (y / Rn) ** j\n            if j != 0:\n                y_n += a[i, j] * (x / Rn) ** i * (y ** (j - 1)) / (Rn**j)\n\n    z_n = -1 * np.ones_like(x_n)\n    normals = np.array((x_n, y_n, z_n)).T\n    normals /= np.linalg.norm(normals, axis=-1)[:, np.newaxis]\n    return normals\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.mirror_surface","title":"<code>mirror_surface(x, y, a)</code>","text":"<p>Analytic form of the mirror surface.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float32]</code> <p>X positions to calculate at in mm.</p> required <code>y</code> <code>NDArray[float32]</code> <p>Y positions to calculate at in mm. Should have the same shape as <code>x</code>.</p> required <code>a</code> <code>NDArray[float32]</code> <p>Coeffecients of the mirror function. Use <code>a_primary</code> for the primary mirror. Use <code>a_secondary</code> for the secondary mirror.</p> required <p>Returns:</p> Name Type Description <code>z</code> <code>NDArray[float32]</code> <p>Z position of the mirror at each input coordinate. Has the same shape as <code>x</code>.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def mirror_surface(\n    x: NDArray[np.float32], y: NDArray[np.float32], a: NDArray[np.float32]\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Analytic form of the mirror surface.\n\n    Parameters\n    ----------\n    x : NDArray[np.float32]\n        X positions to calculate at in mm.\n    y : NDArray[np.float32]\n        Y positions to calculate at in mm.\n        Should have the same shape as `x`.\n    a : NDArray[np.float32]\n        Coeffecients of the mirror function.\n        Use `a_primary` for the primary mirror.\n        Use `a_secondary` for the secondary mirror.\n\n    Returns\n    -------\n    z : NDArray[np.float32]\n        Z position of the mirror at each input coordinate.\n        Has the same shape as `x`.\n    \"\"\"\n    z = np.zeros_like(x)\n    Rn = 3000.0\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):\n            z += a[i, j] * (x / Rn) ** i * (y / Rn) ** j\n    return z\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.plot_panels","title":"<code>plot_panels(panels, title_str, vmax=None)</code>","text":"<p>Make a plot containing panel residuals and histogram. TODO: Correlation?</p> <p>Parameters:</p> Name Type Description Default <code>panels</code> <code>list[Panel]</code> <p>The panels to plot.</p> required <code>title_str</code> <code>str</code> <p>The title string, rms will me appended.</p> required <code>vmax</code> <code>Optional[float]</code> <p>The max of the colorbar. vmin will be -1 times this. Set to None to compute automatically. Should be in um.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>figure</code> <code>Figure</code> <p>The figure with panels plotted on it.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def plot_panels(\n    panels: list[Panel], title_str: str, vmax: Optional[float] = None\n) -&gt; Figure:\n    \"\"\"\n    Make a plot containing panel residuals and histogram.\n    TODO: Correlation?\n\n    Parameters\n    ----------\n    panels : list[Panel]\n        The panels to plot.\n    title_str : str\n        The title string, rms will me appended.\n    vmax : Optional[float], default: None\n        The max of the colorbar. vmin will be -1 times this.\n        Set to None to compute automatically.\n        Should be in um.\n\n    Returns\n    -------\n    figure : Figure\n        The figure with panels plotted on it.\n    \"\"\"\n    res_all = np.vstack([panel.residuals for panel in panels]) * 1000\n    model_all = np.vstack([panel.model for panel in panels])\n    if vmax is None:\n        vmax = np.max(np.abs(res_all[:, 2]))\n    if vmax is None:\n        raise ValueError(\"vmax still None?\")\n    gs = gridspec.GridSpec(2, 2, width_ratios=[20, 1], height_ratios=[2, 1])\n    fig = plt.figure()\n    ax0 = plt.subplot(gs[0])\n    cax = plt.subplot(gs[1])\n    ax1 = plt.subplot(gs[2:])\n    cb = None\n    for panel in panels:\n        ax0.tricontourf(\n            panel.model[:, 0],\n            panel.model[:, 1],\n            panel.residuals[:, 2] * 1000,\n            vmin=-1 * vmax,\n            vmax=vmax,\n            cmap=\"coolwarm\",\n            alpha=0.6,\n        )\n        cb = ax0.scatter(\n            panel.model[:, 0],\n            panel.model[:, 1],\n            s=40,\n            c=panel.residuals[:, 2] * 1000,\n            vmin=-1 * vmax,\n            vmax=vmax,\n            cmap=\"coolwarm\",\n            marker=\"o\",\n            alpha=0.9,\n            linewidth=2,\n            edgecolor=\"black\",\n        )\n        ax0.scatter(\n            panel.meas_adj[:, 0],\n            panel.meas_adj[:, 1],\n            marker=\"x\",\n            linewidth=1,\n            color=\"black\",\n        )\n    ax0.tricontourf(\n        model_all[:, 0],\n        model_all[:, 1],\n        res_all[:, 2],\n        vmin=-1 * vmax,\n        vmax=vmax,\n        cmap=\"coolwarm\",\n        alpha=0.2,\n    )\n    ax0.set_xlabel(\"x (mm)\")\n    ax0.set_ylabel(\"y (mm)\")\n    ax0.set_xlim(-3300, 3300)  # ack hardcoded!\n    ax0.set_ylim(-3300, 3300)\n    if cb is not None:\n        fig.colorbar(cb, cax)\n    ax0.set_aspect(\"equal\")\n    for panel in panels:\n        ax0.add_patch(\n            Polygon(panel.corners[[0, 1, 3, 2], :2], fill=False, color=\"black\")\n        )\n\n    ax1.hist(res_all[:, 2], bins=len(panels))\n    ax1.set_xlabel(\"z residual (um)\")\n\n    points = np.array([len(panel.measurements) for panel in panels])\n    rms = np.array([panel.rms for panel in panels])\n    tot_rms = 1000 * np.sum(rms * points) / np.sum(points)\n    fig.suptitle(f\"{title_str}, RMS={tot_rms:.2f} um\")\n\n    plt.show()\n\n    return fig\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.remove_cm","title":"<code>remove_cm(meas, mirror, compensate=0, thresh=10, cut_thresh=50, niters=10, verbose=False)</code>","text":"<p>Fit for the common mode transformation from the model to the measurements of all panels and them remove it. Note that we only remove the shift component of the common mode, rotations are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>meas</code> <code>dict[str, NDArray[float32]]</code> <p>The photogrammetry data. Dict is data indexed by the target names.</p> required <code>mirror</code> <code>str</code> <p>The mirror this data belong to. Should be 'primary' or 'secondary'.</p> required <code>compensate</code> <code>float</code> <p>Compensation to apply to model. This is to account for the radius of a Faro SMR.</p> <code>0</code> <code>thresh</code> <code>float</code> <p>How many times higher than the median residual a point needs to have to be considered an outlier.</p> <code>10</code> <code>niters</code> <code>int</code> <p>How many iterations of common mode fitting to do.</p> <code>10</code> <code>verbose</code> <code>bool</code> <p>If True print the transformation for each iteration.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>kept_panels</code> <code>list[Panel]</code> <p>The panels that were successfully fit.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def remove_cm(\n    meas,\n    mirror,\n    compensate: float = 0,\n    thresh: float = 10,\n    cut_thresh: float = 50,\n    niters: int = 10,\n    verbose=False,\n) -&gt; dict[str, NDArray[np.float32]]:\n    \"\"\"\n    Fit for the common mode transformation from the model to the measurements of all panels and them remove it.\n    Note that we only remove the shift component of the common mode, rotations are ignored.\n\n    Parameters\n    ----------\n    meas : dict[str, NDArray[np.float32]]\n        The photogrammetry data.\n        Dict is data indexed by the target names.\n    mirror : str\n        The mirror this data belong to.\n        Should be 'primary' or 'secondary'.\n    compensate : float, default: 0\n        Compensation to apply to model.\n        This is to account for the radius of a Faro SMR.\n    thresh : float, default: 10\n        How many times higher than the median residual a point needs to have to be\n        considered an outlier.\n    niters : int, default: 10\n        How many iterations of common mode fitting to do.\n    verbose : bool, default: False\n        If True print the transformation for each iteration.\n\n    Returns\n    -------\n    kept_panels : list[Panel]\n        The panels that were successfully fit.\n    \"\"\"\n\n    def _cm(x, panel):\n        panel.measurements[:] -= x[1:4]\n        rot = Rotation.from_euler(\"xyz\", x[4:])\n        panel.measurements = rot.apply(panel.measurements)\n        panel.measurements *= x[0]\n\n    def _opt(x, panel):\n        p2 = deepcopy(panel)\n        _cm(x, p2)\n        return p2.rms\n\n    # make a fake panel for the full mirror\n    corners = np.array(\n        ([-3300, -3300, 0], [-3300, 3300, 0], [3300, 3300, 0], [3300, -3300, 0])\n    )  # ack hardcoded\n    labels = np.array(list(meas.keys()))\n    data = np.array(list(meas.values()))\n    corr = np.arange(4, dtype=int)\n    x = np.vstack([corners[:, 0] &gt; dat[0] for dat in data])\n    y = np.vstack([corners[:, 1] &gt; dat[1] for dat in data])\n    val = x.astype(int) + 2 * y.astype(int)\n    val = np.sort(val, axis=-1)\n    msk = (val == corr).all(-1)\n    data = data[msk]\n    labels = labels[msk]\n    panel = Panel(\n        mirror,\n        -1,\n        -1,\n        np.zeros((4, 3), \"float32\"),\n        data,\n        np.zeros((5, 3), \"float32\"),\n        compensate,\n    )\n    data = data.copy()\n    data_clean = data.copy()\n\n    x0 = np.hstack([np.ones(1), np.zeros(6)])\n    bounds = [(-0.95, 1.05)] + [(-100, 100)] * 3 + [(0, 2 * np.pi)] * 3\n\n    for i in range(niters):\n        if len(panel.measurements) &lt; 3:\n            raise ValueError\n        print(f\"iter {i} for common mode fit\")\n        cut = panel.res_norm &gt; thresh * np.median(panel.res_norm)\n        if np.sum(cut) &gt; 0:\n            # print(f\"\\tRemoving {np.sum(cut)} points from mirror\")\n            panel.measurements = panel.measurements[~cut]\n            # labels = labels[~cut]\n            data = data[~cut]\n\n        if verbose:\n            print(f\"\\tRemoving a naive common mode shift of {panel.shift}\")\n        panel.measurements -= panel.shift\n        panel.measurements @= panel.rot.T\n\n        res = minimize(_opt, x0, (panel,), bounds=bounds)\n        if verbose:\n            print(\n                f\"\\tRemoving a fit common mode with scale {res.x[0]}, shift {res.x[1:4]}, and rotation {res.x[4:]}\"\n            )\n        _cm(res.x, panel)\n\n        if verbose:\n            print(\n                f\"\\tRemoving a secondary common mode shift of {panel.shift} and rotation of {decompose_rotation(panel.rot)}\"\n            )\n        panel.measurements -= panel.shift\n        panel.measurements @= panel.rot.T\n\n    aff, sft = get_affine(\n        data, panel.measurements, method=\"mean\", weights=np.ones(len(data))\n    )\n    scale, shear, rot = decompose_affine(aff)\n    rot = decompose_rotation(rot)\n    print(\n        f\"Full common mode is:\\n\\tshift = {sft} mm\\n\\tscale = {scale}\\n\\tshear = {shear}\\n\\trot = {np.rad2deg(rot)} deg\"\n    )\n\n    panel.measurements = apply_transform(data_clean, aff, sft)\n    cut = panel.res_norm &gt; cut_thresh * np.median(panel.res_norm)\n    if np.sum(cut) &gt; 0:\n        print(f\"Removing {np.sum(cut)} points from mirror\")\n        panel.measurements = panel.measurements[~cut]\n\n    return {l: d for l, d in zip(labels, panel.measurements)}\n</code></pre>"},{"location":"reference/transforms/","title":"transforms","text":"<p>Functions for coordinate transforms.</p> <p>There are 6 relevant coordinate systems here, belonging to two sets of three. Each set is a global, a primary, and a secondary coordinate system; where primary and secondary are internal to those mirrors. The two sets of coordinates are the optical coordinates and the coordinates used by vertex. We denote these six coordinate systems as follows:</p> <pre><code>- opt_global\n- opt_primary\n- opt_secondary\n- va_global\n- va_primary\n- va_secondary\n</code></pre>"},{"location":"reference/transforms/#lat_alignment.transforms.align_photo","title":"<code>align_photo(labels, coords, *, mirror='primary', reference=None, max_dist=100.0)</code>","text":"<p>Align photogrammetry data and then put it into mirror coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>NDArray[str_]</code> <p>The labels of each photogrammetry point. Should have shape <code>(npoint,)</code>.</p> required <code>coords</code> <code>NDArray[float32]</code> <p>The coordinates of each photogrammetry point. Should have shape <code>(npoint, 3)</code>.</p> required <code>mirror</code> <code>str</code> <p>The mirror that these points belong to. Should be either: 'primary' or 'secondary'.</p> <code>'primary'</code> <code>reference</code> <code>Optional[list[tuple[tuple[float, float, float], list[str]]]]</code> <p>List of reference points to use. Each point given should be a tuple with two elements. The first element is a tuple with the (x, y, z) coordinates of the point in the global coordinate system. The second is a list of nearby coded targets that can be used to identify the point. If <code>None</code> the default reference for each mirror is used.</p> <code>None</code> <code>max_dist</code> <code>float</code> <p>Max distance in mm that the reference poing can be from the target point used to locate it.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>labels</code> <code>NDArray[str_]</code> <p>The labels of each photogrammetry point. Invar points are not included.</p> <code>coords_transformed</code> <code>NDArray[float32]</code> <p>The transformed coordinates. Invar points are not included.</p> <code>msk</code> <code>NDArray[bool_]</code> <p>Mask to removes invar points</p> Source code in <code>lat_alignment/transforms.py</code> <pre><code>def align_photo(\n    labels: NDArray[np.str_],\n    coords: NDArray[np.float32],\n    *,\n    mirror: str = \"primary\",\n    reference: Optional[list[tuple[tuple[float, float, float], list[str]]]] = None,\n    max_dist: float = 100.0,\n) -&gt; tuple[NDArray[np.str_], NDArray[np.float32], NDArray[np.bool_]]:\n    \"\"\"\n    Align photogrammetry data and then put it into mirror coordinates.\n\n    Parameters\n    ----------\n    labels : NDArray[np.str_]\n        The labels of each photogrammetry point.\n        Should have shape `(npoint,)`.\n    coords : NDArray[np.float32]\n        The coordinates of each photogrammetry point.\n        Should have shape `(npoint, 3)`.\n    mirror : str, default: 'primary'\n        The mirror that these points belong to.\n        Should be either: 'primary' or 'secondary'.\n    reference : Optional[list[tuple[tuple[float, float, float], list[str]]]], default: None\n        List of reference points to use.\n        Each point given should be a tuple with two elements.\n        The first element is a tuple with the (x, y, z) coordinates\n        of the point in the global coordinate system.\n        The second is a list of nearby coded targets that can be used\n        to identify the point.\n        If `None` the default reference for each mirror is used.\n    max_dist : float, default: 100\n        Max distance in mm that the reference poing can be from the target\n        point used to locate it.\n\n    Returns\n    -------\n    labels : NDArray[np.str_]\n        The labels of each photogrammetry point.\n        Invar points are not included.\n    coords_transformed : NDArray[np.float32]\n        The transformed coordinates.\n        Invar points are not included.\n    msk : NDArray[np.bool_]\n        Mask to removes invar points\n    \"\"\"\n    if mirror not in [\"primary\", \"secondary\"]:\n        raise ValueError(f\"Invalid mirror: {mirror}\")\n    if mirror == \"primary\":\n        transform = partial(coord_transform, cfrom=\"va_global\", cto=\"opt_primary\")\n    else:\n        transform = partial(coord_transform, cfrom=\"va_global\", cto=\"opt_secondary\")\n    if reference is None:\n        reference = DEFAULT_REF[mirror]\n    if reference is None or len(reference) == 0:\n        raise ValueError(\"Invalid or empty reference\")\n\n    # Lets find the points we can use\n    trg_idx = np.where(np.char.find(labels, \"TARGET\") &gt;= 0)[0]\n    ref = []\n    pts = []\n    invars = []\n    for rpoint, codes in reference:\n        have = np.isin(codes, labels)\n        if np.sum(have) == 0:\n            continue\n        coded = coords[np.where(labels == codes[np.where(have)[0][0]])[0][0]]\n        print(codes[np.where(have)[0][0]])\n        # Find the closest point\n        dist = np.linalg.norm(coords[trg_idx] - coded, axis=-1)\n        if np.min(dist) &gt; max_dist:\n            continue\n        print(np.min(dist))\n        ref += [rpoint]\n        pts += [coords[trg_idx][np.argmin(dist)]]\n        invars += [labels[trg_idx][np.argmin(dist)]]\n    if len(ref) &lt; 4:\n        raise ValueError(f\"Only {len(ref)} reference points found! Can't align!\")\n    msk = [0, 1, 3]\n    pts = np.vstack(pts)[msk]\n    ref = np.vstack(ref)[msk]\n    pts = np.vstack((pts, np.mean(pts, 0)))\n    ref = np.vstack((ref, np.mean(ref, 0)))\n    ref = transform(ref)\n    print(\"Reference points in mirror coords:\")\n    print(ref[:-1])\n    print(make_edm(ref) / make_edm(pts))\n    print(make_edm(ref) - make_edm(pts))\n    print(np.nanmedian(make_edm(ref) / make_edm(pts)))\n    pts *= np.nanmedian(make_edm(ref) / make_edm(pts))\n    print(make_edm(ref) / make_edm(pts))\n    print(make_edm(ref) - make_edm(pts))\n    print(np.nanmedian(make_edm(ref) / make_edm(pts)))\n\n    rot, sft = get_rigid(pts, ref, method=\"mean\")\n    pts_t = apply_transform(pts, rot, sft)\n    import matplotlib.pyplot as plt\n\n    plt.scatter(pts_t[:, 0], pts_t[:, 1], color=\"b\")\n    plt.scatter(ref[:, 0], ref[:, 1], color=\"r\")\n    plt.show()\n    print(pts_t[:-1])\n    print(pts_t - ref)\n    print(\n        f\"RMS of reference points after alignment: {np.sqrt(np.mean((pts_t - ref)**2))}\"\n    )\n    coords_transformed = apply_transform(coords, rot, sft)\n\n    msk = ~np.isin(labels, invars)\n\n    return labels[msk], coords_transformed[msk], msk\n</code></pre>"},{"location":"reference/transforms/#lat_alignment.transforms.coord_transform","title":"<code>coord_transform(coords, cfrom, cto)</code>","text":"<p>Transform between the six defined mirror coordinates:</p> <pre><code>- opt_global\n- opt_primary\n- opt_secondary\n- va_global\n- va_primary\n- va_secondary\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>NDArray[float32]</code> <p>Coordinates to transform. Should be a <code>(npoint, 3)</code> array.</p> required <code>cfrom</code> <code>str</code> <p>The coordinate system that <code>coords</code> is currently in.</p> required <code>cto</code> <code>str</code> <p>The coordinate system to put <code>coords</code> into.</p> required <p>Returns:</p> Name Type Description <code>coords_transformed</code> <code>NDArray[float32]</code> <p><code>coords</code> transformed into <code>cto</code>.</p> Source code in <code>lat_alignment/transforms.py</code> <pre><code>def coord_transform(\n    coords: NDArray[np.float32], cfrom: str, cto: str\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Transform between the six defined mirror coordinates:\n\n        - opt_global\n        - opt_primary\n        - opt_secondary\n        - va_global\n        - va_primary\n        - va_secondary\n\n    Parameters\n    ----------\n    coords : NDArray[np.float32]\n        Coordinates to transform.\n        Should be a `(npoint, 3)` array.\n    cfrom : str\n        The coordinate system that `coords` is currently in.\n    cto : str\n        The coordinate system to put `coords` into.\n\n    Returns\n    -------\n    coords_transformed : NDArray[np.float32]\n        `coords` transformed into `cto`.\n    \"\"\"\n    if cfrom == cto:\n        return coords\n    match f\"{cfrom}-{cto}\":\n        case \"opt_global-opt_primary\":\n            return _opt_global_to_opt_primary(coords)\n        case \"opt_global-opt_secondary\":\n            return _opt_global_to_opt_secondary(coords)\n        case \"opt_primary-opt_global\":\n            return _opt_primary_to_opt_global(coords)\n        case \"opt_secondary-opt_global\":\n            return _opt_secondary_to_opt_global(coords)\n        case \"opt_primary-opt_secondary\":\n            return _opt_primary_to_opt_secondary(coords)\n        case \"opt_secondary-opt_primary\":\n            return _opt_secondary_to_opt_primary(coords)\n        case \"va_global-va_primary\":\n            return _va_global_to_va_primary(coords)\n        case \"va_global-va_secondary\":\n            return _va_global_to_va_secondary(coords)\n        case \"va_primary-va_global\":\n            return _va_primary_to_va_global(coords)\n        case \"va_secondary-va_global\":\n            return _va_secondary_to_va_global(coords)\n        case \"va_primary-va_secondary\":\n            return _va_primary_to_va_secondary(coords)\n        case \"va_secondary-va_primary\":\n            return _va_secondary_to_va_primary(coords)\n        case \"opt_global-va_global\":\n            return _opt_global_to_va_global(coords)\n        case \"opt_global-va_primary\":\n            return _opt_global_to_va_primary(coords)\n        case \"opt_global-va_secondary\":\n            return _opt_global_to_va_secondary(coords)\n        case \"opt_primary-va_global\":\n            return _opt_primary_to_va_global(coords)\n        case \"opt_primary-va_primary\":\n            return _opt_primary_to_va_primary(coords)\n        case \"opt_primary-va_secondary\":\n            return _opt_primary_to_va_secondary(coords)\n        case \"opt_secondary-va_global\":\n            return _opt_secondary_to_va_global(coords)\n        case \"opt_secondary-va_primary\":\n            return _opt_secondary_to_va_primary(coords)\n        case \"opt_secondary-va_secondary\":\n            return _opt_secondary_to_va_secondary(coords)\n        case \"va_global-opt_global\":\n            return _va_global_to_opt_global(coords)\n        case \"va_global-opt_primary\":\n            return _va_global_to_opt_primary(coords)\n        case \"va_global-opt_secondary\":\n            return _va_global_to_opt_secondary(coords)\n        case \"va_primary-opt_global\":\n            return _va_primary_to_opt_global(coords)\n        case \"va_primary-opt_primary\":\n            return _va_primary_to_opt_primary(coords)\n        case \"va_primary-opt_secondary\":\n            return _va_primary_to_opt_secondary(coords)\n        case \"va_secondary-opt_global\":\n            return _va_secondary_to_opt_global(coords)\n        case \"va_secondary-opt_primary\":\n            return _va_secondary_to_opt_primary(coords)\n        case \"va_secondary-opt_secondary\":\n            return _va_secondary_to_opt_secondary(coords)\n        case _:\n            raise ValueError(\"Invalid coordinate system provided!\")\n</code></pre>"}]}