{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LAT Alignment","text":"<p>Tools for LAT mirror alignment</p>"},{"location":"#installation","title":"Installation","text":"<p>Technically after cloning this repository you can just run <code>python lat_alignment/alignment.py PATH/TO/CONFIG</code>, but it is recommended that you install this as a package instead.</p> <p>To do this just run: <code>pip install -e .</code> from the root of this repository.</p> <p>This has two main benefits over running the script directly: 1. It will handle dependencies for you. 2. This sets up an entrypoint called <code>lat_alignment</code> so that you can call the code from anywhere. This is nice because now you can call the code from the measurement directory where you are most likely editing files, saving you the hassle of having to <code>cd</code> or wrangle long file paths.</p>"},{"location":"#usage","title":"Usage","text":"<ol> <li>Create the appropriate directory structure for your measurement (see File Structure for details).</li> <li>Place the measurement files in the appropriate place in your created directory (see Measurement Files for details).</li> <li>Create a file with any information about the measurement that could prove useful (see Description File for details).</li> <li>Create a config file for your measurement (see Config File for details).</li> <li>Run the alignment script with <code>lat_alignment /PATH/TO/CONFIG</code></li> <li>Follow the instructions in the output to align panels. This output will both be printed in the terminal and written to an output file (see Output File)</li> </ol>"},{"location":"#file-structure","title":"File Structure","text":"<p>Measurements should be organized in the following file structure</p> <pre><code>measurements\n|\n\u2514\u2500\u2500\u2500YYYYMMDD_num\n|   |config.txt\n|   |description.txt\n|   |output.txt\n|   |adjusters.yaml\n|   |\n|   \u2514\u2500\u2500\u2500M1\n|   |   |XX-XXXXXX.txt\n|   |   |XX-XXXXXX.txt\n|   |   |...\n|   |\n|   \u2514\u2500\u2500\u2500M2\n|   |   |XX-XXXXXX.txt\n|   |   |XX-XXXXXX.txt\n|   |   |...\n|   |\n|   \u2514\u2500\u2500\u2500plots\n|       \u2514\u2500\u2500\u2500M1\n|       |   |XX-XXXXXX_surface.png\n|       |   |XX-XXXXXX_hist.png\n|       |   |XX-XXXXXX_ps.png\n|       |   |...\n|       |\n|       \u2514\u2500\u2500\u2500M2\n|           |XX-XXXXXX_surface.png\n|           |XX-XXXXXX_hist.png\n|           |XX-XXXXXX_ps.png\n|           |...\n|       \n\u2514\u2500\u2500\u2500YYYYMMDD_num\n|   |config.txt\n|   |description.txt\n|   |adjusters.yaml\n|   |\n|   \u2514\u2500\u2500\u2500M1\n|   |   |XX-XXXXXX.txt\n|   |   |XX-XXXXXX.txt\n|   |   |...\n|   |\n|   \u2514\u2500\u2500\u2500M2\n|       |XX-XXXXXX.txt\n|       |XX-XXXXXX.txt\n|       |...\n|   |\n|   \u2514\u2500\u2500\u2500plots\n|       \u2514\u2500\u2500\u2500M1\n|       |   |XX-XXXXXX_surface.png\n|       |   |XX-XXXXXX_hist.png\n|       |   |XX-XXXXXX_ps.png\n|       |   |...\n|       |\n|       \u2514\u2500\u2500\u2500M2\n|           |XX-XXXXXX_surface.png\n|           |XX-XXXXXX_hist.png\n|           |XX-XXXXXX_ps.png\n|           |...\n|...\n</code></pre>"},{"location":"#measurement-directories","title":"Measurement Directories","text":"<p>Each directory <code>YYYYMMDD_num</code> refers to a specific measurement session. Where <code>YYYYMMDD</code> refers to the date of the measurement and <code>num</code> refers to which number measurement on that date it was. For example the second measurement taken on January 1st, 2022 would be <code>20220101_02</code>.</p> <p>This is the file path that should be provided to <code>alignment.py</code> as the <code>measurement_dir</code> argument.</p>"},{"location":"#config-file","title":"Config File","text":"<p>The file <code>config.yaml</code> contains configuration options. Below is an annotated example with all possible options.</p> <pre><code># The measurement directory\n# If not provided the dirctory containing the config will be used\nmeasurement_dir: PATH/TO/MEASUREMENT\n\n# The path the the dirctory containing the cannonical adjuster locations\n# If not provided the can_points directory in the root of this repository is used\ncannonical_points: PATH/TO/CAN/POINTS\n\n# Coordinate system of measurements\n# Possible vaules are [\"cad\", \"global\", \"primary\", \"secondary\"]\ncoordinates: cad # default value\n\n# Amount to shift the origin of the measurements by\n# Should be a 3 element list\norigin_shift: [0, 0, 0] # default value\n\n# FARO compensation\ncompensation: 0.0 # default value\n\n# Set to True to apply common mode subtraction\ncm_sub: False # default value\n\n# Set to True to make plots if panels \nplots: False # default value\n\n# Where to save log\n# If not provided log is saved to a file called output.txt\n# in the measurement_dir for this measurement\nlog_file: null # Set to null to only print output and not save\n\n# Path to a yaml file with the current adjuster positions\n# If null (None) then all adjusters are assumed to be at 0\n# You probably want to point this to the file generated\n# in the previous alignment run if you have it\nadj_path: null # default value\n\n# Path to where to store the adjuster postions after aligning\n# If null (None) will store in a file called adjusters.yaml\n# in the measurement_dir for this measurement\nadj_out: null # default value\n\n# Defines the allowed adjuster range in mm\nadj_low: -1 # default value\nadj_high: 1 # default value\n</code></pre> <p>If you are using all default values make a blank config with <code>touch config.yaml</code></p>"},{"location":"#description-file","title":"Description File","text":"<p>Each measurement directory should contain a file <code>description.txt</code> with information on the measurement. Any information that could provide useful context when looking at the measurement/alignment after the fact should be included here (ie: who performed the measurement, where the measurement was taken, etc.).</p>"},{"location":"#output-file","title":"Output File","text":"<p>Output generated by <code>alignment.py</code>. By default this is saved at <code>measurement_dir/output.txt</code></p> <p>Note that this file gets overwritten when <code>lat_alignment</code> is run, so if you want to store multiple copies with different configs or something rename them or change the <code>log_file</code> in the config.</p>"},{"location":"#adjuster-positions","title":"Adjuster Positions","text":"<p>Positions of adjusters after applying the calculated adjustments. This is a yaml file nominally saved at <code>measurement_dir/adjusters/yaml</code></p> <p>Each element in the file is in the format:</p> <pre><code>PANEL_NUMBER: [X, Y, ADJ_1, ADJ_2, ADJ_3, ADJ_4, ADJ_5] \n</code></pre>"},{"location":"#mirror-directories","title":"Mirror Directories","text":"<p>Directories containing the measurements files within each root measurement directory. <code>M1</code> contains the measurements for the primary mirror and <code>M2</code> contains the measurements for the secondary mirror. If you don't have measurements for one of the mirrors you do not need to create an empty directory for it.</p>"},{"location":"#measurement-files","title":"Measurement Files","text":"<p>Files containing the point cloud measurements for a given panel. Should live in the mirror directory that the panel belongs to. Files should be named <code>XX-XXXXXX.txt</code> where <code>XX-XXXXXX</code> is the panel number. The numbering system is as follows: * First four digits (<code>XX-XX</code>) are the telescope number. For the LAT this is <code>01-01</code> * Fifth digit is the mirror number. This is <code>1</code> for the primary and <code>2</code> for the secondary. * Sixth digit is the panel row * Seventh digit is the panel column * Eight digit is the panel number (current, spare, replacement, etc.)</p>"},{"location":"#plot-directory","title":"Plot Directory","text":"<p>If the <code>plots</code> option is set to <code>True</code> then the root measurement will contain a directory called <code>plots</code>. Within this directory will be directories for each mirror measured, <code>M1</code> for the primary and <code>M2</code> for the secondary. Each of these will contain three plots per panel measured: * <code>XX-XXXXXX_surface.png</code>, a plot of the panel's surface in the mirror's coordinate system. * <code>XX-XXXXXX_hist.png</code>, a histogram of the residuals from the panel's fit. * <code>XX-XXXXXX_ps.png</code>, a plot of the power spectrum of the residuals from the panel's fit.</p> <p>Where <code>XX-XXXXXX</code> is the panel number.</p>"},{"location":"#coordinate-systems","title":"Coordinate Systems","text":"<p>The relevant coordinate systems are marked in the diagram below:</p> <p></p> <p>Where the orange circle marks the <code>global</code> coordinate system, the green circle marks the <code>primary</code> coordinate system, and the blue circle marks the <code>secondary</code> coordinate system.</p> <p>Additionally there is a <code>cad</code> coordinate system that is defined as the coordinate system from the SolidWorks model. It is given by the following transformation from the <code>global</code> coordinate system:</p> <pre><code>x -&gt; y - 200 mm\ny -&gt; x\nz -&gt; -z\n</code></pre> <p>It is currently unclear why the 200 mm offset exists.</p> <p>Note that the files in the <code>can_points</code> directory are in the <code>cad</code> coordinate system.</p> <p>All measurements should be done in one of these four coordinate systems modulo a known shift in the origin.</p>"},{"location":"#bugs-and-feature-requests","title":"Bugs and Feature Requests","text":"<p>For low priority bugs and feature requests submit an issue on the git repo.</p> <p>For higher priority issues (or questions that require an expedient answer) email, Slack, or call me.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you wish to contribute to this repository (either code or adding measurement files) contact me via email or Slack.</p> <p>If you are contributing code please do so by creating a branch and submitting a pull request. Try to keep things as close to PEP8 as possible.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>adjustments</li> <li>alignment</li> <li>fitting</li> <li>io</li> <li>mirror</li> <li>transforms</li> </ul>"},{"location":"reference/adjustments/","title":"adjustments","text":"<p>Calculate adjustments needed to align LAT mirror panel</p> <p>Author: Saianeesh Keshav Haridas</p>"},{"location":"reference/adjustments/#lat_alignment.adjustments.adjustment_fit_func","title":"<code>adjustment_fit_func(pars, can_points, points, adjustors)</code>","text":"<p>Function to minimize when calculating adjustments</p> <p>@param pars: The parameters to fit for:                 dx: Translation in x                 dy: Translation in y                 dz: Translation in z                 thetha_0: Angle to rotate about first adjustor axis                 thetha_1: Angle to rotate about second adjustor axis                 z_t: Additional translation to tension the center point @param can_points: The cannonical positions of the points to align @param points: The measured positions of the points to align @param adjustors: The measured positions of the adjustors</p> <p>@return norm: The norm of (cannonical positions - transformed positions)</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def adjustment_fit_func(\n    pars: ndarray, can_points: ndarray, points: ndarray, adjustors: ndarray\n) -&gt; float64:\n    \"\"\"\n    Function to minimize when calculating adjustments\n\n    @param pars: The parameters to fit for:\n                    dx: Translation in x\n                    dy: Translation in y\n                    dz: Translation in z\n                    thetha_0: Angle to rotate about first adjustor axis\n                    thetha_1: Angle to rotate about second adjustor axis\n                    z_t: Additional translation to tension the center point\n    @param can_points: The cannonical positions of the points to align\n    @param points: The measured positions of the points to align\n    @param adjustors: The measured positions of the adjustors\n\n    @return norm: The norm of (cannonical positions - transformed positions)\n    \"\"\"\n    dx, dy, dz, thetha_0, thetha_1, z_t = pars\n    points, adjustors = translate_panel(points, adjustors, dx, dy, dz)\n    points, adjustors = rotate_panel(points, adjustors, thetha_0, thetha_1)\n    points[-1, -1] += z_t\n    return np.linalg.norm(can_points - points)\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.calc_adjustments","title":"<code>calc_adjustments(can_points, points, adjustors, **kwargs)</code>","text":"<p>Calculate adjustments needed to align panel</p> <p>@param can_points: The cannonical position of the points to align @param points: The measured positions of the points to align @param adjustors: The measured positions of the adjustors @param **kwargs: Arguments to be passed to scipy.optimize.minimize</p> <p>@return dx: The required translation of panel in x @return dy: The required translation of panel in y @return d_adj: The amount to move each adjustor @return dx_err: The error in the fit for dx @return dy_err: The error in the fit for dy @return d_adj_err: The error in the fit for d_adj</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def calc_adjustments(\n    can_points: ndarray, points: ndarray, adjustors: ndarray, **kwargs\n) -&gt; Tuple[float64, float64, ndarray, float64, float64, ndarray]:\n    \"\"\"\n    Calculate adjustments needed to align panel\n\n    @param can_points: The cannonical position of the points to align\n    @param points: The measured positions of the points to align\n    @param adjustors: The measured positions of the adjustors\n    @param **kwargs: Arguments to be passed to scipy.optimize.minimize\n\n    @return dx: The required translation of panel in x\n    @return dy: The required translation of panel in y\n    @return d_adj: The amount to move each adjustor\n    @return dx_err: The error in the fit for dx\n    @return dy_err: The error in the fit for dy\n    @return d_adj_err: The error in the fit for d_adj\n    \"\"\"\n    res = opt.minimize(\n        adjustment_fit_func, np.zeros(6), (can_points, points, adjustors), **kwargs\n    )\n\n    dx, dy, dz, thetha_0, thetha_1, z_t = res.x\n    _points, _adjustors = translate_panel(points, adjustors, dx, dy, dz)\n    _points, _adjustors = rotate_panel(_points, _adjustors, thetha_0, thetha_1)\n    _adjustors[-1, -1] += z_t\n    d_adj = _adjustors - adjustors\n\n    ftol = 2.220446049250313e-09\n    if \"ftol\" in kwargs:\n        ftol = kwargs[\"ftol\"]\n    perr = np.sqrt(ftol * np.diag(res.hess_inv))\n    dx_err, dy_err, dz_err, thetha_0_err, thetha_1_err, z_t_err = perr\n    _points, _adjustors = translate_panel(points, adjustors, dx_err, dy_err, dz_err)\n    _points, _adjustors = rotate_panel(_points, _adjustors, thetha_0_err, thetha_1_err)\n    _adjustors[-1, -1] += z_t_err\n    d_adj_err = _adjustors - adjustors\n\n    return dx, dy, d_adj[:, 2], dx_err, dy_err, d_adj_err[:, 2]\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.rotate","title":"<code>rotate(point, end_point1, end_point2, thetha)</code>","text":"<p>Rotate a point about an axis</p> <p>@param point: The point to rotate @param end_point1: A point on the axis of rotation @param end_point2: Another point on the axis of rotation @param thetha: Angle in radians to rotate by</p> <p>@return point: The rotated point</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def rotate(\n    point: ndarray, end_point1: ndarray, end_point2: ndarray, thetha: float64\n) -&gt; ndarray:\n    \"\"\"\n    Rotate a point about an axis\n\n    @param point: The point to rotate\n    @param end_point1: A point on the axis of rotation\n    @param end_point2: Another point on the axis of rotation\n    @param thetha: Angle in radians to rotate by\n\n    @return point: The rotated point\n    \"\"\"\n    origin = np.mean((end_point1, end_point2))\n    point_0 = point - origin\n    ax = end_point2 - end_point1\n    ax = rot.from_rotvec(thetha * ax / np.linalg.norm(ax))\n    point_0 = ax.apply(point_0)\n    return point_0 + origin\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.rotate_panel","title":"<code>rotate_panel(points, adjustors, thetha_0, thetha_1)</code>","text":"<p>Rotate panel about axes created by adjustors</p> <p>@param points: Points on panel to rotate @param adjustors: Adjustor positions @param thetha_0: Angle to rotate about first adjustor axis @param thetha_1: Angle to rotate about second adjustor axis</p> <p>@return rot_points: The rotated points @return rot_adjustors: The rotated adjustors</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def rotate_panel(\n    points: ndarray, adjustors: ndarray, thetha_0: float64, thetha_1: float64\n) -&gt; Tuple[ndarray, ndarray]:\n    \"\"\"\n    Rotate panel about axes created by adjustors\n\n    @param points: Points on panel to rotate\n    @param adjustors: Adjustor positions\n    @param thetha_0: Angle to rotate about first adjustor axis\n    @param thetha_1: Angle to rotate about second adjustor axis\n\n    @return rot_points: The rotated points\n    @return rot_adjustors: The rotated adjustors\n    \"\"\"\n    rot_points = np.zeros(points.shape)\n    rot_adjustors = np.zeros(adjustors.shape)\n\n    n_points = len(points)\n    n_adjustors = len(adjustors)\n\n    for i in range(n_points):\n        rot_points[i] = rotate(points[i], adjustors[1], adjustors[2], thetha_0)\n        rot_points[i] = rotate(rot_points[i], adjustors[0], adjustors[3], thetha_1)\n    for i in range(n_adjustors):\n        rot_adjustors[i] = rotate(adjustors[i], adjustors[1], adjustors[2], thetha_0)\n        rot_adjustors[i] = rotate(\n            rot_adjustors[i], adjustors[0], adjustors[3], thetha_1\n        )\n    return rot_points, rot_adjustors\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.translate_panel","title":"<code>translate_panel(points, adjustors, dx, dy, dz)</code>","text":"<p>Translate panel</p> <p>@param points: The points on panel to translate @param adjustors: Adjustor positions @param dx: Translation in x @param dy: Translation in y @param dz: Translation in z</p> <p>@return points: The translated points @return adjustors: The translated adjustors</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def translate_panel(\n    points: ndarray, adjustors: ndarray, dx: float64, dy: float64, dz: float64\n) -&gt; Tuple[ndarray, ndarray]:\n    \"\"\"\n    Translate panel\n\n    @param points: The points on panel to translate\n    @param adjustors: Adjustor positions\n    @param dx: Translation in x\n    @param dy: Translation in y\n    @param dz: Translation in z\n\n    @return points: The translated points\n    @return adjustors: The translated adjustors\n    \"\"\"\n    translation = np.array((dx, dy, dz))\n    return points + translation, adjustors + translation\n</code></pre>"},{"location":"reference/alignment/","title":"alignment","text":""},{"location":"reference/fitting/","title":"fitting","text":"<p>Functions for fitting against the mirror surface.</p>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_fit","title":"<code>mirror_fit(points, a, compensate=0, to_points=True, **kwargs)</code>","text":"<p>Fit points against the mirror surface. Ideally the points should be in the mirror's local coordinate system.</p> Paramaters <p>points : NDArray[np.floating]     Array of points to compare against the mirror.     Should have shape (npoint, 3). a : NDArray[np.floating]     Coeffecients of the mirror function.     Use a_primary for the primary mirror and a_secondary for the secondary. compensate : float, default: 0.0     Amount to compensate the mirror surface by.     This is useful to model things like the surface traced out by an SMR. to_points : bool, default: True     If True, the transform will be inverted to align the model to the points. **kwargs     Additional arguments to pass on to scipy.optimize.minimize.</p> <p>Returns:</p> Name Type Description <code>transform_pars</code> <code>NDArray[floating]</code> <p>Flattened affine transform and shift, has to be 1d for use with minimizers. Will have shape (12,) where the first 9 elements are the flattened affine transform, and the last 3 are the shift in (x, y, z) applied after the affine transform.</p> <code>rms</code> <code>float</code> <p>The RMS error between the transformed points and the model.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_fit(\n    points: NDArray[np.floating],\n    a: NDArray[np.floating],\n    compensate: float = 0,\n    to_points: bool = True,\n    **kwargs\n) -&gt; tuple[NDArray[np.floating], float]:\n    \"\"\"\n    Fit points against the mirror surface.\n    Ideally the points should be in the mirror's local coordinate system.\n\n    Paramaters\n    ----------\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n    a : NDArray[np.floating]\n        Coeffecients of the mirror function.\n        Use a_primary for the primary mirror and a_secondary for the secondary.\n    compensate : float, default: 0.0\n        Amount to compensate the mirror surface by.\n        This is useful to model things like the surface traced out by an SMR.\n    to_points : bool, default: True\n        If True, the transform will be inverted to align the model to the points.\n    **kwargs\n        Additional arguments to pass on to scipy.optimize.minimize.\n\n    Returns\n    -------\n    transform_pars : NDArray[np.floating]\n        Flattened affine transform and shift, has to be 1d for use with minimizers.\n        Will have shape (12,) where the first 9 elements are the flattened affine transform,\n        and the last 3 are the shift in (x, y, z) applied after the affine transform.\n    rms : float\n        The RMS error between the transformed points and the model.\n    \"\"\"\n\n    def _fit_func(transform_pars, points, a, compensate):\n        points_transformed = mirror_transform(transform_pars, points)\n        chisq = mirror_objective(points_transformed, a, compensate)\n        return chisq\n\n    x0 = np.concatenate((np.eye(3).ravel(), np.zeros(3)))\n    res = opt.minimize(_fit_func, x0, args=(points, a, compensate), **kwargs)\n\n    transform_pars = res.x\n    transformed = mirror_transform(transform_pars, points)\n    z = mr.mirror(transformed[:, 0], transformed[:, 1], a, compensate)\n    rms = np.sqrt(np.mean((z - transformed[:, 2]) ** 2))\n\n    if to_points:\n        aff = transform_pars[:9].reshape((3, 3))\n        sft = transform_pars[9:]\n        aff = np.linalg.inv(aff)\n        sft = (-1 * sft) @ aff\n        transform_pars = np.concatenate((aff.ravel(), sft))\n\n    return transform_pars, rms\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_objective","title":"<code>mirror_objective(points, a, compensate=0)</code>","text":"<p>Objective function to minimize when fitting to mirror surface. Essentially just a curvature weighted chisq.</p> Paramaters <p>points : NDArray[np.floating]     Array of points to compare against the mirror.     Should have shape (npoint, 3). a : NDArray[np.floating]     Coeffecients of the mirror function.     Use a_primary for the primary mirror and a_secondary for the secondary. compensate : float, default: 0.0     Amount to compensate the mirror surface by.     This is useful to model things like the surface traced out by an SMR.</p> <p>Returns:</p> Name Type Description <code>chisq</code> <code>float</code> <p>The value to minimize when fitting to.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_objective(\n    points: NDArray[np.floating], a: NDArray[np.floating], compensate: float = 0\n) -&gt; float:\n    \"\"\"\n    Objective function to minimize when fitting to mirror surface.\n    Essentially just a curvature weighted chisq.\n\n    Paramaters\n    ----------\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n    a : NDArray[np.floating]\n        Coeffecients of the mirror function.\n        Use a_primary for the primary mirror and a_secondary for the secondary.\n    compensate : float, default: 0.0\n        Amount to compensate the mirror surface by.\n        This is useful to model things like the surface traced out by an SMR.\n\n    Returns\n    -------\n    chisq : float\n        The value to minimize when fitting to.\n    \"\"\"\n    surface = mr.mirror(points[:, 0], points[:, 1], a, compensate)\n    norm = mr.mirror_norm(points[:, 0], points[:, 1], a)\n    res = (points[:, 2] - surface) * (norm[2] ** 2)\n\n    return res @ res.T\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_transform","title":"<code>mirror_transform(transform_pars, points)</code>","text":"<p>Function to apply an affine transform to the mirror. This is the transform we are fitting for.</p> Paramaters <p>transform_pars : NDArray[np.floating]     Flattened affine transform and shift, has to be 1d for use with minimizers.     Should have shape (12,) where the first 9 elements are the flattened affine transform,     and the last 3 are the shift in (x, y, z) applied after the affine transform. points : NDArray[np.floating]     Array of points to compare against the mirror.     Should have shape (npoint, 3).</p> <p>Returns:</p> Name Type Description <code>points_transformed</code> <code>NDArray[floating]</code> <p>Array of transformed points. Will have shape (npoint, 3).</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_transform(\n    transform_pars: NDArray[np.floating], points: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Function to apply an affine transform to the mirror.\n    This is the transform we are fitting for.\n\n    Paramaters\n    ----------\n    transform_pars : NDArray[np.floating]\n        Flattened affine transform and shift, has to be 1d for use with minimizers.\n        Should have shape (12,) where the first 9 elements are the flattened affine transform,\n        and the last 3 are the shift in (x, y, z) applied after the affine transform.\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n\n    Returns\n    -------\n    points_transformed : NDArray[np.floating]\n        Array of transformed points.\n        Will have shape (npoint, 3).\n    \"\"\"\n    aff = transform_pars[:9].reshape((3, 3))\n    sft = transform_pars[9:]\n    return points @ aff + sft\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.res_auto_corr","title":"<code>res_auto_corr(residuals)</code>","text":"<p>Compute auto correlation of residuals from fit.</p> Paramaters <p>residuals : NDArray[np.floating]     Residuals between measured point cloud and fit model.</p> <p>Returns:</p> Name Type Description <code>ac</code> <code>NDArray[floating]</code> <p>Auto correlation, really just the deviations in mm at each distance scale.</p> <code>ac_dists</code> <code>NDArray[floating]</code> <p>Distance scale of each value in ac.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def res_auto_corr(\n    residuals: NDArray[np.floating],\n) -&gt; tuple[NDArray[np.floating], NDArray[np.floating]]:\n    \"\"\"\n    Compute auto correlation of residuals from fit.\n\n    Paramaters\n    ----------\n    residuals : NDArray[np.floating]\n        Residuals between measured point cloud and fit model.\n\n    Returns\n    -------\n    ac : NDArray[np.floating]\n        Auto correlation, really just the deviations in mm at each distance scale.\n    ac_dists : NDArray[np.floating]\n        Distance scale of each value in ac.\n    \"\"\"\n    dists = np.zeros((len(residuals), len(residuals)))\n    res_diff = np.zeros((len(residuals), len(residuals)))\n\n    for i in range(len(residuals)):\n        res1 = residuals[i]\n        for j in range(i):\n            res2 = residuals[j]\n            dist = np.linalg.norm((res1[0] - res2[0], res1[1] - res2[1]))\n            dists[i, j] = dist\n            res_diff[i, j] = abs(res1[2] - res2[2])\n    tri_i = np.tril_indices(len(residuals), k=-1)\n    dists = dists[tri_i]\n    res_diff = res_diff[tri_i]\n    ac, bin_e, _ = binned_statistic(dists, res_diff, bins=100)\n    ac_dists = bin_e[:-1] + np.diff(bin_e) / 2.0\n\n    return ac, ac_dists\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.tension_fit","title":"<code>tension_fit(residuals, **kwargs)</code>","text":"<p>Fit a power law model of tension to a point cloud of residuals.</p> Paramaters <p>residuals : NDArray[np.floating]     Residuals between measured point cloud and fit model. **kwargs     Arguments to be passed to scipy.optimize.minimize</p> <p>Returns:</p> Name Type Description <code>tension_pars</code> <code>NDArray[floating]</code> <p>The fit parameters, see docstring of tension_model for details.</p> <code>rms</code> <code>float</code> <p>The rms between the input residuals and the fit model.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def tension_fit(\n    residuals: NDArray[np.floating], **kwargs\n) -&gt; tuple[NDArray[np.floating], float]:\n    \"\"\"\n    Fit a power law model of tension to a point cloud of residuals.\n\n    Paramaters\n    ----------\n    residuals : NDArray[np.floating]\n        Residuals between measured point cloud and fit model.\n    **kwargs\n        Arguments to be passed to scipy.optimize.minimize\n\n    Returns\n    -------\n    tension_pars : NDArray[np.floating]\n        The fit parameters, see docstring of tension_model for details.\n    rms : float\n        The rms between the input residuals and the fit model.\n    \"\"\"\n\n    def min_func(pars, residuals):\n        _z = tension_model(*pars[:5], residuals)\n        return np.sqrt(np.mean((residuals[:, 2] - _z) ** 2))\n\n    if \"bounds\" not in kwargs:\n        ptp = np.ptp(residuals[:, 2])\n        bounds = [\n            (np.min(residuals[:, 0]), np.max(residuals[:, 0])),\n            (np.min(residuals[:, 1]), np.max(residuals[:, 1])),\n            (-1 * ptp, ptp),\n            (1e-10, np.inf),\n            (0, np.inf),\n        ]\n        kwargs[\"bounds\"] = bounds\n    x0 = [np.mean(residuals[:, 0]), np.mean(residuals[:, 1]), 0, 1, 0]\n    res = opt.minimize(min_func, x0, (residuals,), **kwargs)\n    return res.x, res.fun\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.tension_model","title":"<code>tension_model(x0, y0, t, a, b, points)</code>","text":"<p>Function to model incorrect panel tensioning. Currently the model used is a radial power law.</p> Paramaters <p>x0 : float     Center of the power law in x. y0 : float     Center of the power law in y. t : float.     Amplitude of power law,     nominally the offset due to tensioning in the center of panel. a : float     Base of power law. b : float     Exponential scale factor of power law points : NDArray[np.floating]     Points to compute power law at.     Only the x and y coordinates are used (first two collumns).     So should be (npoint, 2) but (npoint, ndim&gt;2) is also fine.</p> <p>Returns:</p> Name Type Description <code>z</code> <code>NDArray[floating]</code> <p>Power law model at each xy. Will have shape (npoint,).</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def tension_model(\n    x0: float, y0: float, t: float, a: float, b: float, points: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Function to model incorrect panel tensioning.\n    Currently the model used is a radial power law.\n\n\n    Paramaters\n    ----------\n    x0 : float\n        Center of the power law in x.\n    y0 : float\n        Center of the power law in y.\n    t : float.\n        Amplitude of power law,\n        nominally the offset due to tensioning in the center of panel.\n    a : float\n        Base of power law.\n    b : float\n        Exponential scale factor of power law\n    points : NDArray[np.floating]\n        Points to compute power law at.\n        Only the x and y coordinates are used (first two collumns).\n        So should be (npoint, 2) but (npoint, ndim&gt;2) is also fine.\n\n    Returns\n    -------\n    z : NDArray[np.floating]\n        Power law model at each xy.\n        Will have shape (npoint,).\n    \"\"\"\n    # Avoid divide by 0 error\n    if a == 0:\n        return np.zeros(len(points))\n\n    # Compute radius at each point\n    r = np.sqrt((points[:, 0] - x0) ** 2 + (points[:, 1] - y0) ** 2)\n\n    # Return power law\n    return t * (a ** (-b * r))\n</code></pre>"},{"location":"reference/io/","title":"io","text":""},{"location":"reference/io/#lat_alignment.io.load_adjusters","title":"<code>load_adjusters(path, mirror)</code>","text":"<p>Get nominal adjuster locations from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the data file.</p> required <code>mirror</code> <code>str</code> <p>The mirror that these points belong to. Should be either: 'primary' or 'secondary'.</p> <code>'primary'</code> <p>Returns:</p> Name Type Description <code>adjusters</code> <code>dict[tuple[int, int], NDArray[float32]]</code> <p>Nominal adjuster locations. This is indexed by a (row, col) tuple. Each entry is <code>(5, 3)</code> array where each row is an adjuster.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_adjusters(\n    path: str, mirror: str\n) -&gt; dict[tuple[int, int], NDArray[np.float32]]:\n    \"\"\"\n    Get nominal adjuster locations from file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the data file.\n    mirror : str, default: 'primary'\n        The mirror that these points belong to.\n        Should be either: 'primary' or 'secondary'.\n\n    Returns\n    -------\n    adjusters : dict[tuple[int, int], NDArray[np.float32]]\n        Nominal adjuster locations.\n        This is indexed by a (row, col) tuple.\n        Each entry is `(5, 3)` array where each row is an adjuster.\n    \"\"\"\n    if mirror not in [\"primary\", \"secondary\"]:\n        raise ValueError(f\"Invalid mirror: {mirror}\")\n\n    def _transform(coords):\n        coords = np.atleast_2d(coords)\n        coords -= np.array([120, 0, 0])  # cancel out shift\n        return coord_transform(coords, \"va_global\", f\"opt_{mirror}\")\n\n    # TODO: cleaner transform call\n    adjusters = defaultdict(list)\n    c_points = np.genfromtxt(path, dtype=str)\n    for point in c_points:\n        row = point[0][6]\n        col = point[0][7]\n        adjusters[(row, col)] += [_transform(np.array(point[2:], dtype=np.float32))[0]]\n    adjusters = {rc: np.vstack(pts) for rc, pts in adjusters.items()}\n\n    return adjusters\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_corners","title":"<code>load_corners(path)</code>","text":"<p>Get panel corners from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the data file.</p> required <p>Returns:</p> Name Type Description <code>corners</code> <code>dict[tuple[int, int], ndarray[float32]]</code> <p>The corners. This is indexed by a (row, col) tuple. Each entry is <code>(4, 3)</code> array where each row is a corner.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_corners(path: str) -&gt; dict[tuple[int, int], NDArray[np.float32]]:\n    \"\"\"\n    Get panel corners from file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the data file.\n\n    Returns\n    -------\n    corners : dict[tuple[int, int], ndarray[np.float32]]\n        The corners. This is indexed by a (row, col) tuple.\n        Each entry is `(4, 3)` array where each row is a corner.\n    \"\"\"\n    with open(path) as file:\n        corners_raw = yaml.safe_load(file)\n\n    corners = {\n        (panel[7], panel[9]): np.vstack(\n            [np.array(coord.split(), np.float32) for coord in coords]\n        )\n        for panel, coords in corners_raw.items()\n    }\n    return corners\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_photo","title":"<code>load_photo(path, align=True, err_thresh=2, plot=True, **kwargs)</code>","text":"<p>Load photogrammetry data. Assuming first column is target names and next three are (x, y , z).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the photogrammetry data.</p> required <code>align</code> <code>bool</code> <p>If True align using the invar points.</p> <code>True</code> <code>err_thresh</code> <code>float</code> <p>How many times the median photogrammetry error a target need to have to be cut.</p> <code>2</code> <code>plot</code> <code>bool</code> <p>If True display a scatter plot of targets.</p> <code>True</code> <code>**kwargs</code> <p>Arguments to pass to <code>align_photo</code>.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>data</code> <code>dict[str, NDArray[float32]]</code> <p>The photogrammetry data. Dict is indexed by the target names.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_photo(\n    path: str, align: bool = True, err_thresh: float = 2, plot: bool = True, **kwargs\n) -&gt; dict[str, NDArray[np.float32]]:\n    \"\"\"\n    Load photogrammetry data.\n    Assuming first column is target names and next three are (x, y , z).\n\n    Parameters\n    ----------\n    path : str\n        The path to the photogrammetry data.\n    align : bool, default: True\n        If True align using the invar points.\n    err_thresh : float, default: 2\n        How many times the median photogrammetry error\n        a target need to have to be cut.\n    plot: bool, default: True\n        If True display a scatter plot of targets.\n    **kwargs\n        Arguments to pass to `align_photo`.\n\n    Returns\n    -------\n    data : dict[str, NDArray[np.float32]]\n        The photogrammetry data.\n        Dict is indexed by the target names.\n    \"\"\"\n    labels = np.genfromtxt(path, dtype=str, delimiter=\",\", usecols=(0,))\n    coords = np.genfromtxt(path, dtype=np.float32, delimiter=\",\", usecols=(1, 2, 3))\n    errs = np.genfromtxt(path, dtype=np.float32, delimiter=\",\", usecols=(4, 5, 6))\n    msk = (np.char.find(labels, \"TARGET\") &gt;= 0) + (np.char.find(labels, \"CODE\") &gt;= 0)\n\n    labels, coords, errs = labels[msk], coords[msk], errs[msk]\n    err = np.linalg.norm(errs, axis=-1)\n\n    if align:\n        labels, coords, msk = align_photo(labels, coords, **kwargs)\n        err = err[msk]\n    trg_msk = np.char.find(labels, \"TARGET\") &gt;= 0\n    labels = labels[trg_msk]\n    coords = coords[trg_msk]\n    err = err[trg_msk]\n\n    err_msk = err &lt; err_thresh * np.median(err)\n    labels, coords, err = labels[err_msk], coords[err_msk], err[err_msk]\n\n    # Lets find and remove doubles\n    # Dumb brute force\n    edm = make_edm(coords[:, :2])\n    np.fill_diagonal(edm, np.nan)\n    to_kill = []\n    for i in range(len(edm)):\n        if i in to_kill:\n            continue\n        imin = np.nanargmin(edm[i])\n        if edm[i][imin] &gt; 20:\n            continue\n        if err[i] &lt; err[imin]:\n            to_kill += [imin]\n        else:\n            to_kill += [i]\n    msk = ~np.isin(np.arange(len(coords), dtype=int), to_kill)\n    labels, coords = labels[msk], coords[msk]\n\n    if plot:\n        plt.scatter(coords[:, 0], coords[:, 1], c=coords[:, 2], marker=\"x\")\n        plt.colorbar()\n        plt.show()\n\n    data = {label: coord for label, coord in zip(labels, coords)}\n    return data\n</code></pre>"},{"location":"reference/mirror/","title":"mirror","text":"<p>Functions to describe the mirror surface.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel","title":"<code>Panel</code>  <code>dataclass</code>","text":"<p>Dataclass for storing a mirror panel.</p> <p>Attributes:</p> Name Type Description <code>mirror</code> <code>str</code> <p>Which mirror this panel is for. Should be 'primary' or 'secondary'.</p> <code>row</code> <code>int</code> <p>The row of the panel.</p> <code>col</code> <code>int</code> <p>The column of the panel.</p> <code>corners</code> <code>NDArray[float32]</code> <p>Array of panel corners. Should have shape <code>(4, 3)</code>.</p> <code>measurements</code> <code>NDArray[float32]</code> <p>The measurement data for this panel. Should be in the mirror's internal coords. Should have shape <code>(npoint, 3)</code>.</p> <code>nom_adj</code> <code>NDArray[float32]</code> <p>The nominal position of the adjusters in the mirror internal coordinates. Should have shape <code>(5, 3)</code>.</p> <code>compensate</code> <code>float, default: 0</code> <p>The amount (in mm) to compensate the model surface by. This is to account for things like the Faro SMR.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>@dataclass\nclass Panel:\n    \"\"\"\n    Dataclass for storing a mirror panel.\n\n    Attributes\n    ----------\n    mirror : str\n        Which mirror this panel is for.\n        Should be 'primary' or 'secondary'.\n    row : int\n        The row of the panel.\n    col : int\n        The column of the panel.\n    corners : NDArray[np.float32]\n        Array of panel corners.\n        Should have shape `(4, 3)`.\n    measurements : NDArray[np.float32]\n        The measurement data for this panel.\n        Should be in the mirror's internal coords.\n        Should have shape `(npoint, 3)`.\n    nom_adj : NDArray[np.float32]\n        The nominal position of the adjusters in the mirror internal coordinates.\n        Should have shape `(5, 3)`.\n    compensate : float, default: 0\n        The amount (in mm) to compensate the model surface by.\n        This is to account for things like the Faro SMR.\n    \"\"\"\n\n    mirror: str\n    row: int\n    col: int\n    corners: NDArray[np.float32]\n    measurements: NDArray[np.float32]\n    nom_adj: NDArray[np.float32]\n    compensate: float = field(default=0.0)\n    adjuster_radius: float = field(default=50.0)\n\n    def __post_init__(self):\n        self.measurements = np.atleast_2d(self.measurements)\n\n    def __setattr__(self, name, value):\n        if (\n            name == \"nom_adj\"\n            or name == \"mirror\"\n            or name == \"measurements\"\n            or name == \"compensate\"\n        ):\n            self.__dict__.pop(\"can_surface\", None)\n            self.__dict__.pop(\"model\", None)\n            self.__dict__.pop(\"residuals\", None)\n            self.__dict__.pop(\"transformed_residuals\", None)\n            self.__dict__.pop(\"res_norm\", None)\n            self.__dict__.pop(\"rms\", None)\n            self.__dict__.pop(\"meas_surface\", None)\n            self.__dict__.pop(\"meas_adj\", None)\n            self.__dict__.pop(\"meas_adj_resid\", None)\n            self.__dict__.pop(\"model_transformed\", None)\n            self.__dict__.pop(\"_transform\", None)\n        elif name == \"adjuster_radius\":\n            self.__dict__.pop(\"meas_adj_resid\", None)\n        return super().__setattr__(name, value)\n\n    @cached_property\n    def model(self):\n        \"\"\"\n        The modeled mirror surface at the locations of the measurementss.\n        \"\"\"\n        model = self.measurements.copy()\n        model[:, 2] = mirror_surface(model[:, 0], model[:, 1], a[self.mirror])\n        if self.compensate != 0.0:\n            compensation = self.compensate * mirror_norm(\n                model[:, 0], model[:0], a[self.mirror]\n            )\n            model += compensation\n        return model\n\n    @cached_property\n    def _transform(self):\n        return get_rigid(self.model, self.measurements, center_dst=True, method=\"mean\")\n\n    @property\n    def rot(self):\n        \"\"\"\n        Rotation that aligns the model to the measurements.\n        \"\"\"\n        return self._transform[0]\n\n    @property\n    def shift(self):\n        \"\"\"\n        Shift that aligns the model to the measurements.\n        \"\"\"\n        return self._transform[1]\n\n    @cached_property\n    def can_surface(self):\n        \"\"\"\n        Get the cannonical points to define the panel surface.\n        These are the adjuster positions projected only the mirror surface.\n        Note that this is in the nominal coordinates not the measured ones.\n        \"\"\"\n        can_z = mirror_surface(self.nom_adj[:, 0], self.nom_adj[:, 1], a[self.mirror])\n        points = self.nom_adj.copy()\n        points[:, 2] = can_z\n        return points\n\n    @cached_property\n    def meas_surface(self):\n        \"\"\"\n        The cannonical surface transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.can_surface, self.rot, self.shift)\n\n    @cached_property\n    def meas_adj(self):\n        \"\"\"\n        The adjuster points transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.nom_adj, self.rot, self.shift)\n\n    @cached_property\n    def meas_adj_resid(self):\n        \"\"\"\n        A correction that can be applied to `meas_adj` where we compute\n        the average residual of measured points from the transformed model\n        that are within `adjuster_radius` of the adjuster point in `xy`.\n        \"\"\"\n        resid = np.zeros(len(self.meas_adj))\n        for i, adj in enumerate(self.meas_adj):\n            dists = np.linalg.norm(self.measurements[:, :2] - adj[:2], axis=-1)\n            msk = dists &lt;= self.adjuster_radius\n            if np.sum(msk) == 0:\n                continue\n            resid[i] = np.mean(self.transformed_residuals[msk, 2])\n\n        return resid\n\n    @cached_property\n    def model_transformed(self):\n        \"\"\"\n        The model transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.model, self.rot, self.shift)\n\n    @cached_property\n    def residuals(self):\n        \"\"\"\n        Get residuals between model and measurements.\n        \"\"\"\n        return self.measurements - self.model\n\n    @cached_property\n    def transformed_residuals(self):\n        \"\"\"\n        Get residuals between transformed model and measurements.\n        \"\"\"\n        return self.measurements - self.model_transformed\n\n    @cached_property\n    def res_norm(self):\n        \"\"\"\n        Get norm of residuals between transformed model and measurements.\n        \"\"\"\n        return np.linalg.norm(self.residuals, axis=-1)\n\n    @cached_property\n    def rms(self):\n        \"\"\"\n        Get rms between model and measurements.\n        \"\"\"\n        return np.sqrt(np.mean(self.residuals[:, 2].ravel() ** 2))\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.can_surface","title":"<code>can_surface</code>  <code>cached</code> <code>property</code>","text":"<p>Get the cannonical points to define the panel surface. These are the adjuster positions projected only the mirror surface. Note that this is in the nominal coordinates not the measured ones.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_adj","title":"<code>meas_adj</code>  <code>cached</code> <code>property</code>","text":"<p>The adjuster points transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_adj_resid","title":"<code>meas_adj_resid</code>  <code>cached</code> <code>property</code>","text":"<p>A correction that can be applied to <code>meas_adj</code> where we compute the average residual of measured points from the transformed model that are within <code>adjuster_radius</code> of the adjuster point in <code>xy</code>.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_surface","title":"<code>meas_surface</code>  <code>cached</code> <code>property</code>","text":"<p>The cannonical surface transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.model","title":"<code>model</code>  <code>cached</code> <code>property</code>","text":"<p>The modeled mirror surface at the locations of the measurementss.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.model_transformed","title":"<code>model_transformed</code>  <code>cached</code> <code>property</code>","text":"<p>The model transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.res_norm","title":"<code>res_norm</code>  <code>cached</code> <code>property</code>","text":"<p>Get norm of residuals between transformed model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.residuals","title":"<code>residuals</code>  <code>cached</code> <code>property</code>","text":"<p>Get residuals between model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.rms","title":"<code>rms</code>  <code>cached</code> <code>property</code>","text":"<p>Get rms between model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.rot","title":"<code>rot</code>  <code>property</code>","text":"<p>Rotation that aligns the model to the measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.shift","title":"<code>shift</code>  <code>property</code>","text":"<p>Shift that aligns the model to the measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.transformed_residuals","title":"<code>transformed_residuals</code>  <code>cached</code> <code>property</code>","text":"<p>Get residuals between transformed model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.gen_panels","title":"<code>gen_panels(mirror, measurements, corners, adjusters, compensate=0.0, adjuster_radius=50.0)</code>","text":"<p>Use a set of measurements to generate panel objects.</p> <p>Parameters:</p> Name Type Description Default <code>mirror</code> <code>str</code> <p>The mirror these panels belong to. Should be 'primary' or 'secondary'.</p> required <code>measurements</code> <code>dict[str, NDArray[float32]]</code> <p>The photogrammetry data. Dict is data indexed by the target names.</p> required <code>corners</code> <code>dict[tuple[int, int], ndarray[float32]]</code> <p>The corners. This is indexed by a (row, col) tuple. Each entry is <code>(4, 3)</code> array where each row is a corner.</p> required <code>adjusters</code> <code>dict[tuple[int, int], NDArray[float32]]</code> <p>Nominal adjuster locations. This is indexed by a (row, col) tuple. Each entry is <code>(5, 3)</code> array where each row is an adjuster.</p> required <code>compensate</code> <code>float</code> <p>Amount (in mm) to compensate the model surface by. This is to account for things like the faro SMR.</p> <code>0.0</code> <code>adjuster_radius</code> <code>float</code> <p>The radius in XY of points that an adjuster should use to compute a secondary correction on its position. Should be in mm.</p> <code>50.0</code> <p>Returns:</p> Name Type Description <code>panels</code> <code>list[Panels]</code> <p>A list of panels with the transforme initialized to the identity.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def gen_panels(\n    mirror: str,\n    measurements: dict[str, NDArray[np.float32]],\n    corners: dict[tuple[int, int], NDArray[np.float32]],\n    adjusters: dict[tuple[int, int], NDArray[np.float32]],\n    compensate: float = 0.0,\n    adjuster_radius: float = 50.0,\n) -&gt; list[Panel]:\n    \"\"\"\n    Use a set of measurements to generate panel objects.\n\n    Parameters\n    ----------\n    mirror : str\n        The mirror these panels belong to.\n        Should be 'primary' or 'secondary'.\n    measurements : dict[str, NDArray[np.float32]]\n        The photogrammetry data.\n        Dict is data indexed by the target names.\n    corners : dict[tuple[int, int], ndarray[np.float32]]\n        The corners. This is indexed by a (row, col) tuple.\n        Each entry is `(4, 3)` array where each row is a corner.\n    adjusters : dict[tuple[int, int], NDArray[np.float32]]\n        Nominal adjuster locations.\n        This is indexed by a (row, col) tuple.\n        Each entry is `(5, 3)` array where each row is an adjuster.\n    compensate : float, default: 0.0\n        Amount (in mm) to compensate the model surface by.\n        This is to account for things like the faro SMR.\n    adjuster_radius : float, default: 50.0\n        The radius in XY of points that an adjuster should use to\n        compute a secondary correction on its position.\n        Should be in mm.\n\n    Returns\n    -------\n    panels : list[Panels]\n        A list of panels with the transforme initialized to the identity.\n    \"\"\"\n    points = defaultdict(list)\n    # dumb brute force\n    corr = np.arange(4, dtype=int)\n    for _, point in measurements.items():\n        for rc, crns in corners.items():\n            x = crns[:, 0] &gt; point[0]\n            y = crns[:, 1] &gt; point[1]\n            val = x.astype(int) + 2 * y.astype(int)\n            if np.array_equal(np.sort(val), corr):\n                points[rc] += [point]\n                break\n\n    # Now init the objects\n    panels = []\n    for (row, col), meas in points.items():\n        meas = np.vstack(meas, dtype=np.float32)\n        panel = Panel(\n            mirror,\n            row,\n            col,\n            corners[(row, col)],\n            meas,\n            adjusters[(row, col)],\n            compensate,\n            adjuster_radius,\n        )\n        panels += [panel]\n    return panels\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.mirror_norm","title":"<code>mirror_norm(x, y, a)</code>","text":"<p>Analytic form of the vector normal to the mirror surface.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float32]</code> <p>X positions to calculate at in mm.</p> required <code>y</code> <code>NDArray[float32]</code> <p>Y positions to calculate at in mm. Should have the same shape as <code>x</code>.</p> required <code>a</code> <code>NDArray[float32]</code> <p>Coeffecients of the mirror function. Use <code>a_primary</code> for the primary mirror. Use <code>a_secondary</code> for the secondary mirror.</p> required <p>Returns:</p> Name Type Description <code>normals</code> <code>NDArray[float32]</code> <p>Unit vector normal to the mirror surface at each input coordinate. Has shape <code>shape(x) + (3,)</code>.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def mirror_norm(\n    x: NDArray[np.float32], y: NDArray[np.float32], a: NDArray[np.float32]\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Analytic form of the vector normal to the mirror surface.\n\n    Parameters\n    ----------\n    x : NDArray[np.float32]\n        X positions to calculate at in mm.\n    y : NDArray[np.float32]\n        Y positions to calculate at in mm.\n        Should have the same shape as `x`.\n    a : NDArray[np.float32]\n        Coeffecients of the mirror function.\n        Use `a_primary` for the primary mirror.\n        Use `a_secondary` for the secondary mirror.\n\n    Returns\n    -------\n    normals : NDArray[np.float32]\n        Unit vector normal to the mirror surface at each input coordinate.\n        Has shape `shape(x) + (3,)`.\n    \"\"\"\n    Rn = 3000.0\n\n    x_n = np.zeros_like(x)\n    y_n = np.zeros_like(y)\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):\n            if i != 0:\n                x_n += a[i, j] * (x ** (i - 1)) / (Rn**i) * (y / Rn) ** j\n            if j != 0:\n                y_n += a[i, j] * (x / Rn) ** i * (y ** (j - 1)) / (Rn**j)\n\n    z_n = -1 * np.ones_like(x_n)\n    normals = np.array((x_n, y_n, z_n)).T\n    normals /= np.linalg.norm(normals, axis=-1)[:, np.newaxis]\n    return normals\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.mirror_surface","title":"<code>mirror_surface(x, y, a)</code>","text":"<p>Analytic form of the mirror surface.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float32]</code> <p>X positions to calculate at in mm.</p> required <code>y</code> <code>NDArray[float32]</code> <p>Y positions to calculate at in mm. Should have the same shape as <code>x</code>.</p> required <code>a</code> <code>NDArray[float32]</code> <p>Coeffecients of the mirror function. Use <code>a_primary</code> for the primary mirror. Use <code>a_secondary</code> for the secondary mirror.</p> required <p>Returns:</p> Name Type Description <code>z</code> <code>NDArray[float32]</code> <p>Z position of the mirror at each input coordinate. Has the same shape as <code>x</code>.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def mirror_surface(\n    x: NDArray[np.float32], y: NDArray[np.float32], a: NDArray[np.float32]\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Analytic form of the mirror surface.\n\n    Parameters\n    ----------\n    x : NDArray[np.float32]\n        X positions to calculate at in mm.\n    y : NDArray[np.float32]\n        Y positions to calculate at in mm.\n        Should have the same shape as `x`.\n    a : NDArray[np.float32]\n        Coeffecients of the mirror function.\n        Use `a_primary` for the primary mirror.\n        Use `a_secondary` for the secondary mirror.\n\n    Returns\n    -------\n    z : NDArray[np.float32]\n        Z position of the mirror at each input coordinate.\n        Has the same shape as `x`.\n    \"\"\"\n    z = np.zeros_like(x)\n    Rn = 3000.0\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):\n            z += a[i, j] * (x / Rn) ** i * (y / Rn) ** j\n    return z\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.plot_panels","title":"<code>plot_panels(panels, title_str, vmax=None)</code>","text":"<p>Make a plot containing panel residuals and histogram. TODO: Correlation?</p> <p>Parameters:</p> Name Type Description Default <code>panels</code> <code>list[Panel]</code> <p>The panels to plot.</p> required <code>title_str</code> <code>str</code> <p>The title string, rms will me appended.</p> required <code>vmax</code> <code>Optional[float]</code> <p>The max of the colorbar. vmin will be -1 times this. Set to None to compute automatically. Should be in um.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>figure</code> <code>Figure</code> <p>The figure with panels plotted on it.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def plot_panels(\n    panels: list[Panel], title_str: str, vmax: Optional[float] = None\n) -&gt; Figure:\n    \"\"\"\n    Make a plot containing panel residuals and histogram.\n    TODO: Correlation?\n\n    Parameters\n    ----------\n    panels : list[Panel]\n        The panels to plot.\n    title_str : str\n        The title string, rms will me appended.\n    vmax : Optional[float], default: None\n        The max of the colorbar. vmin will be -1 times this.\n        Set to None to compute automatically.\n        Should be in um.\n\n    Returns\n    -------\n    figure : Figure\n        The figure with panels plotted on it.\n    \"\"\"\n    res_all = np.vstack([panel.residuals for panel in panels]) * 1000\n    model_all = np.vstack([panel.model for panel in panels])\n    if vmax is None:\n        vmax = np.max(np.abs(res_all[:, 2]))\n    if vmax is None:\n        raise ValueError(\"vmax still None?\")\n    gs = gridspec.GridSpec(2, 2, width_ratios=[20, 1], height_ratios=[2, 1])\n    fig = plt.figure()\n    ax0 = plt.subplot(gs[0])\n    cax = plt.subplot(gs[1])\n    ax1 = plt.subplot(gs[2:])\n    cb = None\n    for panel in panels:\n        ax0.tricontourf(\n            panel.model[:, 0],\n            panel.model[:, 1],\n            panel.residuals[:, 2] * 1000,\n            vmin=-1 * vmax,\n            vmax=vmax,\n            cmap=\"coolwarm\",\n            alpha=0.6,\n        )\n        cb = ax0.scatter(\n            panel.model[:, 0],\n            panel.model[:, 1],\n            s=40,\n            c=panel.residuals[:, 2] * 1000,\n            vmin=-1 * vmax,\n            vmax=vmax,\n            cmap=\"coolwarm\",\n            marker=\"o\",\n            alpha=0.9,\n            linewidth=2,\n            edgecolor=\"black\",\n        )\n        ax0.scatter(\n            panel.meas_adj[:, 0],\n            panel.meas_adj[:, 1],\n            marker=\"x\",\n            linewidth=1,\n            color=\"black\",\n        )\n    ax0.tricontourf(\n        model_all[:, 0],\n        model_all[:, 1],\n        res_all[:, 2],\n        vmin=-1 * vmax,\n        vmax=vmax,\n        cmap=\"coolwarm\",\n        alpha=0.2,\n    )\n    ax0.set_xlabel(\"x (mm)\")\n    ax0.set_ylabel(\"y (mm)\")\n    ax0.set_xlim(-3300, 3300)  # ack hardcoded!\n    ax0.set_ylim(-3300, 3300)\n    if cb is not None:\n        fig.colorbar(cb, cax)\n    ax0.set_aspect(\"equal\")\n    for panel in panels:\n        ax0.add_patch(\n            Polygon(panel.corners[[0, 1, 3, 2], :2], fill=False, color=\"black\")\n        )\n\n    ax1.hist(res_all[:, 2], bins=len(panels))\n    ax1.set_xlabel(\"z residual (um)\")\n\n    points = np.array([len(panel.measurements) for panel in panels])\n    rms = np.array([panel.rms for panel in panels])\n    tot_rms = 1000 * np.sum(rms * points) / np.sum(points)\n    fig.suptitle(f\"{title_str}, RMS={tot_rms:.2f} um\")\n\n    plt.show()\n\n    return fig\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.remove_cm","title":"<code>remove_cm(meas, mirror, compensate=0, thresh=10, cut_thresh=50, niters=10, verbose=False)</code>","text":"<p>Fit for the common mode transformation from the model to the measurements of all panels and them remove it. Note that we only remove the shift component of the common mode, rotations are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>meas</code> <code>dict[str, NDArray[float32]]</code> <p>The photogrammetry data. Dict is data indexed by the target names.</p> required <code>mirror</code> <code>str</code> <p>The mirror this data belong to. Should be 'primary' or 'secondary'.</p> required <code>compensate</code> <code>float</code> <p>Compensation to apply to model. This is to account for the radius of a Faro SMR.</p> <code>0</code> <code>thresh</code> <code>float</code> <p>How many times higher than the median residual a point needs to have to be considered an outlier.</p> <code>10</code> <code>niters</code> <code>int</code> <p>How many iterations of common mode fitting to do.</p> <code>10</code> <code>verbose</code> <code>bool</code> <p>If True print the transformation for each iteration.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>kept_panels</code> <code>list[Panel]</code> <p>The panels that were successfully fit.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def remove_cm(\n    meas,\n    mirror,\n    compensate: float = 0,\n    thresh: float = 10,\n    cut_thresh: float = 50,\n    niters: int = 10,\n    verbose=False,\n) -&gt; dict[str, NDArray[np.float32]]:\n    \"\"\"\n    Fit for the common mode transformation from the model to the measurements of all panels and them remove it.\n    Note that we only remove the shift component of the common mode, rotations are ignored.\n\n    Parameters\n    ----------\n    meas : dict[str, NDArray[np.float32]]\n        The photogrammetry data.\n        Dict is data indexed by the target names.\n    mirror : str\n        The mirror this data belong to.\n        Should be 'primary' or 'secondary'.\n    compensate : float, default: 0\n        Compensation to apply to model.\n        This is to account for the radius of a Faro SMR.\n    thresh : float, default: 10\n        How many times higher than the median residual a point needs to have to be\n        considered an outlier.\n    niters : int, default: 10\n        How many iterations of common mode fitting to do.\n    verbose : bool, default: False\n        If True print the transformation for each iteration.\n\n    Returns\n    -------\n    kept_panels : list[Panel]\n        The panels that were successfully fit.\n    \"\"\"\n\n    def _cm(x, panel):\n        panel.measurements[:] -= x[1:4]\n        rot = Rotation.from_euler(\"xyz\", x[4:])\n        panel.measurements = rot.apply(panel.measurements)\n        panel.measurements *= x[0]\n\n    def _opt(x, panel):\n        p2 = deepcopy(panel)\n        _cm(x, p2)\n        return p2.rms\n\n    # make a fake panel for the full mirror\n    corners = np.array(\n        ([-3300, -3300, 0], [-3300, 3300, 0], [3300, 3300, 0], [3300, -3300, 0])\n    )  # ack hardcoded\n    labels = np.array(list(meas.keys()))\n    data = np.array(list(meas.values()))\n    corr = np.arange(4, dtype=int)\n    x = np.vstack([corners[:, 0] &gt; dat[0] for dat in data])\n    y = np.vstack([corners[:, 1] &gt; dat[1] for dat in data])\n    val = x.astype(int) + 2 * y.astype(int)\n    val = np.sort(val, axis=-1)\n    msk = (val == corr).all(-1)\n    data = data[msk]\n    labels = labels[msk]\n    panel = Panel(\n        mirror,\n        -1,\n        -1,\n        np.zeros((4, 3), \"float32\"),\n        data,\n        np.zeros((5, 3), \"float32\"),\n        compensate,\n    )\n    data = data.copy()\n    data_clean = data.copy()\n\n    x0 = np.hstack([np.ones(1), np.zeros(6)])\n    bounds = [(-0.95, 1.05)] + [(-100, 100)] * 3 + [(0, 2 * np.pi)] * 3\n\n    for i in range(niters):\n        if len(panel.measurements) &lt; 3:\n            raise ValueError\n        print(f\"iter {i} for common mode fit\")\n        cut = panel.res_norm &gt; thresh * np.median(panel.res_norm)\n        if np.sum(cut) &gt; 0:\n            # print(f\"\\tRemoving {np.sum(cut)} points from mirror\")\n            panel.measurements = panel.measurements[~cut]\n            # labels = labels[~cut]\n            data = data[~cut]\n\n        if verbose:\n            print(f\"\\tRemoving a naive common mode shift of {panel.shift}\")\n        panel.measurements -= panel.shift\n        panel.measurements @= panel.rot.T\n\n        res = minimize(_opt, x0, (panel,), bounds=bounds)\n        if verbose:\n            print(\n                f\"\\tRemoving a fit common mode with scale {res.x[0]}, shift {res.x[1:4]}, and rotation {res.x[4:]}\"\n            )\n        _cm(res.x, panel)\n\n        if verbose:\n            print(\n                f\"\\tRemoving a secondary common mode shift of {panel.shift} and rotation of {decompose_rotation(panel.rot)}\"\n            )\n        panel.measurements -= panel.shift\n        panel.measurements @= panel.rot.T\n\n    aff, sft = get_affine(\n        data, panel.measurements, method=\"mean\", weights=np.ones(len(data))\n    )\n    scale, shear, rot = decompose_affine(aff)\n    rot = decompose_rotation(rot)\n    print(\n        f\"Full common mode is:\\n\\tshift = {sft} mm\\n\\tscale = {scale}\\n\\tshear = {shear}\\n\\trot = {np.rad2deg(rot)} deg\"\n    )\n\n    panel.measurements = apply_transform(data_clean, aff, sft)\n    cut = panel.res_norm &gt; cut_thresh * np.median(panel.res_norm)\n    if np.sum(cut) &gt; 0:\n        print(f\"Removing {np.sum(cut)} points from mirror\")\n        panel.measurements = panel.measurements[~cut]\n\n    return {l: d for l, d in zip(labels, panel.measurements)}\n</code></pre>"},{"location":"reference/transforms/","title":"transforms","text":"<p>Functions for coordinate transforms.</p> <p>There are 6 relevant coordinate systems here, belonging to two sets of three. Each set is a global, a primary, and a secondary coordinate system; where primary and secondary are internal to those mirrors. The two sets of coordinates are the optical coordinates and the coordinates used by vertex. We denote these six coordinate systems as follows:</p> <pre><code>- opt_global\n- opt_primary\n- opt_secondary\n- va_global\n- va_primary\n- va_secondary\n</code></pre>"},{"location":"reference/transforms/#lat_alignment.transforms.align_photo","title":"<code>align_photo(labels, coords, *, mirror='primary', reference=None, max_dist=100.0)</code>","text":"<p>Align photogrammetry data and then put it into mirror coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>NDArray[str_]</code> <p>The labels of each photogrammetry point. Should have shape <code>(npoint,)</code>.</p> required <code>coords</code> <code>NDArray[float32]</code> <p>The coordinates of each photogrammetry point. Should have shape <code>(npoint, 3)</code>.</p> required <code>mirror</code> <code>str</code> <p>The mirror that these points belong to. Should be either: 'primary' or 'secondary'.</p> <code>'primary'</code> <code>reference</code> <code>Optional[list[tuple[tuple[float, float, float], list[str]]]]</code> <p>List of reference points to use. Each point given should be a tuple with two elements. The first element is a tuple with the (x, y, z) coordinates of the point in the global coordinate system. The second is a list of nearby coded targets that can be used to identify the point. If <code>None</code> the default reference for each mirror is used.</p> <code>None</code> <code>max_dist</code> <code>float</code> <p>Max distance in mm that the reference poing can be from the target point used to locate it.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>labels</code> <code>NDArray[str_]</code> <p>The labels of each photogrammetry point. Invar points are not included.</p> <code>coords_transformed</code> <code>NDArray[float32]</code> <p>The transformed coordinates. Invar points are not included.</p> <code>msk</code> <code>NDArray[bool_]</code> <p>Mask to removes invar points</p> Source code in <code>lat_alignment/transforms.py</code> <pre><code>def align_photo(\n    labels: NDArray[np.str_],\n    coords: NDArray[np.float32],\n    *,\n    mirror: str = \"primary\",\n    reference: Optional[list[tuple[tuple[float, float, float], list[str]]]] = None,\n    max_dist: float = 100.0,\n) -&gt; tuple[NDArray[np.str_], NDArray[np.float32], NDArray[np.bool_]]:\n    \"\"\"\n    Align photogrammetry data and then put it into mirror coordinates.\n\n    Parameters\n    ----------\n    labels : NDArray[np.str_]\n        The labels of each photogrammetry point.\n        Should have shape `(npoint,)`.\n    coords : NDArray[np.float32]\n        The coordinates of each photogrammetry point.\n        Should have shape `(npoint, 3)`.\n    mirror : str, default: 'primary'\n        The mirror that these points belong to.\n        Should be either: 'primary' or 'secondary'.\n    reference : Optional[list[tuple[tuple[float, float, float], list[str]]]], default: None\n        List of reference points to use.\n        Each point given should be a tuple with two elements.\n        The first element is a tuple with the (x, y, z) coordinates\n        of the point in the global coordinate system.\n        The second is a list of nearby coded targets that can be used\n        to identify the point.\n        If `None` the default reference for each mirror is used.\n    max_dist : float, default: 100\n        Max distance in mm that the reference poing can be from the target\n        point used to locate it.\n\n    Returns\n    -------\n    labels : NDArray[np.str_]\n        The labels of each photogrammetry point.\n        Invar points are not included.\n    coords_transformed : NDArray[np.float32]\n        The transformed coordinates.\n        Invar points are not included.\n    msk : NDArray[np.bool_]\n        Mask to removes invar points\n    \"\"\"\n    if mirror not in [\"primary\", \"secondary\"]:\n        raise ValueError(f\"Invalid mirror: {mirror}\")\n    if mirror == \"primary\":\n        transform = partial(coord_transform, cfrom=\"va_global\", cto=\"opt_primary\")\n    else:\n        transform = partial(coord_transform, cfrom=\"va_global\", cto=\"opt_secondary\")\n    if reference is None:\n        reference = DEFAULT_REF[mirror]\n    if reference is None or len(reference) == 0:\n        raise ValueError(\"Invalid or empty reference\")\n\n    # Lets find the points we can use\n    trg_idx = np.where(np.char.find(labels, \"TARGET\") &gt;= 0)[0]\n    ref = []\n    pts = []\n    invars = []\n    for rpoint, codes in reference:\n        have = np.isin(codes, labels)\n        if np.sum(have) == 0:\n            continue\n        coded = coords[np.where(labels == codes[np.where(have)[0][0]])[0][0]]\n        print(codes[np.where(have)[0][0]])\n        # Find the closest point\n        dist = np.linalg.norm(coords[trg_idx] - coded, axis=-1)\n        if np.min(dist) &gt; max_dist:\n            continue\n        print(np.min(dist))\n        ref += [rpoint]\n        pts += [coords[trg_idx][np.argmin(dist)]]\n        invars += [labels[trg_idx][np.argmin(dist)]]\n    if len(ref) &lt; 4:\n        raise ValueError(f\"Only {len(ref)} reference points found! Can't align!\")\n    msk = [0, 1, 3]\n    pts = np.vstack(pts)[msk]\n    ref = np.vstack(ref)[msk]\n    pts = np.vstack((pts, np.mean(pts, 0)))\n    ref = np.vstack((ref, np.mean(ref, 0)))\n    ref = transform(ref)\n    print(\"Reference points in mirror coords:\")\n    print(ref[:-1])\n    print(make_edm(ref) / make_edm(pts))\n    print(make_edm(ref) - make_edm(pts))\n    print(np.nanmedian(make_edm(ref) / make_edm(pts)))\n    pts *= np.nanmedian(make_edm(ref) / make_edm(pts))\n    print(make_edm(ref) / make_edm(pts))\n    print(make_edm(ref) - make_edm(pts))\n    print(np.nanmedian(make_edm(ref) / make_edm(pts)))\n\n    rot, sft = get_rigid(pts, ref, method=\"mean\")\n    pts_t = apply_transform(pts, rot, sft)\n    import matplotlib.pyplot as plt\n\n    plt.scatter(pts_t[:, 0], pts_t[:, 1], color=\"b\")\n    plt.scatter(ref[:, 0], ref[:, 1], color=\"r\")\n    plt.show()\n    print(pts_t[:-1])\n    print(pts_t - ref)\n    print(\n        f\"RMS of reference points after alignment: {np.sqrt(np.mean((pts_t - ref)**2))}\"\n    )\n    coords_transformed = apply_transform(coords, rot, sft)\n\n    msk = ~np.isin(labels, invars)\n\n    return labels[msk], coords_transformed[msk], msk\n</code></pre>"},{"location":"reference/transforms/#lat_alignment.transforms.coord_transform","title":"<code>coord_transform(coords, cfrom, cto)</code>","text":"<p>Transform between the six defined mirror coordinates:</p> <pre><code>- opt_global\n- opt_primary\n- opt_secondary\n- va_global\n- va_primary\n- va_secondary\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>NDArray[float32]</code> <p>Coordinates to transform. Should be a <code>(npoint, 3)</code> array.</p> required <code>cfrom</code> <code>str</code> <p>The coordinate system that <code>coords</code> is currently in.</p> required <code>cto</code> <code>str</code> <p>The coordinate system to put <code>coords</code> into.</p> required <p>Returns:</p> Name Type Description <code>coords_transformed</code> <code>NDArray[float32]</code> <p><code>coords</code> transformed into <code>cto</code>.</p> Source code in <code>lat_alignment/transforms.py</code> <pre><code>def coord_transform(\n    coords: NDArray[np.float32], cfrom: str, cto: str\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Transform between the six defined mirror coordinates:\n\n        - opt_global\n        - opt_primary\n        - opt_secondary\n        - va_global\n        - va_primary\n        - va_secondary\n\n    Parameters\n    ----------\n    coords : NDArray[np.float32]\n        Coordinates to transform.\n        Should be a `(npoint, 3)` array.\n    cfrom : str\n        The coordinate system that `coords` is currently in.\n    cto : str\n        The coordinate system to put `coords` into.\n\n    Returns\n    -------\n    coords_transformed : NDArray[np.float32]\n        `coords` transformed into `cto`.\n    \"\"\"\n    if cfrom == cto:\n        return coords\n    match f\"{cfrom}-{cto}\":\n        case \"opt_global-opt_primary\":\n            return _opt_global_to_opt_primary(coords)\n        case \"opt_global-opt_secondary\":\n            return _opt_global_to_opt_secondary(coords)\n        case \"opt_primary-opt_global\":\n            return _opt_primary_to_opt_global(coords)\n        case \"opt_secondary-opt_global\":\n            return _opt_secondary_to_opt_global(coords)\n        case \"opt_primary-opt_secondary\":\n            return _opt_primary_to_opt_secondary(coords)\n        case \"opt_secondary-opt_primary\":\n            return _opt_secondary_to_opt_primary(coords)\n        case \"va_global-va_primary\":\n            return _va_global_to_va_primary(coords)\n        case \"va_global-va_secondary\":\n            return _va_global_to_va_secondary(coords)\n        case \"va_primary-va_global\":\n            return _va_primary_to_va_global(coords)\n        case \"va_secondary-va_global\":\n            return _va_secondary_to_va_global(coords)\n        case \"va_primary-va_secondary\":\n            return _va_primary_to_va_secondary(coords)\n        case \"va_secondary-va_primary\":\n            return _va_secondary_to_va_primary(coords)\n        case \"opt_global-va_global\":\n            return _opt_global_to_va_global(coords)\n        case \"opt_global-va_primary\":\n            return _opt_global_to_va_primary(coords)\n        case \"opt_global-va_secondary\":\n            return _opt_global_to_va_secondary(coords)\n        case \"opt_primary-va_global\":\n            return _opt_primary_to_va_global(coords)\n        case \"opt_primary-va_primary\":\n            return _opt_primary_to_va_primary(coords)\n        case \"opt_primary-va_secondary\":\n            return _opt_primary_to_va_secondary(coords)\n        case \"opt_secondary-va_global\":\n            return _opt_secondary_to_va_global(coords)\n        case \"opt_secondary-va_primary\":\n            return _opt_secondary_to_va_primary(coords)\n        case \"opt_secondary-va_secondary\":\n            return _opt_secondary_to_va_secondary(coords)\n        case \"va_global-opt_global\":\n            return _va_global_to_opt_global(coords)\n        case \"va_global-opt_primary\":\n            return _va_global_to_opt_primary(coords)\n        case \"va_global-opt_secondary\":\n            return _va_global_to_opt_secondary(coords)\n        case \"va_primary-opt_global\":\n            return _va_primary_to_opt_global(coords)\n        case \"va_primary-opt_primary\":\n            return _va_primary_to_opt_primary(coords)\n        case \"va_primary-opt_secondary\":\n            return _va_primary_to_opt_secondary(coords)\n        case \"va_secondary-opt_global\":\n            return _va_secondary_to_opt_global(coords)\n        case \"va_secondary-opt_primary\":\n            return _va_secondary_to_opt_primary(coords)\n        case \"va_secondary-opt_secondary\":\n            return _va_secondary_to_opt_secondary(coords)\n        case _:\n            raise ValueError(\"Invalid coordinate system provided!\")\n</code></pre>"}]}