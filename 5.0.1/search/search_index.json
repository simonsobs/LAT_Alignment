{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LAT Alignment","text":"<p>Tools for Large Aperture Telescope (LAT) mirror alignment. While these tools are currently specific to the Simons Observatory LAT, much of the library could be generalized to any telescope alignment.</p> <p>For details on usage please read the alignment procedure documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>Technically after cloning this repository you can just run <code>python lat_alignment/alignment.py PATH/TO/CONFIG</code>, but it is recommended that you install this as a package instead.</p> <p>To do this just run: <code>pip install -e .</code> from the root of this repository.</p> <p>This has two main benefits over running the script directly:</p> <ol> <li>It will handle dependencies for you.</li> <li>This sets up an entrypoint called <code>lat_alignment</code> so that you can call the code from anywhere. This is nice because now you can call the code from the measurement directory where you are most likely editing files, saving you the hassle of having to <code>cd</code> or wrangle long file paths.</li> </ol>"},{"location":"#bugs-and-feature-requests","title":"Bugs and Feature Requests","text":"<p>For low priority bugs and feature requests submit an issue on the git repo.</p> <p>For higher priority issues (or questions that require an expedient answer) email, Slack, or call me.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you wish to contribute to this repository (either code or adding measurement files) contact me via email or Slack.</p> <p>If you are contributing code please do so by creating a branch and submitting a pull request. Try to keep things as close to PEP8 as possible.</p>"},{"location":"alignment_procedure/","title":"Alignment Procedure","text":"<p>Here we describe the procedure for aligning the Simons Observatory (SO) Large Aperture Telescope (LAT) using this software package to process photogrammetry data taken using a Geodetic Systems' V-Stars system.</p> <p>With minor modifications these instructions and the software package could be generalized to other forms of measurements (ie: a laser tracker). Generalizing to other telescopes is possible but more involved. If you are interested in applying this software to other measurements or other telescopes please raise a GitHub issue for help with that.</p> <p>Before attempting and alignment it is useful to familiarize yourself with this relevant coordinate systems, the panel numbering scheme, and the package's configuration file.</p>"},{"location":"alignment_procedure/#reference-points","title":"Reference Points","text":"<p>Something that is key for both alignment stages is the use of reference points around the edges of the mirror and on the receiver. These are used to provide an initial transformation from the arbitrary coordinates that the photogrammetry measurements are in to a known coordinate system. These reference points should be places in locations that do not move when panels are installed (ie: around the edge of the mirror's back-up structure. In order to identify these points known coded targets should be placed near the reference points. Currently the locations of these points (in the \"Vertex Global\" coordinates) along with nearby coded targets are can be found in the <code>reference.yaml</code> data file.</p>"},{"location":"alignment_procedure/#panel-alignment","title":"Panel Alignment","text":"<p>When aligning panels the code takes the following steps:</p> <ol> <li>Use reference points to put the measurements in a know coordinate system</li> <li>Transform to the mirror's internal coordinates in the \"Optical\" coordinate system.</li> <li>Remove measurements with high error</li> <li>Find and remove spurious measurements (sometimes the photogrammetry software will accidently find the same target multiple times, only one of those locations is typically of good quality).</li> <li>Fit the surface against the model in multiple iterations (10 by default). Each iteration we remove the common mode transform that all panels see when fit against the model. We also remove points that are far enough from the surface (after removing the common mode) that they seem to be outliers or measurements not of the mirror surface.</li> <li>For each panel fit a transformation that describes how that panel deviates from the model.</li> <li>Use the per panel transformations to estimate how each adjuster is, if we have a measurement sufficiently close to the surface above and adjuster is to used to compute a correction on top of the fit model.</li> <li>Fit for how each adjuster must be moved to correct for the errors in each panel's location and shape. When we do this we model turning each adjuster as a rotation about the axis created by the adjacent adjusters. For small adjustments this is approximately the same as treating the adjusters as independent and simply moving them by their residuals. For large adjustments this is needed to correctly account for the interplay between adjusters.</li> </ol> <p>Warning</p> <p>Note that due to the common mode removal in step 5 above, the overall position of the mirror is not gaurunteed to be correct, only the shape of the surface. However this step is needed in order to account for errors in the locations of the reference point and cannot be skipped. The optical element alignment is needed after panel alignment to account for this an ensure that the mirrors and the receiver are in the correct location relative to each other.</p>"},{"location":"alignment_procedure/#inputs","title":"Inputs","text":"<p>There are only two required inputs to do the panel alignment.</p> <p>The first is a configuration file with the <code>mode</code> field set to <code>panel</code>, see here for an example.</p> <p>The second is a photogrammetry measurement of the mirror we want to align panels for. This measurement should only include measurements of one mirror and should have good measurements of at least four reference points.</p>"},{"location":"alignment_procedure/#outputs","title":"Outputs","text":"<p>The software produces two outputs: a plot of the mirror surface residuals and a <code>csv</code> file with the desired adjustments.</p> <p>The RMS in the title of the plot is the RMS of the residuals between the mirror model and the photogrammetry measurements. Each circle on the upper plot represents a point measured by photogrammetry and the grid shows the panel locations. Additionally there are three layers of colors overlayed on the plot. The colors within each circle show the residual at each measurement point, these colors can be interpreted using the colorbar. The low alpha background shows the residuals interpolated across the whole mirror, this is to show large scale trends but due to the low alpha should not be directly interpreted using the colorbar. The contour withing each panel shows the residuals interpolated between any points measured for that specific panel and show the errors in the shape of each panel as currently aligned, these colors can be interpreted using the color bar. The histogram below the surface plot shows the distribution of residuals for this measurement, if we have aligned to the white noise limit of the measurement then we expect this to look like a gaussian centered on 0.</p> <p></p> <p>The <code>csv</code> file contains the adjustments (and their associated uncertainties) for each panel in the measurement. Each row follows the format of the output of <code>alignement.adjust_panel</code>.</p>"},{"location":"alignment_procedure/#optical-element-alignment","title":"Optical Element Alignment","text":"<p>WIP! Check back later!</p>"},{"location":"config_file/","title":"Configuration File","text":""},{"location":"config_file/#fields","title":"Fields","text":"<code>mode</code> <p>The alignment mode to use.</p> <p>Possible values are:</p> <ul> <li><code>panel</code>: For aligning panels within one mirror.</li> <li><code>optical</code>: For aligning optical elements relative to each other (as solid bodies).</li> </ul> <code>mirror</code> <p>The mirror that we want to align panels to. Only used if <code>mode</code> is <code>panel</code>.</p> <p>Possible values are:</p> <ul> <li><code>primary</code>: To align the primary mirror.</li> <li><code>secondary</code>: To align the secondary mirror.</li> </ul> <code>align_to</code> <p>Which optical element to keep fixed and align the others to. Only used if <code>mode</code> is <code>optical</code>.</p> <p>Possible values are:</p> <ul> <li><code>primary</code>: To align to the primary mirror.</li> <li><code>secondary</code>: To align to the secondary mirror.</li> <li><code>receiver</code>: To align to the receiver.</li> <li><code>bearing</code>: To align to the bearing.</li> </ul> <code>measurement</code> <p>The path to the photogrammetry data we are using to do the alignment. If this is a relative path it is taken relative to the directory that the configuration file is in.</p> <code>data_dir</code> <p>The path to the data files that define the panel corners and the adjuster positions. If this is a relative path it is taken relative to the directory that the configuration file is in.</p> <p>You genrally don't need to provide this since the package will use its own bundled data files by default.</p> <code>load</code> <p>Additional keyword arguments to pass to <code>io.load_photo</code>.</p> <code>load</code> <p>Additional keyword arguments to pass to <code>photogrammetry.align_photo</code>.</p> <code>compensate</code> <p>Amount to compensate mirror measurements by in mm. This is for backwards compatiblilty with laser tracker data and is \\(0\\) by default.</p> <code>common_mode</code> <p>Additional keyword arguments to pass to <code>mirror.remove_cm</code></p> <code>adjuster_radius</code> <p>How close to an adjuster a data point needs to be in order for us to use its residual as a secondary correction when computing adjustments. Only used if <code>mode</code> is <code>panel</code>.</p> <p>This is \\(100\\) mm by default.</p> <code>vmax</code> <p>The maximum value to use in the colorbar when plotting mirror surface. The colorbar is symmetric so <code>vmin = -1*vmax</code>.</p> <code>adjust</code> <p>Additional keyword arguments to pass to <code>adjustments.calc_adjustments</code></p> <code>title</code> <p>The title of the measurement. This is used both in plots and in output filenames.</p>"},{"location":"config_file/#example-configuration-files","title":"Example Configuration Files","text":"<p>These are typical configuration files, you usually will not need to touch fields other than the ones shown here.</p>"},{"location":"config_file/#panel-alignment","title":"Panel Alignment","text":"<pre><code>mode: \"panel\"\nmirror: \"secondary\"\nmeasurement: \"data_20240911_1430.csv\"\ntitle: \"M2 20240911 1430\"\nvmax: 50\n</code></pre>"},{"location":"config_file/#optical-element-alignment","title":"Optical Element Alignment","text":"<p>WIP! Check back later!</p>"},{"location":"coordinate_systems/","title":"Coordinate Systems","text":"<p>There are many coordinate systems that have been used to describe the LAT mirror, most of them were used a single time and them replaced. Here we describe the six coordinate systems that are actively used. These six coordinate systems can be organized into two groups: the \"Optical\" coordinate systems and the \"Vertex\" coordinate systems. Each of these groups contains three coordinate systems: \"Global\", \"Primary\", and \"Secondary\"; where \"Global\" is a global reference frame for the whole telescope, \"Primary\" is an internal reference frame for the primary mirror, and \"Secondary\" is an internal reference frame for the secondary mirror.</p> <p>In general this software package does all of its computations in the \"Optical\" systems, but it is useful to understand the \"Vertex\" systems so that one can utilize measurements provided by Vertex.</p> <p>Note that this page is mostly to give the user an understanding of how these coordinate systems are defined. You should never have to transform between them by hand. For that please use the <code>transforms.coord_transform</code> function.</p>"},{"location":"coordinate_systems/#optical-coordinate-systems","title":"Optical Coordinate Systems","text":"<p>The optical coordinate systems are designed to be logical given the optics of the telescope.</p> <p>For \"Primary\" and \"Secondary\" the axis are defined such that:</p> <ul> <li>The \\(x\\) axis changes as the panel column number changes.</li> <li>The \\(y\\) axis changes as the panel row number changes.</li> <li>The \\(z\\) axis is normal to the mirror surfaces.</li> </ul> <p>And the origin is at the center of the mirror surface. The mirror model in <code>mirror.mirror_surface</code> is computed in these coordinates.</p> <p>The directions of the axis relative to the mirror surface is not the same for the two mirrors, check the diagram below to see where they point.</p> <p>The \"Global\" coordinate system is defined such that:</p> <ul> <li>The \\(x\\) axis is tangent to the telescope's azimuth rotation.</li> <li>The \\(y\\) axis points towards the receiver.</li> <li>The \\(z\\) axis points in the direction that light enters the telescope.</li> </ul> <p>And the origin is set so that the origin of the \"Primary\" system lies along the \"Global\" \\(z\\) axis and the origin of the \"Secondary\" system lies along the \"Global\" \\(y\\) axis.</p> <p></p>"},{"location":"coordinate_systems/#vertex-coordinate-systems","title":"Vertex Coordinate Systems","text":"<p>The vertex coordinate systems were developed by Vertex and are used for all of there alignment purposes. If you get data from Vertex it is likely in this format.</p> <p>For \"Primary\" and \"Secondary\" the axis are defined such that:</p> <ul> <li>The \\(x\\) axis changes as the panel row number changes.</li> <li>The \\(y\\) axis changes as the panel column number changes.</li> <li>The \\(z\\) axis is normal to the mirror surfaces.</li> </ul> <p>The origins are the same as in the \"Optical\" coordinate systems. See the diagram below for the orientation of these axes.</p> <p>The \"Global\" coordinate system is defined such that:</p> <ul> <li>The \\(x\\) axis points towards the receiver.</li> <li>The \\(y\\) axis is tangent to the telescope's azimuth rotation.</li> <li>The \\(z\\) axis points out of the telescope.</li> </ul> <p>The origin is offset by 120 mm along the \"Vertex\" \\(x\\) (so the \"Optical\" \\(y\\) axis). The reason for the offset is unclear.</p> <p></p>"},{"location":"panel_numbers/","title":"Panel Numbering Scheme","text":"<p>Info</p> <p>Here we only describe the indexing and labeling of the mirror panels. For information on the optics of the mirrors please see Parshley et al.. For more information on the optics of the SO LAT  Dicker et al. and Gudmundsson et al. are useful resources as well.</p> <p>Each LAT mirror panel can be identified by a eight digit ID in the following format:</p> <pre><code>(telescope number)(mirror number)(panel row)(panel column}(panel number)\n</code></pre> <p>Where:</p> <ul> <li><code>telescope number</code> is a four digit ID for the telescope that the mirror belongs to with a hyphen between the second and third digit. The SO LAT is \\(01-01\\).</li> <li><code>mirror number</code> is \\(1\\) for the primary mirror and \\(2\\) for the secondary mirror.</li> <li><code>panel row</code> is which row of the mirror the panel is in (see diagram below).</li> <li><code>panel column</code> is which column of the mirror the panel is in (see diagram below).</li> <li><code>panel number</code> identifies which instance of the panel you have, it can change to denote the creation of a spare or replacement panel.</li> </ul> <p></p> <p>Each panel has eight adjusters:</p> <ul> <li>Two \\(x\\) adjusters (ie: moving the panel along its row) denoted as \\(H1\\) and \\(H2\\).</li> <li>One \\(y\\) adjuster (ie: moving the panel along its column) denoted as \\(H3\\).</li> <li>Five \\(z\\) adjusters (ie: to deform the panel surface) denoted as \\(V1\\) to \\(V5\\).</li> </ul> <p>The locations of these adjusters on the back of the panel can be seen below:</p> <p></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>adjustments</li> <li>alignment</li> <li>bearing</li> <li>fitting</li> <li>io</li> <li>mirror</li> <li>photogrammetry</li> <li>transforms</li> </ul>"},{"location":"reference/adjustments/","title":"adjustments","text":"<p>Calculate adjustments needed to align LAT mirror panel</p> <p>Author: Saianeesh Keshav Haridas</p>"},{"location":"reference/adjustments/#lat_alignment.adjustments.adjustment_fit_func","title":"<code>adjustment_fit_func(pars, can_points, points, adjustors)</code>","text":"<p>Function to minimize when calculating adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>pars</code> <code>NDArray[float32]</code> <p>The parameters to fit for:</p> <ul> <li>dx: Translation in x</li> <li>dy: Translation in y</li> <li>dz: Translation in z</li> <li>thetha_0: Angle to rotate about first adjustor axis</li> <li>thetha_1: Angle to rotate about second adjustor axis</li> <li>z_t: Additional translation to tension the center point</li> </ul> required <code>can_points</code> <code>NDArray[float32]</code> <p>The cannonical positions of the points to align.</p> required <code>points</code> <code>NDArray[float32]</code> <p>The measured positions of the points to align.</p> required <code>adjustors</code> <code>NDArray[float32]</code> <p>The measured positions of the adjustors.</p> required <p>Returns:</p> Name Type Description <code>norm</code> <code>float32</code> <p>The norm of \\(cannonical_positions - transformed_positions\\).</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def adjustment_fit_func(\n    pars: NDArray[np.float32],\n    can_points: NDArray[np.float32],\n    points: NDArray[np.float32],\n    adjustors: NDArray[np.float32],\n) -&gt; np.float32:\n    r\"\"\"\n    Function to minimize when calculating adjustments.\n\n    Parameters\n    ----------\n    pars : NDArray[np.float32]\n        The parameters to fit for:\n\n        * dx: Translation in x\n        * dy: Translation in y\n        * dz: Translation in z\n        * thetha_0: Angle to rotate about first adjustor axis\n        * thetha_1: Angle to rotate about second adjustor axis\n        * z_t: Additional translation to tension the center point\n    can_points : NDArray[np.float32]\n        The cannonical positions of the points to align.\n    points : NDArray[np.float32]\n        The measured positions of the points to align.\n    adjustors : NDArray[np.float32]\n        The measured positions of the adjustors.\n\n    Returns\n    -------\n    norm : np.float32\n        The norm of $cannonical_positions - transformed_positions$.\n    \"\"\"\n    dx, dy, dz, thetha_0, thetha_1, z_t = pars\n    points, adjustors = translate_panel(points, adjustors, dx, dy, dz)\n    points, adjustors = rotate_panel(points, adjustors, thetha_0, thetha_1)\n    points[-1, -1] += z_t\n    return np.linalg.norm(can_points - points)\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.calc_adjustments","title":"<code>calc_adjustments(can_points, points, adjustors, **kwargs)</code>","text":"<p>Calculate adjustments needed to align panel.</p> <p>Parameters:</p> Name Type Description Default <code>can_points</code> <code>NDArray[float32]</code> <p>The cannonical position of the points to align.</p> required <code>points</code> <code>NDArray[float32]</code> <p>The measured positions of the points to align.</p> required <code>adjustors</code> <code>NDArray[float32]</code> <p>The measured positions of the adjustors.</p> required <code>**kwargs</code> <p>Arguments to be passed to <code>scipy.optimize.minimize</code>.</p> <code>{}</code> <code>dx</code> <code>float32</code> <p>The required translation of panel in x.</p> required <code>dy</code> <code>float32</code> <p>The required translation of panel in y.</p> required <code>d_adj</code> <code>NDArray[float32]</code> <p>The amount to move each adjustor.</p> required <code>dx_err</code> <code>float32</code> <p>The error in the fit for <code>dx</code>.</p> required <code>dy_err</code> <code>float32</code> <p>The error in the fit for <code>dy</code>.</p> required <code>d_adj_err</code> <code>NDArray[float32]</code> <p>The error in the fit for <code>d_adj</code>.</p> required Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def calc_adjustments(\n    can_points: NDArray[np.float32],\n    points: NDArray[np.float32],\n    adjustors: NDArray[np.float32],\n    **kwargs,\n) -&gt; Tuple[\n    np.float32,\n    np.float32,\n    NDArray[np.float32],\n    np.float32,\n    np.float32,\n    NDArray[np.float32],\n]:\n    \"\"\"\n    Calculate adjustments needed to align panel.\n\n    Parameters\n    ----------\n    can_points : NDArray[np.float32]\n        The cannonical position of the points to align.\n    points : NDArray[np.float32]\n        The measured positions of the points to align.\n    adjustors : NDArray[np.float32]\n        The measured positions of the adjustors.\n    **kwargs\n        Arguments to be passed to `scipy.optimize.minimize`.\n\n    dx : np.float32\n        The required translation of panel in x.\n    dy : np.float32\n        The required translation of panel in y.\n    d_adj : NDArray[np.float32]\n        The amount to move each adjustor.\n    dx_err : np.float32\n        The error in the fit for `dx`.\n    dy_err : np.float32\n        The error in the fit for `dy`.\n    d_adj_err : NDArray[np.float32]\n        The error in the fit for `d_adj`.\n    \"\"\"\n    res = opt.minimize(\n        adjustment_fit_func, np.zeros(6), (can_points, points, adjustors), **kwargs\n    )\n\n    dx, dy, dz, thetha_0, thetha_1, z_t = res.x\n    _points, _adjustors = translate_panel(points, adjustors, dx, dy, dz)\n    _points, _adjustors = rotate_panel(_points, _adjustors, thetha_0, thetha_1)\n    _adjustors[-1, -1] += z_t\n    d_adj = _adjustors - adjustors\n\n    ftol = 2.220446049250313e-09\n    if \"ftol\" in kwargs:\n        ftol = kwargs[\"ftol\"]\n    perr = np.sqrt(ftol * np.diag(res.hess_inv))\n    dx_err, dy_err, dz_err, thetha_0_err, thetha_1_err, z_t_err = perr\n    _points, _adjustors = translate_panel(points, adjustors, dx_err, dy_err, dz_err)\n    _points, _adjustors = rotate_panel(_points, _adjustors, thetha_0_err, thetha_1_err)\n    _adjustors[-1, -1] += z_t_err\n    d_adj_err = _adjustors - adjustors\n\n    return dx, dy, d_adj[:, 2], dx_err, dy_err, d_adj_err[:, 2]\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.rotate","title":"<code>rotate(point, end_point1, end_point2, theta)</code>","text":"<p>Rotate a point about an axis</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>NDArray[float32]</code> <p>The point to rotate</p> required <code>end_point1</code> <code>NDArray[float32]</code> <p>A point on the axis of rotation</p> required <code>end_point2</code> <code>NDArray[float32]</code> <p>Another point on the axis of rotation</p> required <code>theta</code> <code>float32</code> <p>Angle in radians to rotate by</p> required <p>Returns:</p> Name Type Description <code>point</code> <code>NDArray[float32]</code> <p>The rotated point</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def rotate(\n    point: NDArray[np.float32],\n    end_point1: NDArray[np.float32],\n    end_point2: NDArray[np.float32],\n    theta: np.float32,\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Rotate a point about an axis\n\n    Parameters\n    ----------\n    point : NDArray[np.float32]\n        The point to rotate\n    end_point1 : NDArray[np.float32]\n        A point on the axis of rotation\n    end_point2 : NDArray[np.float32]\n        Another point on the axis of rotation\n    theta: NDArray[np.float32]\n        Angle in radians to rotate by\n\n    Returns\n    -------\n    point : NDArray[np.float32]\n        The rotated point\n    \"\"\"\n    origin = np.mean((end_point1, end_point2))\n    point_0 = point - origin\n    ax = end_point2 - end_point1\n    ax = rot.from_rotvec(theta * ax / np.linalg.norm(ax))\n    point_0 = ax.apply(point_0)\n    return point_0 + origin\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.rotate_panel","title":"<code>rotate_panel(points, adjustors, thetha_0, thetha_1)</code>","text":"<p>Rotate panel about axes created by adjustors.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[float32]</code> <p>Points on panel to rotate.</p> required <code>adjustors</code> <code>NDArray[float32]</code> <p>Adjustor positions.</p> required <code>thetha_0</code> <code>float32</code> <p>Angle to rotate about first adjustor axis</p> required <code>thetha_1</code> <code>np.float32.</code> <p>Angle to rotate about second adjustor axis</p> required <p>Returns:</p> Name Type Description <code>rot_points</code> <code>NDArray[float32]</code> <p>The rotated points.</p> <code>rot_adjustors</code> <code>NDArray[float32]</code> <p>The rotated adjustors.</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def rotate_panel(\n    points: NDArray[np.float32],\n    adjustors: NDArray[np.float32],\n    thetha_0: np.float32,\n    thetha_1: np.float32,\n) -&gt; Tuple[NDArray[np.float32], NDArray[np.float32]]:\n    \"\"\"\n    Rotate panel about axes created by adjustors.\n\n    Parameters\n    ----------\n    points : NDArray[np.float32]\n        Points on panel to rotate.\n    adjustors : NDArray[np.float32]\n        Adjustor positions.\n    thetha_0 : np.float32\n        Angle to rotate about first adjustor axis\n    thetha_1 : np.float32.\n        Angle to rotate about second adjustor axis\n\n    Returns\n    -------\n    rot_points : NDArray[np.float32]\n        The rotated points.\n    rot_adjustors : NDArray[np.float32]\n        The rotated adjustors.\n    \"\"\"\n    rot_points = np.zeros(points.shape, np.float32)\n    rot_adjustors = np.zeros(adjustors.shape, np.float32)\n\n    n_points = len(points)\n    n_adjustors = len(adjustors)\n\n    for i in range(n_points):\n        rot_points[i] = rotate(points[i], adjustors[1], adjustors[2], thetha_0)\n        rot_points[i] = rotate(rot_points[i], adjustors[0], adjustors[3], thetha_1)\n    for i in range(n_adjustors):\n        rot_adjustors[i] = rotate(adjustors[i], adjustors[1], adjustors[2], thetha_0)\n        rot_adjustors[i] = rotate(\n            rot_adjustors[i], adjustors[0], adjustors[3], thetha_1\n        )\n    return rot_points, rot_adjustors\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.translate_panel","title":"<code>translate_panel(points, adjustors, dx, dy, dz)</code>","text":"<p>Translate a panel.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[float32]</code> <p>The points on panel to translate.</p> required <code>adjustors</code> <code>NDArray[float32]</code> <p>Adjustor positions.</p> required <code>dx</code> <code>float32</code> <p>Translation in x.</p> required <code>dy</code> <code>float32</code> <p>Translation in y.</p> required <code>dz</code> <code>float32</code> <p>Translation in z.</p> required <p>Returns:</p> Name Type Description <code>points</code> <code>NDArray[float32]</code> <p>The translated points.</p> <code>adjustors</code> <code>NDArray[float32]</code> <p>The translated adjustors.</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def translate_panel(\n    points: NDArray[np.float32],\n    adjustors: NDArray[np.float32],\n    dx: np.float32,\n    dy: np.float32,\n    dz: np.float32,\n) -&gt; Tuple[NDArray[np.float32], NDArray[np.float32]]:\n    \"\"\"\n    Translate a panel.\n\n    Parameters\n    ----------\n    points : NDArray[np.float32]\n        The points on panel to translate.\n    adjustors : NDArray[np.float32]\n        Adjustor positions.\n    dx : np.float32\n        Translation in x.\n    dy : np.float32\n        Translation in y.\n    dz : np.float32\n        Translation in z.\n\n    Returns\n    -------\n    points : NDArray[np.float32]\n        The translated points.\n    adjustors : NDArray[np.float32]\n        The translated adjustors.\n    \"\"\"\n    translation = np.array((dx, dy, dz))\n    return points + translation, adjustors + translation\n</code></pre>"},{"location":"reference/alignment/","title":"alignment","text":"<p>Main driver script for running the alignment. You typically want to use the <code>lat_alignment</code> entrypoint rather than calling this directly.</p>"},{"location":"reference/alignment/#lat_alignment.alignment.adjust_panel","title":"<code>adjust_panel(panel, mnum, cfg)</code>","text":"<p>Helper function to get the adjustments for a single panel.</p> <p>Parameters:</p> Name Type Description Default <code>panel</code> <code>Panel</code> <p>The mirror panel to adjust.</p> required <code>mnum</code> <code>int</code> <p>The mirror number. 1 for the primary and 2 for the secondary.</p> required <code>cfg</code> <code>dict</code> <p>The configuration dictionairy.</p> required <p>Returns:</p> Name Type Description <code>adjustments</code> <code>NDArray[float32]</code> <p>The adjustments to make for the panel. This is a 17 element array with the following structure: <code>[mnum, panel_row, panel_col, dx, dy, d_adj1, ..., d_adj5, dx_err, dy_err, d_adj1_err, ..., d_adj5_err]</code>.</p> Source code in <code>lat_alignment/alignment.py</code> <pre><code>def adjust_panel(panel: mir.Panel, mnum: int, cfg: dict) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Helper function to get the adjustments for a single panel.\n\n    Parameters\n    ----------\n    panel : mir.Panel\n        The mirror panel to adjust.\n    mnum : int\n        The mirror number.\n        1 for the primary and 2 for the secondary.\n    cfg : dict\n        The configuration dictionairy.\n\n    Returns\n    -------\n    adjustments : NDArray[np.float32]\n        The adjustments to make for the panel.\n        This is a 17 element array with the following structure:\n        `[mnum, panel_row, panel_col, dx, dy, d_adj1, ..., d_adj5, dx_err, dy_err, d_adj1_err, ..., d_adj5_err]`.\n    \"\"\"\n    adjustments = np.zeros(17, np.float32)\n    adjustments[0] = mnum\n    adjustments[1] = panel.row\n    adjustments[2] = panel.col\n    meas_adj = panel.meas_adj.copy()\n    meas_adj[:, 2] += panel.meas_adj_resid\n    meas_surface = panel.meas_surface.copy()\n    meas_surface[:, 2] += panel.meas_adj_resid\n    dx, dy, d_adj, dx_err, dy_err, d_adj_err = adj.calc_adjustments(\n        panel.can_surface, meas_surface, meas_adj, **cfg.get(\"adjust\", {})\n    )\n    # The primary has x and z opposite to what is intuitive\n    if mnum == 1:\n        dx *= -1\n        d_adj *= -1\n    adjustments[3:] = np.array(\n        [dx, dy] + list(d_adj) + [dx_err, dy_err] + list(d_adj_err)\n    )\n\n    return adjustments\n</code></pre>"},{"location":"reference/bearing/","title":"bearing","text":"<p>Module for fitting for the bearing location. Needs to be made less hardcoded...</p>"},{"location":"reference/bearing/#lat_alignment.bearing.cylinder_fit","title":"<code>cylinder_fit(dataset)</code>","text":"<p>Fit for the bearing's position by fitting a cylinder to the bearing surface. This acts as a correction on top of the alignment to reference points.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>Photogrammetry dataset. Should already be aligned to the bearing referance points.</p> required <p>Returns:</p> Name Type Description <code>inside_points</code> <code>Dataset</code> <p>Points on the inner surface of the bearing with alignment applied. Only includes targets, codes are removed.</p> <code>alignment</code> <code>tuple[NDArray[float32], NDArray[float32]]</code> <p>The transformation that aligned the bearing. The first element is a rotation matrix and the second is the shift.</p> Source code in <code>lat_alignment/bearing.py</code> <pre><code>def cylinder_fit(\n    dataset: Dataset,\n) -&gt; tuple[Dataset, tuple[NDArray[np.float32], NDArray[np.float32]]]:\n    \"\"\"\n    Fit for the bearing's position by fitting a cylinder to the bearing surface.\n    This acts as a correction on top of the alignment to reference points.\n\n    Parameters\n    ----------\n    dataset : Dataset\n        Photogrammetry dataset.\n        Should already be aligned to the bearing referance points.\n\n    Returns\n    -------\n    inside_points : Dataset\n        Points on the inner surface of the bearing with alignment applied.\n        Only includes targets, codes are removed.\n    alignment : tuple[NDArray[np.float32], NDArray[np.float32]]\n        The transformation that aligned the bearing.\n        The first element is a rotation matrix and\n        the second is the shift.\n    \"\"\"\n    # Partition points\n    logger.info(\"\\tStarting fit of bearing axis\")\n    inside_points, face_points, zero_point, zero_coded = partition_points(dataset)\n    logger.info(\"\\t\\tFound %d points on bearing surface\", len(inside_points))\n    logger.debug(\"\\t\\tZero point is at %s\", str(zero_point))\n\n    # Fit inside of bearing\n    w, c, *_ = cf.fit(inside_points.points)\n    center_line = Line(point=c, direction=w)\n\n    # Fit face of bearing\n    face_plane = Plane.best_fit(face_points.points)\n    origin = face_plane.intersect_line(center_line)\n    shift = ORIGIN - origin\n\n    # Get our basis\n    axis1 = Vector.from_points(origin + shift, center_line.point + shift).unit()\n    axis2 = Vector.from_points(origin + shift, zero_point + shift).unit()\n    axis2_coded = Vector.from_points(origin + shift, zero_coded + shift).unit()\n\n    # Get the transform that aligns us\n    rot, err, *_ = R.align_vectors(\n        np.vstack((axis1, axis2, axis2_coded)), np.vstack((AXIS1, AXIS2, AXIS2_CODED))\n    )\n    logger.info(\"\\t\\tError on bearing axis alignment: %f\", err)\n\n    shift = rot.apply(shift)\n    rot = np.array(rot.as_matrix(), dtype=np.float32).T\n    logger.debug(\"\\t\\tShift is %s mm\", str(shift))\n    logger.debug(\"\\t\\tRotation is %s deg\", str(np.rad2deg(decompose_rotation(rot))))\n\n    coords_transformed = apply_transform(inside_points.points, rot, shift)\n    data = {\n        label: coord for label, coord in zip(inside_points.labels, coords_transformed)\n    }\n\n    return Dataset(data), (rot, shift)\n</code></pre>"},{"location":"reference/bearing/#lat_alignment.bearing.partition_points","title":"<code>partition_points(dataset)</code>","text":"<p>Split up dataset into points on the bearing reference surface and inner surface. Also pulls out the bearing zero points.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>Photogrammetry dataset. Should already be aligned to the bearing referance points.</p> required <p>Returns:</p> Name Type Description <code>inside_points</code> <code>Dataset</code> <p>Points on the inner surface of the bearing. Only includes targets, codes are removed.</p> <code>face_points</code> <code>Dataset</code> <p>Points on face of the bearing that we use as a reference surface. Only includes targets, codes are removed.</p> <code>zero_point</code> <code>NDArray[float32]</code> <p>Array of size (3,) that gives the coordinates of the target we treat as the bearing's zero point.</p> <code>zero_code</code> <code>NDArray[float32]</code> <p>Array of size (3,) that gives the coordinates of the coded target we use to identify the bearing's zero point.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the zero point of the bearing is not found or there are less than four points found on the inner surface or face fo the bearing.</p> Source code in <code>lat_alignment/bearing.py</code> <pre><code>def partition_points(\n    dataset: Dataset,\n) -&gt; tuple[Dataset, Dataset, NDArray[np.float32], NDArray[np.float32]]:\n    \"\"\"\n    Split up dataset into points on the bearing reference surface and inner surface.\n    Also pulls out the bearing zero points.\n\n    Parameters\n    ----------\n    dataset : Dataset\n        Photogrammetry dataset.\n        Should already be aligned to the bearing referance points.\n\n    Returns\n    -------\n    inside_points : Dataset\n        Points on the inner surface of the bearing.\n        Only includes targets, codes are removed.\n    face_points : Dataset\n        Points on face of the bearing that we use as a reference surface.\n        Only includes targets, codes are removed.\n    zero_point : NDArray[np.float32]\n        Array of size (3,) that gives the coordinates of the target we treat\n        as the bearing's zero point.\n    zero_code: NDArray[np.float32]\n        Array of size (3,) that gives the coordinates of the coded target we use\n        to identify the bearing's zero point.\n\n    Raises\n    ------\n    ValueError\n        When the zero point of the bearing is not found or there are less than four\n        points found on the inner surface or face fo the bearing.\n    \"\"\"\n    if ZERO_CODE not in dataset.code_labels:\n        raise ValueError(\"Can't find zero point of bearing! Coded target not found!\")\n    zero_coded = dataset[ZERO_CODE]\n    dist = np.linalg.norm(dataset.targets - zero_coded, axis=-1)\n    zero_point = dataset.targets[np.argmin(dist)]\n    if np.min(dist) &gt; 100:\n        raise ValueError(\"Can't find zero point of bearing!\")\n\n    inside_msk = (dataset.targets[:, 1] &gt; ORIGIN[1] - 100) * (\n        dataset.targets[:, 1] &lt; ORIGIN[1] - 10\n    )\n    inside_points = Dataset(\n        {\n            l: p\n            for l, p in zip(\n                dataset.target_labels[inside_msk], dataset.targets[inside_msk]\n            )\n        }\n    )\n    if len(inside_points) &lt; 4:\n        raise ValueError(\"Not enough points on inner bearing surface found!\")\n\n    face_origin = np.mean(\n        np.vstack(\n            [\n                dataset[label]\n                for label in [\"CODE91\", \"CODE92\", \"CODE93\", \"CODE94\"]\n                if label in dataset\n            ]\n        ),\n        axis=0,\n    )\n    face_msk = (dataset.points[:, 1] &gt; face_origin[1] - 0.5) * (\n        dataset.points[:, 1] &lt; face_origin[1] + 0.5\n    )\n    face_points = Dataset(\n        {l: p for l, p in zip(dataset.labels[face_msk], dataset.points[face_msk])}\n    )\n    if len(face_points) &lt; 4:\n        raise ValueError(\"Not enough points on bearing face surface found!\")\n\n    return inside_points, face_points, zero_point, zero_coded\n</code></pre>"},{"location":"reference/fitting/","title":"fitting","text":"<p>Functions for fitting against the mirror surface.</p>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_fit","title":"<code>mirror_fit(points, a, compensate=0, to_points=True, **kwargs)</code>","text":"<p>Fit points against the mirror surface. Ideally the points should be in the mirror's local coordinate system.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[floating]</code> <p>Array of points to compare against the mirror. Should have shape (npoint, 3).</p> required <code>a</code> <code>NDArray[floating]</code> <p>Coeffecients of the mirror function. Use a_primary for the primary mirror and a_secondary for the secondary.</p> required <code>compensate</code> <code>float</code> <p>Amount to compensate the mirror surface by. This is useful to model things like the surface traced out by an SMR.</p> <code>0.0</code> <code>to_points</code> <code>bool</code> <p>If True, the transform will be inverted to align the model to the points.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments to pass on to scipy.optimize.minimize.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>transform_pars</code> <code>NDArray[floating]</code> <p>Flattened affine transform and shift, has to be 1d for use with minimizers. Will have shape (12,) where the first 9 elements are the flattened affine transform, and the last 3 are the shift in (x, y, z) applied after the affine transform.</p> <code>rms</code> <code>float</code> <p>The RMS error between the transformed points and the model.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_fit(\n    points: NDArray[np.floating],\n    a: NDArray[np.floating],\n    compensate: float = 0,\n    to_points: bool = True,\n    **kwargs,\n) -&gt; tuple[NDArray[np.floating], float]:\n    \"\"\"\n    Fit points against the mirror surface.\n    Ideally the points should be in the mirror's local coordinate system.\n\n    Parameters\n    ----------\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n    a : NDArray[np.floating]\n        Coeffecients of the mirror function.\n        Use a_primary for the primary mirror and a_secondary for the secondary.\n    compensate : float, default: 0.0\n        Amount to compensate the mirror surface by.\n        This is useful to model things like the surface traced out by an SMR.\n    to_points : bool, default: True\n        If True, the transform will be inverted to align the model to the points.\n    **kwargs\n        Additional arguments to pass on to scipy.optimize.minimize.\n\n    Returns\n    -------\n    transform_pars : NDArray[np.floating]\n        Flattened affine transform and shift, has to be 1d for use with minimizers.\n        Will have shape (12,) where the first 9 elements are the flattened affine transform,\n        and the last 3 are the shift in (x, y, z) applied after the affine transform.\n    rms : float\n        The RMS error between the transformed points and the model.\n    \"\"\"\n\n    def _fit_func(transform_pars, points, a, compensate):\n        points_transformed = mirror_transform(transform_pars, points)\n        chisq = mirror_objective(points_transformed, a, compensate)\n        return chisq\n\n    x0 = np.concatenate((np.eye(3).ravel(), np.zeros(3)))\n    res = opt.minimize(_fit_func, x0, args=(points, a, compensate), **kwargs)\n\n    transform_pars = res.x\n    transformed = mirror_transform(transform_pars, points)\n    z = mr.mirror(transformed[:, 0], transformed[:, 1], a, compensate)\n    rms = np.sqrt(np.mean((z - transformed[:, 2]) ** 2))\n\n    if to_points:\n        aff = transform_pars[:9].reshape((3, 3))\n        sft = transform_pars[9:]\n        aff = np.linalg.inv(aff)\n        sft = (-1 * sft) @ aff\n        transform_pars = np.concatenate((aff.ravel(), sft))\n\n    return transform_pars, rms\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_objective","title":"<code>mirror_objective(points, a, compensate=0)</code>","text":"<p>Objective function to minimize when fitting to mirror surface. Essentially just a curvature weighted chisq.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[floating]</code> <p>Array of points to compare against the mirror. Should have shape (npoint, 3).</p> required <code>a</code> <code>NDArray[floating]</code> <p>Coeffecients of the mirror function. Use a_primary for the primary mirror and a_secondary for the secondary.</p> required <code>compensate</code> <code>float</code> <p>Amount to compensate the mirror surface by. This is useful to model things like the surface traced out by an SMR.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>chisq</code> <code>float</code> <p>The value to minimize when fitting to.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_objective(\n    points: NDArray[np.floating], a: NDArray[np.floating], compensate: float = 0\n) -&gt; float:\n    \"\"\"\n    Objective function to minimize when fitting to mirror surface.\n    Essentially just a curvature weighted chisq.\n\n    Parameters\n    ----------\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n    a : NDArray[np.floating]\n        Coeffecients of the mirror function.\n        Use a_primary for the primary mirror and a_secondary for the secondary.\n    compensate : float, default: 0.0\n        Amount to compensate the mirror surface by.\n        This is useful to model things like the surface traced out by an SMR.\n\n    Returns\n    -------\n    chisq : float\n        The value to minimize when fitting to.\n    \"\"\"\n    surface = mr.mirror(points[:, 0], points[:, 1], a, compensate)\n    norm = mr.mirror_norm(points[:, 0], points[:, 1], a)\n    res = (points[:, 2] - surface) * (norm[2] ** 2)\n\n    return res @ res.T\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_transform","title":"<code>mirror_transform(transform_pars, points)</code>","text":"<p>Function to apply an affine transform to the mirror. This is the transform we are fitting for.</p> <p>Parameters:</p> Name Type Description Default <code>transform_pars</code> <code>NDArray[floating]</code> <p>Flattened affine transform and shift, has to be 1d for use with minimizers. Should have shape (12,) where the first 9 elements are the flattened affine transform, and the last 3 are the shift in (x, y, z) applied after the affine transform.</p> required <code>points</code> <code>NDArray[floating]</code> <p>Array of points to compare against the mirror. Should have shape (npoint, 3).</p> required <p>Returns:</p> Name Type Description <code>points_transformed</code> <code>NDArray[floating]</code> <p>Array of transformed points. Will have shape (npoint, 3).</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_transform(\n    transform_pars: NDArray[np.floating], points: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Function to apply an affine transform to the mirror.\n    This is the transform we are fitting for.\n\n    Parameters\n    ----------\n    transform_pars : NDArray[np.floating]\n        Flattened affine transform and shift, has to be 1d for use with minimizers.\n        Should have shape (12,) where the first 9 elements are the flattened affine transform,\n        and the last 3 are the shift in (x, y, z) applied after the affine transform.\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n\n    Returns\n    -------\n    points_transformed : NDArray[np.floating]\n        Array of transformed points.\n        Will have shape (npoint, 3).\n    \"\"\"\n    aff = transform_pars[:9].reshape((3, 3))\n    sft = transform_pars[9:]\n    return points @ aff + sft\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.res_auto_corr","title":"<code>res_auto_corr(residuals)</code>","text":"<p>Compute auto correlation of residuals from fit.</p> <p>Parameters:</p> Name Type Description Default <code>residuals</code> <code>NDArray[floating]</code> <p>Residuals between measured point cloud and fit model.</p> required <p>Returns:</p> Name Type Description <code>ac</code> <code>NDArray[floating]</code> <p>Auto correlation, really just the deviations in mm at each distance scale.</p> <code>ac_dists</code> <code>NDArray[floating]</code> <p>Distance scale of each value in ac.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def res_auto_corr(\n    residuals: NDArray[np.floating],\n) -&gt; tuple[NDArray[np.floating], NDArray[np.floating]]:\n    \"\"\"\n    Compute auto correlation of residuals from fit.\n\n    Parameters\n    ----------\n    residuals : NDArray[np.floating]\n        Residuals between measured point cloud and fit model.\n\n    Returns\n    -------\n    ac : NDArray[np.floating]\n        Auto correlation, really just the deviations in mm at each distance scale.\n    ac_dists : NDArray[np.floating]\n        Distance scale of each value in ac.\n    \"\"\"\n    dists = np.zeros((len(residuals), len(residuals)))\n    res_diff = np.zeros((len(residuals), len(residuals)))\n\n    for i in range(len(residuals)):\n        res1 = residuals[i]\n        for j in range(i):\n            res2 = residuals[j]\n            dist = np.linalg.norm((res1[0] - res2[0], res1[1] - res2[1]))\n            dists[i, j] = dist\n            res_diff[i, j] = abs(res1[2] - res2[2])\n    tri_i = np.tril_indices(len(residuals), k=-1)\n    dists = dists[tri_i]\n    res_diff = res_diff[tri_i]\n    ac, bin_e, _ = binned_statistic(dists, res_diff, bins=100)\n    ac_dists = bin_e[:-1] + np.diff(bin_e) / 2.0\n\n    return ac, ac_dists\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.tension_fit","title":"<code>tension_fit(residuals, **kwargs)</code>","text":"<p>Fit a power law model of tension to a point cloud of residuals.</p> <p>Parameters:</p> Name Type Description Default <code>residuals</code> <code>NDArray[floating]</code> <p>Residuals between measured point cloud and fit model.</p> required <code>**kwargs</code> <p>Arguments to be passed to scipy.optimize.minimize</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tension_pars</code> <code>NDArray[floating]</code> <p>The fit parameters, see docstring of tension_model for details.</p> <code>rms</code> <code>float</code> <p>The rms between the input residuals and the fit model.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def tension_fit(\n    residuals: NDArray[np.floating], **kwargs\n) -&gt; tuple[NDArray[np.floating], float]:\n    \"\"\"\n    Fit a power law model of tension to a point cloud of residuals.\n\n    Parameters\n    ----------\n    residuals : NDArray[np.floating]\n        Residuals between measured point cloud and fit model.\n    **kwargs\n        Arguments to be passed to scipy.optimize.minimize\n\n    Returns\n    -------\n    tension_pars : NDArray[np.floating]\n        The fit parameters, see docstring of tension_model for details.\n    rms : float\n        The rms between the input residuals and the fit model.\n    \"\"\"\n\n    def min_func(pars, residuals):\n        _z = tension_model(*pars[:5], residuals)\n        return np.sqrt(np.mean((residuals[:, 2] - _z) ** 2))\n\n    if \"bounds\" not in kwargs:\n        ptp = np.ptp(residuals[:, 2])\n        bounds = [\n            (np.min(residuals[:, 0]), np.max(residuals[:, 0])),\n            (np.min(residuals[:, 1]), np.max(residuals[:, 1])),\n            (-1 * ptp, ptp),\n            (1e-10, np.inf),\n            (0, np.inf),\n        ]\n        kwargs[\"bounds\"] = bounds\n    x0 = [np.mean(residuals[:, 0]), np.mean(residuals[:, 1]), 0, 1, 0]\n    res = opt.minimize(min_func, x0, (residuals,), **kwargs)\n    return res.x, res.fun\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.tension_model","title":"<code>tension_model(x0, y0, t, a, b, points)</code>","text":"<p>Function to model incorrect panel tensioning. Currently the model used is a radial power law.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>float</code> <p>Center of the power law in x.</p> required <code>y0</code> <code>float</code> <p>Center of the power law in y.</p> required <code>t</code> <code>float.</code> <p>Amplitude of power law, nominally the offset due to tensioning in the center of panel.</p> required <code>a</code> <code>float</code> <p>Base of power law.</p> required <code>b</code> <code>float</code> <p>Exponential scale factor of power law</p> required <code>points</code> <code>NDArray[floating]</code> <p>Points to compute power law at. Only the x and y coordinates are used (first two collumns). So should be (npoint, 2) but (npoint, ndim&gt;2) is also fine.</p> required <p>Returns:</p> Name Type Description <code>z</code> <code>NDArray[floating]</code> <p>Power law model at each xy. Will have shape (npoint,).</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def tension_model(\n    x0: float, y0: float, t: float, a: float, b: float, points: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Function to model incorrect panel tensioning.\n    Currently the model used is a radial power law.\n\n\n    Parameters\n    ----------\n    x0 : float\n        Center of the power law in x.\n    y0 : float\n        Center of the power law in y.\n    t : float.\n        Amplitude of power law,\n        nominally the offset due to tensioning in the center of panel.\n    a : float\n        Base of power law.\n    b : float\n        Exponential scale factor of power law\n    points : NDArray[np.floating]\n        Points to compute power law at.\n        Only the x and y coordinates are used (first two collumns).\n        So should be (npoint, 2) but (npoint, ndim&gt;2) is also fine.\n\n    Returns\n    -------\n    z : NDArray[np.floating]\n        Power law model at each xy.\n        Will have shape (npoint,).\n    \"\"\"\n    # Avoid divide by 0 error\n    if a == 0:\n        return np.zeros(len(points))\n\n    # Compute radius at each point\n    r = np.sqrt((points[:, 0] - x0) ** 2 + (points[:, 1] - y0) ** 2)\n\n    # Return power law\n    return t * (a ** (-b * r))\n</code></pre>"},{"location":"reference/io/","title":"io","text":""},{"location":"reference/io/#lat_alignment.io.load_adjusters","title":"<code>load_adjusters(path, mirror)</code>","text":"<p>Get nominal adjuster locations from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the data file.</p> required <code>mirror</code> <code>str</code> <p>The mirror that these points belong to. Should be either: 'primary' or 'secondary'.</p> <code>'primary'</code> <p>Returns:</p> Name Type Description <code>adjusters</code> <code>dict[tuple[int, int], NDArray[float32]]</code> <p>Nominal adjuster locations. This is indexed by a (row, col) tuple. Each entry is <code>(5, 3)</code> array where each row is an adjuster.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_adjusters(\n    path: str, mirror: str\n) -&gt; dict[tuple[int, int], NDArray[np.float32]]:\n    \"\"\"\n    Get nominal adjuster locations from file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the data file.\n    mirror : str, default: 'primary'\n        The mirror that these points belong to.\n        Should be either: 'primary' or 'secondary'.\n\n    Returns\n    -------\n    adjusters : dict[tuple[int, int], NDArray[np.float32]]\n        Nominal adjuster locations.\n        This is indexed by a (row, col) tuple.\n        Each entry is `(5, 3)` array where each row is an adjuster.\n    \"\"\"\n    if mirror not in [\"primary\", \"secondary\"]:\n        raise ValueError(f\"Invalid mirror: {mirror}\")\n\n    def _transform(coords):\n        coords = np.atleast_2d(coords)\n        coords -= np.array([120, 0, 0])  # cancel out shift\n        return coord_transform(coords, \"va_global\", f\"opt_{mirror}\")\n\n    # TODO: cleaner transform call\n    adjusters = defaultdict(list)\n    c_points = np.genfromtxt(path, dtype=str)\n    for point in c_points:\n        row = point[0][6]\n        col = point[0][7]\n        adjusters[(row, col)] += [_transform(np.array(point[2:], dtype=np.float32))[0]]\n    adjusters = {rc: np.vstack(pts) for rc, pts in adjusters.items()}\n\n    return adjusters\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_corners","title":"<code>load_corners(path)</code>","text":"<p>Get panel corners from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the data file.</p> required <p>Returns:</p> Name Type Description <code>corners</code> <code>dict[tuple[int, int], ndarray[float32]]</code> <p>The corners. This is indexed by a (row, col) tuple. Each entry is <code>(4, 3)</code> array where each row is a corner.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_corners(path: str) -&gt; dict[tuple[int, int], NDArray[np.float32]]:\n    \"\"\"\n    Get panel corners from file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the data file.\n\n    Returns\n    -------\n    corners : dict[tuple[int, int], ndarray[np.float32]]\n        The corners. This is indexed by a (row, col) tuple.\n        Each entry is `(4, 3)` array where each row is a corner.\n    \"\"\"\n    with open(path) as file:\n        corners_raw = yaml.safe_load(file)\n\n    corners = {\n        (panel[7], panel[9]): np.vstack(\n            [np.array(coord.split(), np.float32) for coord in coords]\n        )\n        for panel, coords in corners_raw.items()\n    }\n    return corners\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_photo","title":"<code>load_photo(path, err_thresh=2, doubles_dist=10, plot=True)</code>","text":"<p>Load photogrammetry data. Assuming first column is target names and next three are (x, y , z).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the photogrammetry data.</p> required <code>err_thresh</code> <code>float</code> <p>How many times the median photogrammetry error a target need to have to be cut.</p> <code>2</code> <code>plot</code> <code>bool</code> <p>If True display a scatter plot of targets.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>data</code> <code>Dataset</code> <p>The photogrammetry data.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_photo(\n    path: str, err_thresh: float = 2, doubles_dist: float = 10, plot: bool = True\n) -&gt; Dataset:\n    \"\"\"\n    Load photogrammetry data.\n    Assuming first column is target names and next three are (x, y , z).\n\n    Parameters\n    ----------\n    path : str\n        The path to the photogrammetry data.\n    err_thresh : float, default: 2\n        How many times the median photogrammetry error\n        a target need to have to be cut.\n    plot: bool, default: True\n        If True display a scatter plot of targets.\n\n    Returns\n    -------\n    data : Dataset\n        The photogrammetry data.\n    \"\"\"\n    logger.info(\"Loading measurement data\")\n    labels = np.genfromtxt(path, dtype=str, delimiter=\",\", usecols=(0,))\n    coords = np.genfromtxt(path, dtype=np.float32, delimiter=\",\", usecols=(1, 2, 3))\n    errs = np.genfromtxt(path, dtype=np.float32, delimiter=\",\", usecols=(4, 5, 6))\n    msk = (np.char.find(labels, \"TARGET\") &gt;= 0) + (np.char.find(labels, \"CODE\") &gt;= 0)\n\n    labels, coords, errs = labels[msk], coords[msk], errs[msk]\n    err = np.linalg.norm(errs, axis=-1)\n    trg_msk = np.char.find(labels, \"TARGET\") &gt;= 0\n    code_msk = np.char.find(labels, \"CODE\") &gt;= 0\n\n    err_msk = (err &lt; err_thresh * np.median(err[trg_msk])) + code_msk\n    labels, coords, err = labels[err_msk], coords[err_msk], err[err_msk]\n    logger.info(\"\\t%d good points loaded\", len(coords))\n    logger.info(\"\\t%d high error points not loaded\", np.sum(~err_msk))\n\n    # Lets find and remove doubles\n    # Dumb brute force\n    trg_msk = np.char.find(labels, \"TARGET\") &gt;= 0\n    edm = make_edm(coords[trg_msk, :2])\n    np.fill_diagonal(edm, np.nan)\n    to_kill = []\n    for i in range(len(edm)):\n        if labels[trg_msk][i] in to_kill:\n            continue\n        imin = np.nanargmin(edm[i])\n        if edm[i][imin] &gt; doubles_dist:\n            continue\n        if err[trg_msk][i] &lt; err[trg_msk][imin]:\n            to_kill += [labels[trg_msk][imin]]\n        else:\n            to_kill += [labels[trg_msk][i]]\n    msk = ~np.isin(labels, to_kill)\n    logger.info(\"\\tFound and removed %d doubles\", len(to_kill))\n    labels, coords = labels[msk], coords[msk]\n\n    if plot:\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=\"3d\")\n        ax.scatter(coords[:, 0], coords[:, 1], coords[:, 2], marker=\"x\")\n        plt.show()\n\n    data = {label: coord for label, coord in zip(labels, coords)}\n    return Dataset(data)\n</code></pre>"},{"location":"reference/mirror/","title":"mirror","text":"<p>Functions to describe the mirror surface.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel","title":"<code>Panel</code>  <code>dataclass</code>","text":"<p>Dataclass for storing a mirror panel.</p> <p>Attributes:</p> Name Type Description <code>mirror</code> <code>str</code> <p>Which mirror this panel is for. Should be 'primary' or 'secondary'.</p> <code>row</code> <code>int</code> <p>The row of the panel.</p> <code>col</code> <code>int</code> <p>The column of the panel.</p> <code>corners</code> <code>NDArray[float32]</code> <p>Array of panel corners. Should have shape <code>(4, 3)</code>.</p> <code>measurements</code> <code>NDArray[float32]</code> <p>The measurement data for this panel. Should be in the mirror's internal coords. Should have shape <code>(npoint, 3)</code>.</p> <code>nom_adj</code> <code>NDArray[float32]</code> <p>The nominal position of the adjusters in the mirror internal coordinates. Should have shape <code>(5, 3)</code>.</p> <code>compensate</code> <code>float, default: 0</code> <p>The amount (in mm) to compensate the model surface by. This is to account for things like the Faro SMR.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>@dataclass\nclass Panel:\n    \"\"\"\n    Dataclass for storing a mirror panel.\n\n    Attributes\n    ----------\n    mirror : str\n        Which mirror this panel is for.\n        Should be 'primary' or 'secondary'.\n    row : int\n        The row of the panel.\n    col : int\n        The column of the panel.\n    corners : NDArray[np.float32]\n        Array of panel corners.\n        Should have shape `(4, 3)`.\n    measurements : NDArray[np.float32]\n        The measurement data for this panel.\n        Should be in the mirror's internal coords.\n        Should have shape `(npoint, 3)`.\n    nom_adj : NDArray[np.float32]\n        The nominal position of the adjusters in the mirror internal coordinates.\n        Should have shape `(5, 3)`.\n    compensate : float, default: 0\n        The amount (in mm) to compensate the model surface by.\n        This is to account for things like the Faro SMR.\n    \"\"\"\n\n    mirror: str\n    row: int\n    col: int\n    corners: NDArray[np.float32]\n    measurements: NDArray[np.float32]\n    nom_adj: NDArray[np.float32]\n    compensate: float = field(default=0.0)\n    adjuster_radius: float = field(default=50.0)\n\n    def __post_init__(self):\n        self.measurements = np.atleast_2d(self.measurements)\n\n    def __setattr__(self, name, value):\n        if (\n            name == \"nom_adj\"\n            or name == \"mirror\"\n            or name == \"measurements\"\n            or name == \"compensate\"\n        ):\n            self.__dict__.pop(\"can_surface\", None)\n            self.__dict__.pop(\"model\", None)\n            self.__dict__.pop(\"residuals\", None)\n            self.__dict__.pop(\"transformed_residuals\", None)\n            self.__dict__.pop(\"res_norm\", None)\n            self.__dict__.pop(\"rms\", None)\n            self.__dict__.pop(\"meas_surface\", None)\n            self.__dict__.pop(\"meas_adj\", None)\n            self.__dict__.pop(\"meas_adj_resid\", None)\n            self.__dict__.pop(\"model_transformed\", None)\n            self.__dict__.pop(\"_transform\", None)\n        elif name == \"adjuster_radius\":\n            self.__dict__.pop(\"meas_adj_resid\", None)\n        return super().__setattr__(name, value)\n\n    @cached_property\n    def model(self):\n        \"\"\"\n        The modeled mirror surface at the locations of the measurementss.\n        \"\"\"\n        model = self.measurements.copy()\n        model[:, 2] = mirror_surface(model[:, 0], model[:, 1], a[self.mirror])\n        if self.compensate != 0.0:\n            compensation = self.compensate * mirror_norm(\n                model[:, 0], model[:0], a[self.mirror]\n            )\n            model += compensation\n        return model\n\n    @cached_property\n    def _transform(self):\n        return get_rigid(self.model, self.measurements, center_dst=True, method=\"mean\")\n\n    @property\n    def rot(self):\n        \"\"\"\n        Rotation that aligns the model to the measurements.\n        \"\"\"\n        return self._transform[0]\n\n    @property\n    def shift(self):\n        \"\"\"\n        Shift that aligns the model to the measurements.\n        \"\"\"\n        return self._transform[1]\n\n    @cached_property\n    def can_surface(self):\n        \"\"\"\n        Get the cannonical points to define the panel surface.\n        These are the adjuster positions projected only the mirror surface.\n        Note that this is in the nominal coordinates not the measured ones.\n        \"\"\"\n        can_z = mirror_surface(self.nom_adj[:, 0], self.nom_adj[:, 1], a[self.mirror])\n        points = self.nom_adj.copy()\n        points[:, 2] = can_z\n        return points\n\n    @cached_property\n    def meas_surface(self):\n        \"\"\"\n        The cannonical surface transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.can_surface, self.rot, self.shift)\n\n    @cached_property\n    def meas_adj(self):\n        \"\"\"\n        The adjuster points transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.nom_adj, self.rot, self.shift)\n\n    @cached_property\n    def meas_adj_resid(self):\n        \"\"\"\n        A correction that can be applied to `meas_adj` where we compute\n        the average residual of measured points from the transformed model\n        that are within `adjuster_radius` of the adjuster point in `xy`.\n        \"\"\"\n        resid = np.zeros(len(self.meas_adj))\n        for i, adj in enumerate(self.meas_adj):\n            dists = np.linalg.norm(self.measurements[:, :2] - adj[:2], axis=-1)\n            msk = dists &lt;= self.adjuster_radius\n            if np.sum(msk) == 0:\n                continue\n            resid[i] = np.mean(self.transformed_residuals[msk, 2])\n\n        return resid\n\n    @cached_property\n    def model_transformed(self):\n        \"\"\"\n        The model transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.model, self.rot, self.shift)\n\n    @cached_property\n    def residuals(self):\n        \"\"\"\n        Get residuals between model and measurements.\n        \"\"\"\n        return self.measurements - self.model\n\n    @cached_property\n    def transformed_residuals(self):\n        \"\"\"\n        Get residuals between transformed model and measurements.\n        \"\"\"\n        return self.measurements - self.model_transformed\n\n    @cached_property\n    def res_norm(self):\n        \"\"\"\n        Get norm of residuals between transformed model and measurements.\n        \"\"\"\n        return np.linalg.norm(self.residuals, axis=-1)\n\n    @cached_property\n    def rms(self):\n        \"\"\"\n        Get rms between model and measurements.\n        \"\"\"\n        return np.sqrt(np.mean(self.residuals[:, 2].ravel() ** 2))\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.can_surface","title":"<code>can_surface</code>  <code>cached</code> <code>property</code>","text":"<p>Get the cannonical points to define the panel surface. These are the adjuster positions projected only the mirror surface. Note that this is in the nominal coordinates not the measured ones.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_adj","title":"<code>meas_adj</code>  <code>cached</code> <code>property</code>","text":"<p>The adjuster points transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_adj_resid","title":"<code>meas_adj_resid</code>  <code>cached</code> <code>property</code>","text":"<p>A correction that can be applied to <code>meas_adj</code> where we compute the average residual of measured points from the transformed model that are within <code>adjuster_radius</code> of the adjuster point in <code>xy</code>.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_surface","title":"<code>meas_surface</code>  <code>cached</code> <code>property</code>","text":"<p>The cannonical surface transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.model","title":"<code>model</code>  <code>cached</code> <code>property</code>","text":"<p>The modeled mirror surface at the locations of the measurementss.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.model_transformed","title":"<code>model_transformed</code>  <code>cached</code> <code>property</code>","text":"<p>The model transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.res_norm","title":"<code>res_norm</code>  <code>cached</code> <code>property</code>","text":"<p>Get norm of residuals between transformed model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.residuals","title":"<code>residuals</code>  <code>cached</code> <code>property</code>","text":"<p>Get residuals between model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.rms","title":"<code>rms</code>  <code>cached</code> <code>property</code>","text":"<p>Get rms between model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.rot","title":"<code>rot</code>  <code>property</code>","text":"<p>Rotation that aligns the model to the measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.shift","title":"<code>shift</code>  <code>property</code>","text":"<p>Shift that aligns the model to the measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.transformed_residuals","title":"<code>transformed_residuals</code>  <code>cached</code> <code>property</code>","text":"<p>Get residuals between transformed model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.gen_panels","title":"<code>gen_panels(mirror, dataset, corners, adjusters, compensate=0.0, adjuster_radius=50.0)</code>","text":"<p>Use a set of measurements to generate panel objects.</p> <p>Parameters:</p> Name Type Description Default <code>mirror</code> <code>str</code> <p>The mirror these panels belong to. Should be 'primary' or 'secondary'.</p> required <code>dataset</code> <code>Dataset</code> <p>The photogrammetry data.</p> required <code>corners</code> <code>dict[tuple[int, int], ndarray[float32]]</code> <p>The corners. This is indexed by a (row, col) tuple. Each entry is <code>(4, 3)</code> array where each row is a corner.</p> required <code>adjusters</code> <code>dict[tuple[int, int], NDArray[float32]]</code> <p>Nominal adjuster locations. This is indexed by a (row, col) tuple. Each entry is <code>(5, 3)</code> array where each row is an adjuster.</p> required <code>compensate</code> <code>float</code> <p>Amount (in mm) to compensate the model surface by. This is to account for things like the faro SMR.</p> <code>0.0</code> <code>adjuster_radius</code> <code>float</code> <p>The radius in XY of points that an adjuster should use to compute a secondary correction on its position. Should be in mm.</p> <code>50.0</code> <p>Returns:</p> Name Type Description <code>panels</code> <code>list[Panels]</code> <p>A list of panels with the transforme initialized to the identity.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def gen_panels(\n    mirror: str,\n    dataset: Dataset,\n    corners: dict[tuple[int, int], NDArray[np.float32]],\n    adjusters: dict[tuple[int, int], NDArray[np.float32]],\n    compensate: float = 0.0,\n    adjuster_radius: float = 50.0,\n) -&gt; list[Panel]:\n    \"\"\"\n    Use a set of measurements to generate panel objects.\n\n    Parameters\n    ----------\n    mirror : str\n        The mirror these panels belong to.\n        Should be 'primary' or 'secondary'.\n    dataset : Dataset\n        The photogrammetry data.\n    corners : dict[tuple[int, int], ndarray[np.float32]]\n        The corners. This is indexed by a (row, col) tuple.\n        Each entry is `(4, 3)` array where each row is a corner.\n    adjusters : dict[tuple[int, int], NDArray[np.float32]]\n        Nominal adjuster locations.\n        This is indexed by a (row, col) tuple.\n        Each entry is `(5, 3)` array where each row is an adjuster.\n    compensate : float, default: 0.0\n        Amount (in mm) to compensate the model surface by.\n        This is to account for things like the faro SMR.\n    adjuster_radius : float, default: 50.0\n        The radius in XY of points that an adjuster should use to\n        compute a secondary correction on its position.\n        Should be in mm.\n\n    Returns\n    -------\n    panels : list[Panels]\n        A list of panels with the transforme initialized to the identity.\n    \"\"\"\n    points = defaultdict(list)\n    # dumb brute force\n    corr = np.arange(4, dtype=int)\n    for point in dataset.points:\n        for rc, crns in corners.items():\n            x = crns[:, 0] &gt; point[0]\n            y = crns[:, 1] &gt; point[1]\n            val = x.astype(int) + 2 * y.astype(int)\n            if np.array_equal(np.sort(val), corr):\n                points[rc] += [point]\n                break\n\n    # Now init the objects\n    panels = []\n    for (row, col), meas in points.items():\n        meas = np.vstack(meas, dtype=np.float32)\n        panel = Panel(\n            mirror,\n            row,\n            col,\n            corners[(row, col)],\n            meas,\n            adjusters[(row, col)],\n            compensate,\n            adjuster_radius,\n        )\n        panels += [panel]\n    return panels\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.mirror_norm","title":"<code>mirror_norm(x, y, a)</code>","text":"<p>Analytic form of the vector normal to the mirror surface.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float32]</code> <p>X positions to calculate at in mm.</p> required <code>y</code> <code>NDArray[float32]</code> <p>Y positions to calculate at in mm. Should have the same shape as <code>x</code>.</p> required <code>a</code> <code>NDArray[float32]</code> <p>Coeffecients of the mirror function. Use <code>a_primary</code> for the primary mirror. Use <code>a_secondary</code> for the secondary mirror.</p> required <p>Returns:</p> Name Type Description <code>normals</code> <code>NDArray[float32]</code> <p>Unit vector normal to the mirror surface at each input coordinate. Has shape <code>shape(x) + (3,)</code>.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def mirror_norm(\n    x: NDArray[np.float32], y: NDArray[np.float32], a: NDArray[np.float32]\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Analytic form of the vector normal to the mirror surface.\n\n    Parameters\n    ----------\n    x : NDArray[np.float32]\n        X positions to calculate at in mm.\n    y : NDArray[np.float32]\n        Y positions to calculate at in mm.\n        Should have the same shape as `x`.\n    a : NDArray[np.float32]\n        Coeffecients of the mirror function.\n        Use `a_primary` for the primary mirror.\n        Use `a_secondary` for the secondary mirror.\n\n    Returns\n    -------\n    normals : NDArray[np.float32]\n        Unit vector normal to the mirror surface at each input coordinate.\n        Has shape `shape(x) + (3,)`.\n    \"\"\"\n    Rn = 3000.0\n\n    x_n = np.zeros_like(x)\n    y_n = np.zeros_like(y)\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):\n            if i != 0:\n                x_n += a[i, j] * (x ** (i - 1)) / (Rn**i) * (y / Rn) ** j\n            if j != 0:\n                y_n += a[i, j] * (x / Rn) ** i * (y ** (j - 1)) / (Rn**j)\n\n    z_n = -1 * np.ones_like(x_n)\n    normals = np.array((x_n, y_n, z_n)).T\n    normals /= np.linalg.norm(normals, axis=-1)[:, np.newaxis]\n    return normals\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.mirror_surface","title":"<code>mirror_surface(x, y, a)</code>","text":"<p>Analytic form of the mirror surface.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float32]</code> <p>X positions to calculate at in mm.</p> required <code>y</code> <code>NDArray[float32]</code> <p>Y positions to calculate at in mm. Should have the same shape as <code>x</code>.</p> required <code>a</code> <code>NDArray[float32]</code> <p>Coeffecients of the mirror function. Use <code>a_primary</code> for the primary mirror. Use <code>a_secondary</code> for the secondary mirror.</p> required <p>Returns:</p> Name Type Description <code>z</code> <code>NDArray[float32]</code> <p>Z position of the mirror at each input coordinate. Has the same shape as <code>x</code>.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def mirror_surface(\n    x: NDArray[np.float32], y: NDArray[np.float32], a: NDArray[np.float32]\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Analytic form of the mirror surface.\n\n    Parameters\n    ----------\n    x : NDArray[np.float32]\n        X positions to calculate at in mm.\n    y : NDArray[np.float32]\n        Y positions to calculate at in mm.\n        Should have the same shape as `x`.\n    a : NDArray[np.float32]\n        Coeffecients of the mirror function.\n        Use `a_primary` for the primary mirror.\n        Use `a_secondary` for the secondary mirror.\n\n    Returns\n    -------\n    z : NDArray[np.float32]\n        Z position of the mirror at each input coordinate.\n        Has the same shape as `x`.\n    \"\"\"\n    z = np.zeros_like(x)\n    Rn = 3000.0\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):\n            z += a[i, j] * (x / Rn) ** i * (y / Rn) ** j\n    return z\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.plot_panels","title":"<code>plot_panels(panels, title_str, vmax=None)</code>","text":"<p>Make a plot containing panel residuals and histogram. TODO: Correlation?</p> <p>Parameters:</p> Name Type Description Default <code>panels</code> <code>list[Panel]</code> <p>The panels to plot.</p> required <code>title_str</code> <code>str</code> <p>The title string, rms will me appended.</p> required <code>vmax</code> <code>Optional[float]</code> <p>The max of the colorbar. vmin will be -1 times this. Set to None to compute automatically. Should be in um.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>figure</code> <code>Figure</code> <p>The figure with panels plotted on it.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def plot_panels(\n    panels: list[Panel], title_str: str, vmax: Optional[float] = None\n) -&gt; Figure:\n    \"\"\"\n    Make a plot containing panel residuals and histogram.\n    TODO: Correlation?\n\n    Parameters\n    ----------\n    panels : list[Panel]\n        The panels to plot.\n    title_str : str\n        The title string, rms will me appended.\n    vmax : Optional[float], default: None\n        The max of the colorbar. vmin will be -1 times this.\n        Set to None to compute automatically.\n        Should be in um.\n\n    Returns\n    -------\n    figure : Figure\n        The figure with panels plotted on it.\n    \"\"\"\n    res_all = np.vstack([panel.residuals for panel in panels]) * 1000\n    model_all = np.vstack([panel.model for panel in panels])\n    if vmax is None:\n        vmax = np.max(np.abs(res_all[:, 2]))\n    if vmax is None:\n        raise ValueError(\"vmax still None?\")\n    gs = gridspec.GridSpec(2, 2, width_ratios=[20, 1], height_ratios=[2, 1])\n    fig = plt.figure()\n    ax0 = plt.subplot(gs[0])\n    cax = plt.subplot(gs[1])\n    ax1 = plt.subplot(gs[2:])\n    cb = None\n    for panel in panels:\n        ax0.tricontourf(\n            panel.model[:, 0],\n            panel.model[:, 1],\n            panel.residuals[:, 2] * 1000,\n            vmin=-1 * vmax,\n            vmax=vmax,\n            cmap=\"coolwarm\",\n            alpha=0.6,\n        )\n        cb = ax0.scatter(\n            panel.model[:, 0],\n            panel.model[:, 1],\n            s=40,\n            c=panel.residuals[:, 2] * 1000,\n            vmin=-1 * vmax,\n            vmax=vmax,\n            cmap=\"coolwarm\",\n            marker=\"o\",\n            alpha=0.9,\n            linewidth=2,\n            edgecolor=\"black\",\n        )\n        ax0.scatter(\n            panel.meas_adj[:, 0],\n            panel.meas_adj[:, 1],\n            marker=\"x\",\n            linewidth=1,\n            color=\"black\",\n        )\n    ax0.tricontourf(\n        model_all[:, 0],\n        model_all[:, 1],\n        res_all[:, 2],\n        vmin=-1 * vmax,\n        vmax=vmax,\n        cmap=\"coolwarm\",\n        alpha=0.2,\n    )\n    ax0.set_xlabel(\"x (mm)\")\n    ax0.set_ylabel(\"y (mm)\")\n    ax0.set_xlim(-3300, 3300)  # ack hardcoded!\n    ax0.set_ylim(-3300, 3300)\n    if cb is not None:\n        fig.colorbar(cb, cax)\n    ax0.set_aspect(\"equal\")\n    for panel in panels:\n        ax0.add_patch(\n            Polygon(panel.corners[[0, 1, 3, 2], :2], fill=False, color=\"black\")\n        )\n\n    ax1.hist(res_all[:, 2], bins=len(panels))\n    ax1.set_xlabel(\"z residual (um)\")\n\n    points = np.array([len(panel.measurements) for panel in panels])\n    rms = np.array([panel.rms for panel in panels])\n    tot_rms = 1000 * np.sum(rms * points) / np.sum(points)\n    fig.suptitle(f\"{title_str}, RMS={tot_rms:.2f} um\")\n\n    plt.show()\n\n    return fig\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.remove_cm","title":"<code>remove_cm(dataset, mirror, compensate=0, thresh=10, cut_thresh=50, niters=10)</code>","text":"<p>Fit for the common mode transformation from the model to the measurements of all panels and them remove it. Note that this will remove all coded targets from the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The photogrammetry data.</p> required <code>mirror</code> <code>str</code> <p>The mirror this data belong to. Should be 'primary' or 'secondary'.</p> required <code>compensate</code> <code>float</code> <p>Compensation to apply to model. This is to account for the radius of a Faro SMR.</p> <code>0</code> <code>thresh</code> <code>float</code> <p>How many times higher than the median residual a point needs to have to be considered an outlier.</p> <code>10</code> <code>niters</code> <code>int</code> <p>How many iterations of common mode fitting to do.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>kept_points</code> <code>Dataset</code> <p>The points that were successfully fit with the common mode removed.</p> <code>common_mode</code> <code>tuple[NDArray[float32], NDArray[float32]]</code> <p>The common mode that was removed. The first element is an affine matrix and the second is the shift.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def remove_cm(\n    dataset: Dataset,\n    mirror: str,\n    compensate: float = 0,\n    thresh: float = 10,\n    cut_thresh: float = 50,\n    niters: int = 10,\n) -&gt; tuple[Dataset, tuple[NDArray[np.float32], NDArray[np.float32]]]:\n    \"\"\"\n    Fit for the common mode transformation from the model to the measurements of all panels and them remove it.\n    Note that this will remove all coded targets from the dataset.\n\n    Parameters\n    ----------\n    dataset : Dataset\n        The photogrammetry data.\n    mirror : str\n        The mirror this data belong to.\n        Should be 'primary' or 'secondary'.\n    compensate : float, default: 0\n        Compensation to apply to model.\n        This is to account for the radius of a Faro SMR.\n    thresh : float, default: 10\n        How many times higher than the median residual a point needs to have to be\n        considered an outlier.\n    niters : int, default: 10\n        How many iterations of common mode fitting to do.\n\n    Returns\n    -------\n    kept_points: Dataset\n        The points that were successfully fit with the common mode removed.\n    common_mode : tuple[NDArray[np.float32], NDArray[np.float32]]\n        The common mode that was removed.\n        The first element is an affine matrix and\n        the second is the shift.\n    \"\"\"\n    logger.info(\"Removing common mode for %s\", mirror)\n\n    def _cm(x, panel):\n        panel.measurements[:] -= x[1:4]\n        rot = Rotation.from_euler(\"xyz\", x[4:])\n        panel.measurements = rot.apply(panel.measurements)\n        panel.measurements *= x[0]\n\n    def _opt(x, panel):\n        p2 = deepcopy(panel)\n        _cm(x, p2)\n        return p2.rms\n\n    # make a fake panel for the full mirror\n    corners = np.array(\n        ([-3300, -3300, 0], [-3300, 3300, 0], [3300, 3300, 0], [3300, -3300, 0])\n    )  # ack hardcoded\n    labels = dataset.target_labels\n    data = dataset.targets\n    corr = np.arange(4, dtype=int)\n    x = np.vstack([corners[:, 0] &gt; dat[0] for dat in data])\n    y = np.vstack([corners[:, 1] &gt; dat[1] for dat in data])\n    val = x.astype(int) + 2 * y.astype(int)\n    val = np.sort(val, axis=-1)\n    msk = (val == corr).all(-1)\n    data = data[msk]\n    labels = labels[msk]\n    panel = Panel(\n        mirror,\n        -1,\n        -1,\n        np.zeros((4, 3), \"float32\"),\n        data,\n        np.zeros((5, 3), \"float32\"),\n        compensate,\n    )\n    data = data.copy()\n    data_clean = data.copy()\n    logger.info(\"\\tRemoved %d points not on mirror surface\", np.sum(~msk))\n\n    x0 = np.hstack([np.ones(1), np.zeros(6)])\n    bounds = [(0.95, 1.05)] + [(-100, 100)] * 3 + [(0, 2 * np.pi)] * 3\n\n    for i in range(niters):\n        if len(panel.measurements) &lt; 3:\n            raise ValueError\n        logger.debug(\"\\titer %d for common mode fit\", i)\n        cut = panel.res_norm &gt; thresh * np.median(panel.res_norm)\n        if np.sum(cut) &gt; 0:\n            panel.measurements = panel.measurements[~cut]\n            data = data[~cut]\n\n        logger.debug(\"\\t\\tRemoving a naive common mode shift of %s\", str(panel.shift))\n        panel.measurements -= panel.shift\n        panel.measurements @= panel.rot.T\n\n        res = minimize(_opt, x0, (panel,), bounds=bounds)\n        logger.debug(\n            \"\\t\\tRemoving a fit common mode with scale %f, shift %s, and rotation %s\",\n            res.x[0],\n            str(res.x[1:4]),\n            str(res.x[4:]),\n        )\n        _cm(res.x, panel)\n\n        logger.debug(\n            \"\\t\\tRemoving a secondary common mode shift of %s and rotation of %s\",\n            str(panel.shift),\n            str(np.rad2deg(decompose_rotation(panel.rot))),\n        )\n        panel.measurements -= panel.shift\n        panel.measurements @= panel.rot.T\n\n    aff, sft = get_affine(\n        data, panel.measurements, method=\"mean\", weights=np.ones(len(data))\n    )\n    scale, shear, rot = decompose_affine(aff)\n    rot = decompose_rotation(rot)\n    logger.info(\n        \"\\tFull common mode is:\\n\\t\\t\\tshift = %s mm\\n\\t\\t\\tscale = %s\\n\\t\\t\\tshear = %s\\n\\t\\t\\trot = %s deg\",\n        str(sft),\n        str(scale),\n        str(shear),\n        str(np.rad2deg(rot)),\n    )\n\n    panel.measurements = apply_transform(data_clean, aff, sft)\n    cut = panel.res_norm &gt; cut_thresh * np.median(panel.res_norm)\n    if np.sum(cut) &gt; 0:\n        logger.info(\"\\tRemoving %d bad points from mirror\", np.sum(cut))\n        panel.measurements = panel.measurements[~cut]\n        labels = labels[~cut]\n    logger.info(\"\\tMirror has %d good points\", len(panel.measurements))\n\n    data = {l: d for l, d in zip(labels, panel.measurements)}\n\n    return Dataset(data), (aff, sft)\n</code></pre>"},{"location":"reference/photogrammetry/","title":"photogrammetry","text":"<p>Code for handling and processing photogrammetry data</p>"},{"location":"reference/photogrammetry/#lat_alignment.photogrammetry.Dataset","title":"<code>Dataset</code>  <code>dataclass</code>","text":"<p>Container class for photogrammetry dataset. Provides a dict like interface for accessing points by their labels.</p> <p>Attributes:</p> Name Type Description <code>data_dict</code> <code>dict[str, NDArray[float32]]</code> <p>Dict of photogrammetry points. You should genrally not touch this directly.</p> Source code in <code>lat_alignment/photogrammetry.py</code> <pre><code>@dataclass\nclass Dataset:\n    \"\"\"\n    Container class for photogrammetry dataset.\n    Provides a dict like interface for accessing points by their labels.\n\n    Attributes\n    ----------\n    data_dict : dict[str, NDArray[np.float32]]\n        Dict of photogrammetry points.\n        You should genrally not touch this directly.\n    \"\"\"\n\n    data_dict: dict[str, NDArray[np.float32]]\n\n    def _clear_cache(self):\n        self.__dict__.pop(\"points\", None)\n        self.__dict__.pop(\"labels\", None)\n        self.__dict__.pop(\"codes\", None)\n        self.__dict__.pop(\"code_labels\", None)\n        self.__dict__.pop(\"target\", None)\n        self.__dict__.pop(\"target_labels\", None)\n\n    def __setattr__(self, name, value):\n        if name == \"data_dict\":\n            self._clear_cache()\n        return super().__setattr__(name, value)\n\n    def __setitem__(self, key, item):\n        self._clear_cache()\n        self.data_dict[key] = item\n\n    def __getitem__(self, key):\n        return self.data_dict[key]\n\n    def __repr__(self):\n        return repr(self.data_dict)\n\n    def __len__(self):\n        return len(self.data_dict)\n\n    def __delitem__(self, key):\n        self._clear_cache()\n        del self.data_dict[key]\n\n    def __contains__(self, item):\n        return item in self.data_dict\n\n    def __iter__(self):\n        return iter(self.data_dict)\n\n    @cached_property\n    def points(self) -&gt; NDArray[np.float32]:\n        \"\"\"\n        Get all points in the dataset as an array.\n        This is cached.\n        \"\"\"\n        return np.array(list(self.data_dict.values()))\n\n    @cached_property\n    def labels(self) -&gt; NDArray[np.str_]:\n        \"\"\"\n        Get all labels in the dataset as an array.\n        This is cached.\n        \"\"\"\n        return np.array(list(self.data_dict.keys()))\n\n    @cached_property\n    def codes(self) -&gt; NDArray[np.float32]:\n        \"\"\"\n        Get all coded points in the dataset as an array.\n        This is cached.\n        \"\"\"\n        msk = np.char.find(self.labels, \"CODE\") &gt;= 0\n        return self.points[msk]\n\n    @cached_property\n    def code_labels(self) -&gt; NDArray[np.str_]:\n        \"\"\"\n        Get all coded labels in the dataset as an array.\n        This is cached.\n        \"\"\"\n        msk = np.char.find(self.labels, \"CODE\") &gt;= 0\n        return self.labels[msk]\n\n    @cached_property\n    def targets(self) -&gt; NDArray[np.float32]:\n        \"\"\"\n        Get all target points in the dataset as an array.\n        This is cached.\n        \"\"\"\n        msk = np.char.find(self.labels, \"TARGET\") &gt;= 0\n        return self.points[msk]\n\n    @cached_property\n    def target_labels(self) -&gt; NDArray[np.str_]:\n        \"\"\"\n        Get all target labels in the dataset as an array.\n        This is cached.\n        \"\"\"\n        msk = np.char.find(self.labels, \"TARGET\") &gt;= 0\n        return self.labels[msk]\n\n    def copy(self) -&gt; Self:\n        \"\"\"\n        Make a deep copy of the dataset.\n\n        Returns\n        -------\n        copy : Dataset\n            A deep copy of this dataset.\n        \"\"\"\n        return deepcopy(self)\n</code></pre>"},{"location":"reference/photogrammetry/#lat_alignment.photogrammetry.Dataset.code_labels","title":"<code>code_labels</code>  <code>cached</code> <code>property</code>","text":"<p>Get all coded labels in the dataset as an array. This is cached.</p>"},{"location":"reference/photogrammetry/#lat_alignment.photogrammetry.Dataset.codes","title":"<code>codes</code>  <code>cached</code> <code>property</code>","text":"<p>Get all coded points in the dataset as an array. This is cached.</p>"},{"location":"reference/photogrammetry/#lat_alignment.photogrammetry.Dataset.labels","title":"<code>labels</code>  <code>cached</code> <code>property</code>","text":"<p>Get all labels in the dataset as an array. This is cached.</p>"},{"location":"reference/photogrammetry/#lat_alignment.photogrammetry.Dataset.points","title":"<code>points</code>  <code>cached</code> <code>property</code>","text":"<p>Get all points in the dataset as an array. This is cached.</p>"},{"location":"reference/photogrammetry/#lat_alignment.photogrammetry.Dataset.target_labels","title":"<code>target_labels</code>  <code>cached</code> <code>property</code>","text":"<p>Get all target labels in the dataset as an array. This is cached.</p>"},{"location":"reference/photogrammetry/#lat_alignment.photogrammetry.Dataset.targets","title":"<code>targets</code>  <code>cached</code> <code>property</code>","text":"<p>Get all target points in the dataset as an array. This is cached.</p>"},{"location":"reference/photogrammetry/#lat_alignment.photogrammetry.Dataset.copy","title":"<code>copy()</code>","text":"<p>Make a deep copy of the dataset.</p> <p>Returns:</p> Name Type Description <code>copy</code> <code>Dataset</code> <p>A deep copy of this dataset.</p> Source code in <code>lat_alignment/photogrammetry.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"\n    Make a deep copy of the dataset.\n\n    Returns\n    -------\n    copy : Dataset\n        A deep copy of this dataset.\n    \"\"\"\n    return deepcopy(self)\n</code></pre>"},{"location":"reference/photogrammetry/#lat_alignment.photogrammetry.align_photo","title":"<code>align_photo(dataset, reference, kill_refs, element='primary', scale=True, *, plot=True, max_dist=100.0)</code>","text":"<p>Align photogrammetry data and then put it into mirror coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The photogrammetry data to align.</p> required <code>reference</code> <code>dict</code> <p>Reference dictionary. Should contain a key called <code>coords</code> that specifies the coordinate system that the reference points are in. The rest of the keys should be optical elements (ie: \"primary\") pointing to a list of reference points to use. Each point given should be a tuple with two elements. The first element is a tuple with the (x, y, z) coordinates of the point in the global coordinate system. The second is a list of nearby coded targets that can be used to identify the point.</p> required <code>kill_refs</code> <code>bool</code> <p>If True remove reference points from the dataset.</p> required <code>element</code> <code>str</code> <p>The element that these points belong to. Should be either: 'primary', 'secondary', 'bearing', or 'receiver'.</p> <code>'primary'</code> <code>plot</code> <code>bool</code> <p>If True show a diagnostic plot of how well the reference points are aligned.</p> <code>True</code> <code>max_dist</code> <code>float</code> <p>Max distance in mm that the reference poing can be from the target point used to locate it.</p> <code>100</code> <p>Returns:</p> Name Type Description <code>aligned</code> <code>Dataset</code> <p>The photogrammetry data aligned to the reference points.</p> <code>alignment</code> <code>tuple[NDArray[float32], NDArray[float32]]</code> <p>The transformation that aligned the points. The first element is a rotation matrix and the second is the shift.</p> Source code in <code>lat_alignment/photogrammetry.py</code> <pre><code>def align_photo(\n    dataset: Dataset,\n    reference: dict,\n    kill_refs: bool,\n    element: str = \"primary\",\n    scale: bool = True,\n    *,\n    plot: bool = True,\n    max_dist: float = 100.0,\n) -&gt; tuple[\n    Dataset,\n    tuple[NDArray[np.float32], NDArray[np.float32]],\n]:\n    \"\"\"\n    Align photogrammetry data and then put it into mirror coordinates.\n\n    Parameters\n    ----------\n    dataset : Dataset\n        The photogrammetry data to align.\n    reference : dict\n        Reference dictionary.\n        Should contain a key called `coords` that specifies the\n        coordinate system that the reference points are in.\n        The rest of the keys should be optical elements (ie: \"primary\")\n        pointing to a list of reference points to use.\n        Each point given should be a tuple with two elements.\n        The first element is a tuple with the (x, y, z) coordinates\n        of the point in the global coordinate system.\n        The second is a list of nearby coded targets that can be used\n        to identify the point.\n    kill_refs : bool\n        If True remove reference points from the dataset.\n    element: str, default: 'primary'\n        The element that these points belong to.\n        Should be either: 'primary', 'secondary', 'bearing', or 'receiver'.\n    plot : bool, default: True\n        If True show a diagnostic plot of how well the reference points\n        are aligned.\n    max_dist : float, default: 100\n        Max distance in mm that the reference poing can be from the target\n        point used to locate it.\n\n    Returns\n    -------\n    aligned : Dataset\n        The photogrammetry data aligned to the reference points.\n    alignment : tuple[NDArray[np.float32], NDArray[np.float32]]\n        The transformation that aligned the points.\n        The first element is a rotation matrix and\n        the second is the shift.\n    \"\"\"\n    logger.info(\"\\tAligning with reference points for %s\", element)\n    elements = [\"primary\", \"secondary\", \"bearing\", \"receiver\"]\n    if element not in elements and element != \"all\":\n        raise ValueError(f\"Invalid element: {element}\")\n    if len(reference) == 0:\n        raise ValueError(\"Invalid or empty reference\")\n    if element not in reference and element != \"all\":\n        raise ValueError(\"Element not found in reference dict\")\n    if \"coords\" not in reference:\n        raise ValueError(\"Reference coordinate system not specified\")\n    if element == \"primary\":\n        transform = partial(\n            coord_transform, cfrom=reference[\"coords\"], cto=\"opt_primary\"\n        )\n    elif element == \"secondary\":\n        transform = partial(\n            coord_transform, cfrom=reference[\"coords\"], cto=\"opt_secondary\"\n        )\n    else:\n        transform = partial(\n            coord_transform, cfrom=reference[\"coords\"], cto=\"opt_global\"\n        )\n    if element == \"all\":\n        all_refs = []\n        for el in elements:\n            if el not in reference:\n                continue\n            all_refs += reference[el]\n        reference[\"all\"] = all_refs\n\n    # Lets find the points we can use\n    ref = []\n    pts = []\n    invars = []\n    for rpoint, codes in reference[element]:\n        codes = np.array(codes)\n        have = np.isin(codes, dataset.code_labels)\n        if np.sum(have) == 0:\n            continue\n        coded = dataset[codes[have][0]]\n        # Find the closest point\n        dist = np.linalg.norm(dataset.targets - coded, axis=-1)\n        if np.min(dist) &gt; max_dist:\n            continue\n        label = dataset.target_labels[np.argmin(dist)]\n        ref += [rpoint]\n        pts += [dataset[label]]\n        invars += [label]\n    if len(ref) &lt; 4:\n        raise ValueError(f\"Only {len(ref)} reference points found! Can't align!\")\n    logger.debug(\n        \"\\t\\tFound %d reference points in measurements with labels:\\n\\t\\t\\t%s\",\n        len(pts),\n        str(invars),\n    )\n    pts = np.vstack(pts)\n    ref = np.vstack(ref)\n    pts = np.vstack((pts, np.mean(pts, 0)))\n    ref = np.vstack((ref, np.mean(ref, 0)))\n    ref = transform(ref)\n    logger.debug(\"\\t\\tReference points in element coords:\\n%s\", str(ref))\n    scale_fac = 1\n    if scale:\n        triu_idx = np.triu_indices(len(pts), 1)\n        scale_fac = np.nanmedian(make_edm(ref)[triu_idx] / make_edm(pts)[triu_idx])\n        pts *= scale_fac\n    logger.debug(\"\\t\\tScale factor of %f applied\", scale_fac)\n\n    rot, sft = get_rigid(pts, ref, method=\"mean\")\n    pts_t = apply_transform(pts, rot, sft)\n\n    if plot:\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=\"3d\")\n        ax.scatter(pts[:, 0], pts[:, 1], pts[:, 2], color=\"g\")\n        ax.scatter(pts_t[:, 0], pts_t[:, 1], pts_t[:, 2], color=\"b\")\n        ax.scatter(ref[:, 0], ref[:, 1], ref[:, 2], color=\"r\", marker=\"X\")\n        plt.show()\n    logger.info(\n        \"\\t\\tRMS of reference points after alignment: %f\",\n        np.sqrt(np.mean((pts_t - ref) ** 2)),\n    )\n    coords_transformed = apply_transform(dataset.points * scale_fac, rot, sft)\n    labels = dataset.labels\n\n    if kill_refs:\n        msk = ~np.isin(dataset.labels, invars)\n        labels = labels[msk]\n        coords_transformed = coords_transformed[msk]\n\n    data = {label: coord for label, coord in zip(labels, coords_transformed)}\n    transformed = Dataset(data)\n\n    logger.debug(\"\\t\\tShift is %s mm\", str(sft))\n    logger.debug(\"\\t\\tRotation is %s deg\", str(np.rad2deg(decompose_rotation(rot))))\n    scale_fac = np.eye(3) * scale_fac\n    rot @= scale_fac\n\n    if plot:\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=\"3d\")\n        ax.scatter(\n            transformed.targets[:, 0],\n            transformed.targets[:, 1],\n            transformed.targets[:, 2],\n            marker=\"x\",\n        )\n        plt.show()\n\n    return transformed, (rot, sft)\n</code></pre>"},{"location":"reference/transforms/","title":"transforms","text":"<p>Functions for coordinate transforms.</p> <p>There are 6 relevant coordinate systems here, belonging to two sets of three. Each set is a global, a primary, and a secondary coordinate system; where primary and secondary are internal to those mirrors. The two sets of coordinates are the optical coordinates and the coordinates used by vertex. We denote these six coordinate systems as follows:</p> <pre><code>- opt_global\n- opt_primary\n- opt_secondary\n- va_global\n- va_primary\n- va_secondary\n</code></pre>"},{"location":"reference/transforms/#lat_alignment.transforms.affine_basis_transform","title":"<code>affine_basis_transform(aff, sft, cfrom, cto, src_or_dst=True)</code>","text":"<p>Take an affine transform defined in one coordinate system and move it to another. The valid coordinate systems are the same as in <code>coord_transform</code>.</p> <p>Parameters:</p> Name Type Description Default <code>aff</code> <code>NDArray[float32]</code> <p>Affine matrix to tranform. Should be a <code>(3, 3)</code> array.</p> required <code>sft</code> <code>NDArray[float32]</code> <p>Shift vector to tranform. Should be a <code>(3,)</code> array.</p> required <code>cfrom</code> <code>str</code> <p>The coordinate system that <code>aff</code> and <code>sft</code> is currently in.</p> required <code>cto</code> <code>str</code> <p>The coordinate system to put <code>aff</code> and <code>sft</code> into.</p> required <code>src_or_dst</code> <code>bool</code> <p>If <code>True</code> then the coordinate transform is done on the source points that we are affine transforming. This is equivalent to doing <code>aff@(coord_transform(src)) + sft</code>. If <code>False</code> then the coordinate transform is done on the destination points obtained by the affine transform. This is equivalent to doing <code>coord_transform(aff@src + sft)</code></p> <code>True</code> <p>Returns:</p> Name Type Description <code>aff_transformed</code> <code>NDArray[float32]</code> <p><code>aff</code> transformed into <code>cto</code>.</p> <code>sft_transformed</code> <code>NDArray[float32]</code> <p><code>sft</code> transformed into <code>cto</code>.</p> Source code in <code>lat_alignment/transforms.py</code> <pre><code>def affine_basis_transform(\n    aff: NDArray[np.float32],\n    sft: NDArray[np.float32],\n    cfrom: str,\n    cto: str,\n    src_or_dst: bool = True,\n) -&gt; tuple[NDArray[np.float32], NDArray[np.float32]]:\n    \"\"\"\n    Take an affine transform defined in one coordinate system and move it to another.\n    The valid coordinate systems are the same as in `coord_transform`.\n\n    Parameters\n    ----------\n    aff : NDArray[np.float32]\n        Affine matrix to tranform.\n        Should be a `(3, 3)` array.\n    sft : NDArray[np.float32]\n        Shift vector to tranform.\n        Should be a `(3,)` array.\n    cfrom : str\n        The coordinate system that `aff` and `sft` is currently in.\n    cto : str\n        The coordinate system to put `aff` and `sft` into.\n    src_or_dst : bool, default: True\n        If `True` then the coordinate transform is done on the source\n        points that we are affine transforming.\n        This is equivalent to doing `aff@(coord_transform(src)) + sft`.\n        If `False` then the coordinate transform is done on the destination\n        points obtained by the affine transform.\n        This is equivalent to doing `coord_transform(aff@src + sft)`\n\n    Returns\n    -------\n    aff_transformed : NDArray[np.float32]\n        `aff` transformed into `cto`.\n    sft_transformed : NDArray[np.float32]\n        `sft` transformed into `cto`.\n    \"\"\"\n    # Make a grid of reference points\n    line = np.array((-1, 0, 1), np.float32)\n    x, y, z = np.meshgrid(line, line, line)\n    xyz = np.column_stack((x.ravel(), y.ravel(), z.ravel()))\n\n    # Apply the affine transform\n    xyz_transformed = apply_transform(xyz, aff, sft)\n\n    # Move to the new coordinate system\n    if src_or_dst:\n        xyz = coord_transform(xyz, cfrom, cto)\n    else:\n        xyz_transformed = coord_transform(xyz_transformed, cfrom, cto)\n\n    # Get the new affine transform\n    aff, sft = get_affine(xyz, xyz_transformed)\n\n    return aff, sft\n</code></pre>"},{"location":"reference/transforms/#lat_alignment.transforms.coord_transform","title":"<code>coord_transform(coords, cfrom, cto)</code>","text":"<p>Transform between the six defined mirror coordinates:</p> <pre><code>- opt_global\n- opt_primary\n- opt_secondary\n- va_global\n- va_primary\n- va_secondary\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>NDArray[float32]</code> <p>Coordinates to transform. Should be a <code>(npoint, 3)</code> array.</p> required <code>cfrom</code> <code>str</code> <p>The coordinate system that <code>coords</code> is currently in.</p> required <code>cto</code> <code>str</code> <p>The coordinate system to put <code>coords</code> into.</p> required <p>Returns:</p> Name Type Description <code>coords_transformed</code> <code>NDArray[float32]</code> <p><code>coords</code> transformed into <code>cto</code>.</p> Source code in <code>lat_alignment/transforms.py</code> <pre><code>def coord_transform(\n    coords: NDArray[np.float32], cfrom: str, cto: str\n) -&gt; NDArray[np.float32]:\n    \"\"\"\n    Transform between the six defined mirror coordinates:\n\n        - opt_global\n        - opt_primary\n        - opt_secondary\n        - va_global\n        - va_primary\n        - va_secondary\n\n    Parameters\n    ----------\n    coords : NDArray[np.float32]\n        Coordinates to transform.\n        Should be a `(npoint, 3)` array.\n    cfrom : str\n        The coordinate system that `coords` is currently in.\n    cto : str\n        The coordinate system to put `coords` into.\n\n    Returns\n    -------\n    coords_transformed : NDArray[np.float32]\n        `coords` transformed into `cto`.\n    \"\"\"\n    if cfrom == cto:\n        return coords\n    match f\"{cfrom}-{cto}\":\n        case \"opt_global-opt_primary\":\n            return _opt_global_to_opt_primary(coords)\n        case \"opt_global-opt_secondary\":\n            return _opt_global_to_opt_secondary(coords)\n        case \"opt_primary-opt_global\":\n            return _opt_primary_to_opt_global(coords)\n        case \"opt_secondary-opt_global\":\n            return _opt_secondary_to_opt_global(coords)\n        case \"opt_primary-opt_secondary\":\n            return _opt_primary_to_opt_secondary(coords)\n        case \"opt_secondary-opt_primary\":\n            return _opt_secondary_to_opt_primary(coords)\n        case \"va_global-va_primary\":\n            return _va_global_to_va_primary(coords)\n        case \"va_global-va_secondary\":\n            return _va_global_to_va_secondary(coords)\n        case \"va_primary-va_global\":\n            return _va_primary_to_va_global(coords)\n        case \"va_secondary-va_global\":\n            return _va_secondary_to_va_global(coords)\n        case \"va_primary-va_secondary\":\n            return _va_primary_to_va_secondary(coords)\n        case \"va_secondary-va_primary\":\n            return _va_secondary_to_va_primary(coords)\n        case \"opt_global-va_global\":\n            return _opt_global_to_va_global(coords)\n        case \"opt_global-va_primary\":\n            return _opt_global_to_va_primary(coords)\n        case \"opt_global-va_secondary\":\n            return _opt_global_to_va_secondary(coords)\n        case \"opt_primary-va_global\":\n            return _opt_primary_to_va_global(coords)\n        case \"opt_primary-va_primary\":\n            return _opt_primary_to_va_primary(coords)\n        case \"opt_primary-va_secondary\":\n            return _opt_primary_to_va_secondary(coords)\n        case \"opt_secondary-va_global\":\n            return _opt_secondary_to_va_global(coords)\n        case \"opt_secondary-va_primary\":\n            return _opt_secondary_to_va_primary(coords)\n        case \"opt_secondary-va_secondary\":\n            return _opt_secondary_to_va_secondary(coords)\n        case \"va_global-opt_global\":\n            return _va_global_to_opt_global(coords)\n        case \"va_global-opt_primary\":\n            return _va_global_to_opt_primary(coords)\n        case \"va_global-opt_secondary\":\n            return _va_global_to_opt_secondary(coords)\n        case \"va_primary-opt_global\":\n            return _va_primary_to_opt_global(coords)\n        case \"va_primary-opt_primary\":\n            return _va_primary_to_opt_primary(coords)\n        case \"va_primary-opt_secondary\":\n            return _va_primary_to_opt_secondary(coords)\n        case \"va_secondary-opt_global\":\n            return _va_secondary_to_opt_global(coords)\n        case \"va_secondary-opt_primary\":\n            return _va_secondary_to_opt_primary(coords)\n        case \"va_secondary-opt_secondary\":\n            return _va_secondary_to_opt_secondary(coords)\n        case _:\n            raise ValueError(\"Invalid coordinate system provided!\")\n</code></pre>"}]}