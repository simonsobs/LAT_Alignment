{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LAT Alignment","text":"<p>Tools for Large Aperture Telescope (LAT) mirror alignment. While these tools are currently specific to the Simons Observatory LAT, much of the library could be generalized to any telescope alignment.</p> <p>For details on usage please read the alignment procedure documentation.</p>"},{"location":"#installation","title":"Installation","text":"<p>Technically after cloning this repository you can just run <code>python lat_alignment/alignment.py PATH/TO/CONFIG</code>, but it is recommended that you install this as a package instead.</p> <p>To do this just run: <code>pip install -e .</code> from the root of this repository.</p> <p>This has two main benefits over running the script directly:</p> <ol> <li>It will handle dependencies for you.</li> <li>This sets up an entrypoint called <code>lat_alignment</code> so that you can call the code from anywhere. This is nice because now you can call the code from the measurement directory where you are most likely editing files, saving you the hassle of having to <code>cd</code> or wrangle long file paths.</li> </ol>"},{"location":"#bugs-and-feature-requests","title":"Bugs and Feature Requests","text":"<p>For low priority bugs and feature requests submit an issue on the git repo.</p> <p>For higher priority issues (or questions that require an expedient answer) email, Slack, or call me.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you wish to contribute to this repository (either code or adding measurement files) contact me via email or Slack.</p> <p>If you are contributing code please do so by creating a branch and submitting a pull request. Try to keep things as close to PEP8 as possible.</p>"},{"location":"alignment_procedure/","title":"Alignment Procedure","text":"<p>Here we describe the procedure for aligning the Simons Observatory (SO) Large Aperture Telescope (LAT) using this software package to process photogrammetry data taken using a Geodetic Systems' V-Stars system.</p> <p>With minor modifications these instructions and the software package could be generalized to other forms of measurements (ie: a laser tracker). Generalizing to other telescopes is possible but more involved. If you are interested in applying this software to other measurements or other telescopes please raise a GitHub issue for help with that.</p> <p>Before attempting and alignment it is useful to familiarize yourself with this relevant coordinate systems, the panel numbering scheme, and the package's configuration file.</p>"},{"location":"alignment_procedure/#reference-points","title":"Reference Points","text":"<p>Something that is key for both alignment stages is the use of reference points around the edges of the mirror and on the receiver. These are used to provide an initial transformation from the arbitrary coordinates that the photogrammetry measurements are in to a known coordinate system. These reference points should be places in locations that do not move when panels are installed (ie: around the edge of the mirror's back-up structure. In order to identify these points known coded targets should be placed near the reference points. Currently the locations of these points (in the \"Vertex Global\" coordinates) along with nearby coded targets are can be found in the <code>reference.yaml</code> data file.</p>"},{"location":"alignment_procedure/#panel-alignment","title":"Panel Alignment","text":"<p>When aligning panels the code takes the following steps:</p> <ol> <li>Use reference points to put the measurements in a know coordinate system</li> <li>Transform to the mirror's internal coordinates in the \"Optical\" coordinate system.</li> <li>Remove measurements with high error</li> <li>Find and remove spurious measurements (sometimes the photogrammetry software will accidently find the same target multiple times, only one of those locations is typically of good quality).</li> <li>Fit the surface against the model in multiple iterations (10 by default). Each iteration we remove the common mode transform that all panels see when fit against the model. We also remove points that are far enough from the surface (after removing the common mode) that they seem to be outliers or measurements not of the mirror surface.</li> <li>For each panel fit a transformation that describes how that panel deviates from the model.</li> <li>Use the per panel transformations to estimate how each adjuster is, if we have a measurement sufficiently close to the surface above and adjuster is to used to compute a correction on top of the fit model.</li> <li>Fit for how each adjuster must be moved to correct for the errors in each panel's location and shape. When we do this we model turning each adjuster as a rotation about the axis created by the adjacent adjusters. For small adjustments this is approximately the same as treating the adjusters as independent and simply moving them by their residuals. For large adjustments this is needed to correctly account for the interplay between adjusters.</li> </ol> <p>Warning</p> <p>Note that due to the common mode removal in step 5 above, the overall position of the mirror is not gaurunteed to be correct, only the shape of the surface. However this step is needed in order to account for errors in the locations of the reference point and cannot be skipped. The optical element alignment is needed after panel alignment to account for this an ensure that the mirrors and the receiver are in the correct location relative to each other.</p>"},{"location":"alignment_procedure/#inputs","title":"Inputs","text":"<p>There are only two required inputs to do the panel alignment.</p> <p>The first is a configuration file with the <code>mode</code> field set to <code>panel</code>, see here for an example.</p> <p>The second is a photogrammetry measurement of the mirror we want to align panels for. This measurement should only include measurements of one mirror and should have good measurements of at least four reference points.</p>"},{"location":"alignment_procedure/#outputs","title":"Outputs","text":"<p>The software produces two outputs: a plot of the mirror surface residuals and a <code>csv</code> file with the desired adjustments.</p> <p>The RMS in the title of the plot is the RMS of the residuals between the mirror model and the photogrammetry measurements. Each circle on the upper plot represents a point measured by photogrammetry and the grid shows the panel locations. Additionally there are three layers of colors overlayed on the plot. The colors within each circle show the residual at each measurement point, these colors can be interpreted using the colorbar. The low alpha background shows the residuals interpolated across the whole mirror, this is to show large scale trends but due to the low alpha should not be directly interpreted using the colorbar. The contour withing each panel shows the residuals interpolated between any points measured for that specific panel and show the errors in the shape of each panel as currently aligned, these colors can be interpreted using the color bar. The histogram below the surface plot shows the distribution of residuals for this measurement, if we have aligned to the white noise limit of the measurement then we expect this to look like a gaussian centered on 0.</p> <p></p> <p>The <code>csv</code> file contains the adjustments (and their associated uncertainties) for each panel in the measurement. Each row follows the format of the output of <code>alignement.adjust_panel</code>.</p>"},{"location":"alignment_procedure/#optical-element-alignment","title":"Optical Element Alignment","text":"<p>WIP! Check back later!</p>"},{"location":"config_file/","title":"Configuration File","text":""},{"location":"config_file/#fields","title":"Fields","text":"<code>mode</code> <p>The alignment mode to use.</p> <p>Possible values are:</p> <ul> <li><code>panel</code>: For aligning panels within one mirror.</li> <li><code>optical</code>: For aligning optical elements relative to each other (as solid bodies).</li> </ul> <code>mirror</code> <p>The mirror that we want to align panels to. Only used if <code>mode</code> is <code>panel</code>.</p> <p>Possible values are:</p> <ul> <li><code>primary</code>: To align the primary mirror.</li> <li><code>secondary</code>: To align the secondary mirror.</li> </ul> <code>align_to</code> <p>Which optical element to keep fixed and align the others to. Only used if <code>mode</code> is <code>optical</code>.</p> <p>Possible values are:</p> <ul> <li><code>primary</code>: To align to the primary mirror.</li> <li><code>secondary</code>: To align to the secondary mirror.</li> <li><code>receiver</code>: To align to the receiver.</li> <li><code>bearing</code>: To align to the bearing.</li> </ul> <code>measurement</code> <p>The path to the photogrammetry data we are using to do the alignment. If this is a relative path it is taken relative to the directory that the configuration file is in.</p> <code>data_dir</code> <p>The path to the data files that define the panel corners and the adjuster positions. If this is a relative path it is taken relative to the directory that the configuration file is in.</p> <p>You genrally don't need to provide this since the package will use its own bundled data files by default.</p> <code>load</code> <p>Additional keyword arguments to pass to <code>io.load_photo</code>.</p> <code>load</code> <p>Additional keyword arguments to pass to <code>photogrammetry.align_photo</code>.</p> <code>compensate</code> <p>Amount to compensate mirror measurements by in mm. This is for backwards compatiblilty with laser tracker data and is \\(0\\) by default.</p> <code>common_mode</code> <p>Additional keyword arguments to pass to <code>mirror.remove_cm</code></p> <code>adjuster_radius</code> <p>How close to an adjuster a data point needs to be in order for us to use its residual as a secondary correction when computing adjustments. Only used if <code>mode</code> is <code>panel</code>.</p> <p>This is \\(100\\) mm by default.</p> <code>vmax</code> <p>The maximum value to use in the colorbar when plotting mirror surface. The colorbar is symmetric so <code>vmin = -1*vmax</code>.</p> <code>adjust</code> <p>Additional keyword arguments to pass to <code>adjustments.calc_adjustments</code></p> <code>fit_adjustments</code> <p>If <code>True</code> then attempt to fit for adjustments by modeling them as panel rotations. If <code>False</code> sinply use the raw residuals. If you have a finely sampled point cloud fitting is prefered but for sparse sampling you may want to turn this off.</p> <p>This is <code>True</code> by default.</p> <code>title</code> <p>The title of the measurement. This is used both in plots and in output filenames.</p>"},{"location":"config_file/#example-configuration-files","title":"Example Configuration Files","text":"<p>These are typical configuration files, you usually will not need to touch fields other than the ones shown here.</p>"},{"location":"config_file/#panel-alignment","title":"Panel Alignment","text":"<pre><code>mode: \"panel\"\nmirror: \"secondary\"\nmeasurement: \"data_20240911_1430.csv\"\ntitle: \"M2 20240911 1430\"\nvmax: 50\n</code></pre>"},{"location":"config_file/#optical-element-alignment","title":"Optical Element Alignment","text":"<p>WIP! Check back later!</p>"},{"location":"coordinate_systems/","title":"Coordinate Systems","text":"<p>There are many coordinate systems that have been used to describe the LAT mirror, most of them were used a single time and them replaced. Here we describe the six coordinate systems that are actively used. These six coordinate systems can be organized into two groups: the \"Optical\" coordinate systems and the \"Vertex\" coordinate systems. Each of these groups contains three coordinate systems: \"Global\", \"Primary\", and \"Secondary\"; where \"Global\" is a global reference frame for the whole telescope, \"Primary\" is an internal reference frame for the primary mirror, and \"Secondary\" is an internal reference frame for the secondary mirror.</p> <p>In general this software package does all of its computations in the \"Optical\" systems, but it is useful to understand the \"Vertex\" systems so that one can utilize measurements provided by Vertex.</p> <p>Note that this page is mostly to give the user an understanding of how these coordinate systems are defined. You should never have to transform between them by hand. For that please use the <code>transforms.coord_transform</code> function.</p>"},{"location":"coordinate_systems/#optical-coordinate-systems","title":"Optical Coordinate Systems","text":"<p>The optical coordinate systems are designed to be logical given the optics of the telescope.</p> <p>For \"Primary\" and \"Secondary\" the axis are defined such that:</p> <ul> <li>The \\(x\\) axis changes as the panel column number changes.</li> <li>The \\(y\\) axis changes as the panel row number changes.</li> <li>The \\(z\\) axis is normal to the mirror surfaces.</li> </ul> <p>And the origin is at the center of the mirror surface. The mirror model in <code>mirror.mirror_surface</code> is computed in these coordinates.</p> <p>The directions of the axis relative to the mirror surface is not the same for the two mirrors, check the diagram below to see where they point.</p> <p>The \"Global\" coordinate system is defined such that:</p> <ul> <li>The \\(x\\) axis is tangent to the telescope's azimuth rotation.</li> <li>The \\(y\\) axis points towards the receiver.</li> <li>The \\(z\\) axis points in the direction that light enters the telescope.</li> </ul> <p>And the origin is set so that the origin of the \"Primary\" system lies along the \"Global\" \\(z\\) axis and the origin of the \"Secondary\" system lies along the \"Global\" \\(y\\) axis.</p> <p></p>"},{"location":"coordinate_systems/#vertex-coordinate-systems","title":"Vertex Coordinate Systems","text":"<p>The vertex coordinate systems were developed by Vertex and are used for all of there alignment purposes. If you get data from Vertex it is likely in this format.</p> <p>For \"Primary\" and \"Secondary\" the axis are defined such that:</p> <ul> <li>The \\(x\\) axis changes as the panel row number changes.</li> <li>The \\(y\\) axis changes as the panel column number changes.</li> <li>The \\(z\\) axis is normal to the mirror surfaces.</li> </ul> <p>The origins are the same as in the \"Optical\" coordinate systems. See the diagram below for the orientation of these axes.</p> <p>The \"Global\" coordinate system is defined such that:</p> <ul> <li>The \\(x\\) axis points towards the receiver.</li> <li>The \\(y\\) axis is tangent to the telescope's azimuth rotation.</li> <li>The \\(z\\) axis points out of the telescope.</li> </ul> <p>The origin is offset by 120 mm along the \"Vertex\" \\(x\\) (so the \"Optical\" \\(y\\) axis). The reason for the offset is unclear.</p> <p></p>"},{"location":"ixb/","title":"IxB Instructions","text":"<p>Manually adjusting every mirror panel can be extremely time consuming and error prone. Here we discuss the setup and use of a Atlas Copco IxB tool to do this.</p> <p>This is done using the Atlas Copco Open Protocol, it may be useful to familiarize yourself with the specification and appendix but note that these are not up to date and working with the protocol may require a mix of trail and error and packet sniffing.</p>"},{"location":"ixb/#initial-setup","title":"Initial Setup","text":"<ol> <li>Connect to the tool, this can be done via wifi or USB. If you connect via USB the IP will be <code>168.254.1.1</code>, if you connect to the tool's local wifi network the IP should be <code>192.168.1.1</code>. To access the web interface simply enter the IP into your browser.</li> <li>Install the backup of the IxB configuration with all of the needed mapping preloaded (contact Saianeesh for this). See this page for instructions on how to do this import.</li> <li>Make sure open protocol is active in the virtual station.</li> </ol>"},{"location":"ixb/#sending-data-to-the-tool","title":"Sending Data to the Tool","text":"<p>Future Feature Alert!</p> <p>Right now there are limitations of the IxB firmware that prevent your from having all adjustors programmed at once! Ongoing development will eventually enable a \"server-client\" mode that will work around this limitation.</p> <p>Once you have calculated your required adjustments for the mirror you can send it to the tool by running:</p> <pre><code>ixb_send PATH_TO_ADJUSTEMNTS MIRROR_HALF\n</code></pre> <p>where <code>PATH_TO_ADJUSTEMNTS</code> is the path to the output from <code>lat_alignment</code> in panel mode and <code>MIRROR_HALF</code> is the half of the mirror we are adjusting. If <code>MIRROR_HALF</code> is <code>1</code> then we are adjusting the panels in rows 1-4 and if it in <code>2</code> then we are adjusting rows 5-9.</p> <p>This command will also print out a list of adjusters above the adjustment threshold, it is useful to take note of this so you can skip areas that don't need adjusting. The adjustment threshold and the number of microns per turn of the adjuster can be set as command line arguments, run <code>ixb_send --help</code> for syntax. The IP and port of the tool can also be specified this way.</p> <p>Once this is done reboot the IxB tool by removing the battery and waiting for the screen to shut off and then reinstalling the battery. This is needed ensure that the changes to the tightening program propagate.</p> <p>The final step is to make sure the correct task is selected, to do this:</p> <ol> <li>Connect to the web UI for the IxB tool.</li> <li>Go to the \"Integrated Controller Tool\" menu</li> <li>Click \"Virtual Station\"</li> <li>Under \"Task\" select \"Choose Test\"</li> <li>Clock on the \"Sources\" tab</li> <li>Select <code>Mirror_Part1</code> or <code>Mirror_Part</code> depending on which half of the mirror you are adjusting.</li> <li>Click \"Save\"</li> </ol>"},{"location":"ixb/#using-the-ixb-tool-to-adjust-panels","title":"Using the IxB Tool to Adjust Panels","text":"<p>This part is easy (hopefully):</p> <ol> <li>Scan the barcode next to the adjuster. This can be done either by pulling the trigger or hitting the button on top of the scanner.</li> <li>If you have already scanned this adjuster a pop up will appear on the screen asking you to confirm.</li> <li>Place the tool on the edge of the adjuster and hold down the trigger until the screen goes green.</li> <li>Try not to hit your head as you move to the next adjuster.</li> </ol> <p>It will save time if you use the list of adjusters above threshold that <code>ixb_send</code> generates to only scan adjuster you need to hit.</p>"},{"location":"panel_numbers/","title":"Panel Numbering Scheme","text":"<p>Info</p> <p>Here we only describe the indexing and labeling of the mirror panels. For information on the optics of the mirrors please see Parshley et al.. For more information on the optics of the SO LAT  Dicker et al. and Gudmundsson et al. are useful resources as well.</p> <p>Each LAT mirror panel can be identified by a eight digit ID in the following format:</p> <pre><code>(telescope number)(mirror number)(panel row)(panel column}(panel number)\n</code></pre> <p>Where:</p> <ul> <li><code>telescope number</code> is a four digit ID for the telescope that the mirror belongs to with a hyphen between the second and third digit. The SO LAT is \\(01-01\\).</li> <li><code>mirror number</code> is \\(1\\) for the primary mirror and \\(2\\) for the secondary mirror.</li> <li><code>panel row</code> is which row of the mirror the panel is in (see diagram below).</li> <li><code>panel column</code> is which column of the mirror the panel is in (see diagram below).</li> <li><code>panel number</code> identifies which instance of the panel you have, it can change to denote the creation of a spare or replacement panel.</li> </ul> <p></p> <p>Each panel has eight adjusters:</p> <ul> <li>Two \\(x\\) adjusters (ie: moving the panel along its row) denoted as \\(H1\\) and \\(H2\\).</li> <li>One \\(y\\) adjuster (ie: moving the panel along its column) denoted as \\(H3\\).</li> <li>Five \\(z\\) adjusters (ie: to deform the panel surface) denoted as \\(V1\\) to \\(V5\\).</li> </ul> <p>The locations of these adjusters on the back of the panel can be seen below:</p> <p></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>adjustments</li> <li>alignment</li> <li>bearing</li> <li>data_alignment</li> <li>dataset</li> <li>error</li> <li>fitting</li> <li>io</li> <li>ixb</li> <li>mirror</li> <li>refpoint</li> <li>traj_plots</li> <li>trajectory</li> <li>transforms</li> </ul>"},{"location":"reference/adjustments/","title":"adjustments","text":"<p>Calculate adjustments needed to align LAT mirror panel</p> <p>Author: Saianeesh Keshav Haridas</p>"},{"location":"reference/adjustments/#lat_alignment.adjustments.adjustment_fit_func","title":"<code>adjustment_fit_func(pars, can_points, points, adjustors)</code>","text":"<p>Function to minimize when calculating adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>pars</code> <code>NDArray[float64]</code> <p>The parameters to fit for:</p> <ul> <li>dx: Translation in x</li> <li>dy: Translation in y</li> <li>dz: Translation in z</li> <li>thetha_0: Angle to rotate about first adjustor axis</li> <li>thetha_1: Angle to rotate about second adjustor axis</li> <li>z_t: Additional translation to tension the center point</li> </ul> required <code>can_points</code> <code>NDArray[float64]</code> <p>The cannonical positions of the points to align.</p> required <code>points</code> <code>NDArray[float64]</code> <p>The measured positions of the points to align.</p> required <code>adjustors</code> <code>NDArray[float64]</code> <p>The measured positions of the adjustors.</p> required <p>Returns:</p> Name Type Description <code>norm</code> <code>float64</code> <p>The norm of \\(cannonical_positions - transformed_positions\\).</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def adjustment_fit_func(\n    pars: NDArray[np.float64],\n    can_points: NDArray[np.float64],\n    points: NDArray[np.float64],\n    adjustors: NDArray[np.float64],\n) -&gt; np.float64:\n    r\"\"\"\n    Function to minimize when calculating adjustments.\n\n    Parameters\n    ----------\n    pars : NDArray[np.float64]\n        The parameters to fit for:\n\n        * dx: Translation in x\n        * dy: Translation in y\n        * dz: Translation in z\n        * thetha_0: Angle to rotate about first adjustor axis\n        * thetha_1: Angle to rotate about second adjustor axis\n        * z_t: Additional translation to tension the center point\n    can_points : NDArray[np.float64]\n        The cannonical positions of the points to align.\n    points : NDArray[np.float64]\n        The measured positions of the points to align.\n    adjustors : NDArray[np.float64]\n        The measured positions of the adjustors.\n\n    Returns\n    -------\n    norm : np.float64\n        The norm of $cannonical_positions - transformed_positions$.\n    \"\"\"\n    dx, dy, dz, thetha_0, thetha_1, z_t = pars\n    points, adjustors = translate_panel(points, adjustors, dx, dy, dz)\n    points, adjustors = rotate_panel(points, adjustors, thetha_0, thetha_1)\n    points[-1, -1] += z_t\n    return np.linalg.norm(can_points - points)\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.calc_adjustments","title":"<code>calc_adjustments(can_points, points, adjustors, **kwargs)</code>","text":"<p>Calculate adjustments needed to align panel.</p> <p>Parameters:</p> Name Type Description Default <code>can_points</code> <code>NDArray[float64]</code> <p>The cannonical position of the points to align.</p> required <code>points</code> <code>NDArray[float64]</code> <p>The measured positions of the points to align.</p> required <code>adjustors</code> <code>NDArray[float64]</code> <p>The measured positions of the adjustors.</p> required <code>**kwargs</code> <p>Arguments to be passed to <code>scipy.optimize.minimize</code>.</p> <code>{}</code> <code>dx</code> <code>float64</code> <p>The required translation of panel in x.</p> required <code>dy</code> <code>float64</code> <p>The required translation of panel in y.</p> required <code>d_adj</code> <code>NDArray[float64]</code> <p>The amount to move each adjustor.</p> required <code>dx_err</code> <code>float64</code> <p>The error in the fit for <code>dx</code>.</p> required <code>dy_err</code> <code>float64</code> <p>The error in the fit for <code>dy</code>.</p> required <code>d_adj_err</code> <code>NDArray[float64]</code> <p>The error in the fit for <code>d_adj</code>.</p> required Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def calc_adjustments(\n    can_points: NDArray[np.float64],\n    points: NDArray[np.float64],\n    adjustors: NDArray[np.float64],\n    **kwargs,\n) -&gt; Tuple[\n    np.float64,\n    np.float64,\n    NDArray[np.float64],\n    np.float64,\n    np.float64,\n    NDArray[np.float64],\n]:\n    \"\"\"\n    Calculate adjustments needed to align panel.\n\n    Parameters\n    ----------\n    can_points : NDArray[np.float64]\n        The cannonical position of the points to align.\n    points : NDArray[np.float64]\n        The measured positions of the points to align.\n    adjustors : NDArray[np.float64]\n        The measured positions of the adjustors.\n    **kwargs\n        Arguments to be passed to `scipy.optimize.minimize`.\n\n    dx : np.float64\n        The required translation of panel in x.\n    dy : np.float64\n        The required translation of panel in y.\n    d_adj : NDArray[np.float64]\n        The amount to move each adjustor.\n    dx_err : np.float64\n        The error in the fit for `dx`.\n    dy_err : np.float64\n        The error in the fit for `dy`.\n    d_adj_err : NDArray[np.float64]\n        The error in the fit for `d_adj`.\n    \"\"\"\n    res = opt.minimize(\n        adjustment_fit_func, np.zeros(6), (can_points, points, adjustors), **kwargs\n    )\n\n    dx, dy, dz, thetha_0, thetha_1, z_t = res.x\n    _points, _adjustors = translate_panel(points, adjustors, dx, dy, dz)\n    _points, _adjustors = rotate_panel(_points, _adjustors, thetha_0, thetha_1)\n    _adjustors[-1, -1] += z_t\n    d_adj = _adjustors - adjustors\n\n    ftol = 2.220446049250313e-09\n    if \"ftol\" in kwargs:\n        ftol = kwargs[\"ftol\"]\n    perr = np.sqrt(ftol * np.diag(res.hess_inv))\n    dx_err, dy_err, dz_err, thetha_0_err, thetha_1_err, z_t_err = perr\n    _points, _adjustors = translate_panel(points, adjustors, dx_err, dy_err, dz_err)\n    _points, _adjustors = rotate_panel(_points, _adjustors, thetha_0_err, thetha_1_err)\n    _adjustors[-1, -1] += z_t_err\n    d_adj_err = _adjustors - adjustors\n\n    return dx, dy, d_adj[:, 2], dx_err, dy_err, d_adj_err[:, 2]\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.rotate","title":"<code>rotate(point, end_point1, end_point2, theta)</code>","text":"<p>Rotate a point about an axis</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>NDArray[float64]</code> <p>The point to rotate</p> required <code>end_point1</code> <code>NDArray[float64]</code> <p>A point on the axis of rotation</p> required <code>end_point2</code> <code>NDArray[float64]</code> <p>Another point on the axis of rotation</p> required <code>theta</code> <code>float64</code> <p>Angle in radians to rotate by</p> required <p>Returns:</p> Name Type Description <code>point</code> <code>NDArray[float64]</code> <p>The rotated point</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def rotate(\n    point: NDArray[np.float64],\n    end_point1: NDArray[np.float64],\n    end_point2: NDArray[np.float64],\n    theta: np.float64,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Rotate a point about an axis\n\n    Parameters\n    ----------\n    point : NDArray[np.float64]\n        The point to rotate\n    end_point1 : NDArray[np.float64]\n        A point on the axis of rotation\n    end_point2 : NDArray[np.float64]\n        Another point on the axis of rotation\n    theta: NDArray[np.float64]\n        Angle in radians to rotate by\n\n    Returns\n    -------\n    point : NDArray[np.float64]\n        The rotated point\n    \"\"\"\n    origin = np.mean((end_point1, end_point2))\n    point_0 = point - origin\n    ax = end_point2 - end_point1\n    ax = rot.from_rotvec(theta * ax / np.linalg.norm(ax))\n    point_0 = ax.apply(point_0)\n    return point_0 + origin\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.rotate_panel","title":"<code>rotate_panel(points, adjustors, thetha_0, thetha_1)</code>","text":"<p>Rotate panel about axes created by adjustors.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[float64]</code> <p>Points on panel to rotate.</p> required <code>adjustors</code> <code>NDArray[float64]</code> <p>Adjustor positions.</p> required <code>thetha_0</code> <code>float64</code> <p>Angle to rotate about first adjustor axis</p> required <code>thetha_1</code> <code>np.float64.</code> <p>Angle to rotate about second adjustor axis</p> required <p>Returns:</p> Name Type Description <code>rot_points</code> <code>NDArray[float64]</code> <p>The rotated points.</p> <code>rot_adjustors</code> <code>NDArray[float64]</code> <p>The rotated adjustors.</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def rotate_panel(\n    points: NDArray[np.float64],\n    adjustors: NDArray[np.float64],\n    thetha_0: np.float64,\n    thetha_1: np.float64,\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"\n    Rotate panel about axes created by adjustors.\n\n    Parameters\n    ----------\n    points : NDArray[np.float64]\n        Points on panel to rotate.\n    adjustors : NDArray[np.float64]\n        Adjustor positions.\n    thetha_0 : np.float64\n        Angle to rotate about first adjustor axis\n    thetha_1 : np.float64.\n        Angle to rotate about second adjustor axis\n\n    Returns\n    -------\n    rot_points : NDArray[np.float64]\n        The rotated points.\n    rot_adjustors : NDArray[np.float64]\n        The rotated adjustors.\n    \"\"\"\n    rot_points = np.zeros(points.shape, np.float64)\n    rot_adjustors = np.zeros(adjustors.shape, np.float64)\n\n    n_points = len(points)\n    n_adjustors = len(adjustors)\n\n    for i in range(n_points):\n        rot_points[i] = rotate(points[i], adjustors[1], adjustors[2], thetha_0)\n        rot_points[i] = rotate(rot_points[i], adjustors[0], adjustors[3], thetha_1)\n    for i in range(n_adjustors):\n        rot_adjustors[i] = rotate(adjustors[i], adjustors[1], adjustors[2], thetha_0)\n        rot_adjustors[i] = rotate(\n            rot_adjustors[i], adjustors[0], adjustors[3], thetha_1\n        )\n    return rot_points, rot_adjustors\n</code></pre>"},{"location":"reference/adjustments/#lat_alignment.adjustments.translate_panel","title":"<code>translate_panel(points, adjustors, dx, dy, dz)</code>","text":"<p>Translate a panel.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[float64]</code> <p>The points on panel to translate.</p> required <code>adjustors</code> <code>NDArray[float64]</code> <p>Adjustor positions.</p> required <code>dx</code> <code>float64</code> <p>Translation in x.</p> required <code>dy</code> <code>float64</code> <p>Translation in y.</p> required <code>dz</code> <code>float64</code> <p>Translation in z.</p> required <p>Returns:</p> Name Type Description <code>points</code> <code>NDArray[float64]</code> <p>The translated points.</p> <code>adjustors</code> <code>NDArray[float64]</code> <p>The translated adjustors.</p> Source code in <code>lat_alignment/adjustments.py</code> <pre><code>def translate_panel(\n    points: NDArray[np.float64],\n    adjustors: NDArray[np.float64],\n    dx: np.float64,\n    dy: np.float64,\n    dz: np.float64,\n) -&gt; Tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"\n    Translate a panel.\n\n    Parameters\n    ----------\n    points : NDArray[np.float64]\n        The points on panel to translate.\n    adjustors : NDArray[np.float64]\n        Adjustor positions.\n    dx : np.float64\n        Translation in x.\n    dy : np.float64\n        Translation in y.\n    dz : np.float64\n        Translation in z.\n\n    Returns\n    -------\n    points : NDArray[np.float64]\n        The translated points.\n    adjustors : NDArray[np.float64]\n        The translated adjustors.\n    \"\"\"\n    translation = np.array((dx, dy, dz))\n    return points + translation, adjustors + translation\n</code></pre>"},{"location":"reference/alignment/","title":"alignment","text":"<p>Main driver script for running the alignment. You typically want to use the <code>lat_alignment</code> entrypoint rather than calling this directly.</p>"},{"location":"reference/alignment/#lat_alignment.alignment.adjust_panel","title":"<code>adjust_panel(panel, mnum, fit, cfg)</code>","text":"<p>Helper function to get the adjustments for a single panel.</p> <p>Parameters:</p> Name Type Description Default <code>panel</code> <code>Panel</code> <p>The mirror panel to adjust.</p> required <code>mnum</code> <code>int</code> <p>The mirror number. 1 for the primary and 2 for the secondary.</p> required <code>fit</code> <code>bool</code> <p>If True fit for the adjustments by modeling them as rotations of the panel. If False just use the raw residuals.</p> required <code>cfg</code> <code>dict</code> <p>The configuration dictionairy.</p> required <p>Returns:</p> Name Type Description <code>adjustments</code> <code>NDArray[float64]</code> <p>The adjustments to make for the panel. This is a 17 element array with the following structure: <code>[mnum, panel_row, panel_col, dx, dy, d_adj1, ..., d_adj5, dx_err, dy_err, d_adj1_err, ..., d_adj5_err]</code>.</p> Source code in <code>lat_alignment/alignment.py</code> <pre><code>def adjust_panel(\n    panel: mir.Panel, mnum: int, fit: bool, cfg: dict\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Helper function to get the adjustments for a single panel.\n\n    Parameters\n    ----------\n    panel : mir.Panel\n        The mirror panel to adjust.\n    mnum : int\n        The mirror number.\n        1 for the primary and 2 for the secondary.\n    fit: bool\n        If True fit for the adjustments by modeling them as rotations of the panel.\n        If False just use the raw residuals.\n    cfg : dict\n        The configuration dictionairy.\n\n    Returns\n    -------\n    adjustments : NDArray[np.float64]\n        The adjustments to make for the panel.\n        This is a 17 element array with the following structure:\n        `[mnum, panel_row, panel_col, dx, dy, d_adj1, ..., d_adj5, dx_err, dy_err, d_adj1_err, ..., d_adj5_err]`.\n    \"\"\"\n    adjustments = np.zeros(17, np.float64)\n    adjustments[0] = mnum\n    adjustments[1] = panel.row\n    adjustments[2] = panel.col\n    if fit:\n        meas_adj = panel.meas_adj.copy()\n        meas_adj[:, 2] -= panel.meas_adj_resid\n        meas_surface = panel.meas_surface.copy()\n        meas_surface[:, 2] -= panel.meas_adj_resid\n        dx, dy, d_adj, dx_err, dy_err, d_adj_err = adj.calc_adjustments(\n            panel.can_surface, meas_surface, meas_adj, **cfg.get(\"adjust\", {})\n        )\n    else:\n        dx = 0\n        dx_err = 0\n        dy = 0\n        dy_err = 0\n        d_adj = -1 * panel.adj_resid\n        d_adj_err = np.zeros_like(d_adj)\n    # The primary has x and z opposite to what is intuitive\n    if mnum == 1:\n        dx *= -1\n        d_adj *= -1\n    adjustments[3:] = np.array(\n        [dx, dy] + list(d_adj) + [dx_err, dy_err] + list(d_adj_err)\n    )\n\n    return adjustments\n</code></pre>"},{"location":"reference/bearing/","title":"bearing","text":"<p>Module for fitting for the bearing location. Needs to be made less hardcoded...</p>"},{"location":"reference/bearing/#lat_alignment.bearing.cylinder_fit","title":"<code>cylinder_fit(dataset)</code>","text":"<p>Fit for the bearing's position by fitting a cylinder to the bearing surface. This acts as a correction on top of the alignment to reference points.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>DatasetPhotogrammetry</code> <p>Photogrammetry dataset. Should already be aligned to the bearing referance points.</p> required <p>Returns:</p> Name Type Description <code>inside_points</code> <code>DatasetPhotogrammetry</code> <p>Points on the inner surface of the bearing with alignment applied. Only includes targets, codes are removed.</p> <code>alignment</code> <code>tuple[NDArray[float64], NDArray[float64]]</code> <p>The transformation that aligned the bearing. The first element is a rotation matrix and the second is the shift.</p> Source code in <code>lat_alignment/bearing.py</code> <pre><code>def cylinder_fit(\n    dataset: DatasetPhotogrammetry,\n) -&gt; tuple[DatasetPhotogrammetry, tuple[NDArray[np.float64], NDArray[np.float64]]]:\n    \"\"\"\n    Fit for the bearing's position by fitting a cylinder to the bearing surface.\n    This acts as a correction on top of the alignment to reference points.\n\n    Parameters\n    ----------\n    dataset : DatasetPhotogrammetry\n        Photogrammetry dataset.\n        Should already be aligned to the bearing referance points.\n\n    Returns\n    -------\n    inside_points : DatasetPhotogrammetry\n        Points on the inner surface of the bearing with alignment applied.\n        Only includes targets, codes are removed.\n    alignment : tuple[NDArray[np.float64], NDArray[np.float64]]\n        The transformation that aligned the bearing.\n        The first element is a rotation matrix and\n        the second is the shift.\n    \"\"\"\n    # Partition points\n    logger.info(\"\\tStarting fit of bearing axis\")\n    inside_points, face_points, zero_point, zero_coded = partition_points(dataset)\n    logger.info(\"\\t\\tFound %d points on bearing surface\", len(inside_points))\n    logger.debug(\"\\t\\tZero point is at %s\", str(zero_point))\n\n    # Fit inside of bearing\n    w, c, *_ = cf.fit(inside_points.points)\n    center_line = Line(point=c, direction=w)\n\n    # Fit face of bearing\n    face_plane = Plane.best_fit(face_points.points)\n    origin = face_plane.intersect_line(center_line)\n    shift = ORIGIN - origin\n\n    # Get our basis\n    axis1 = Vector.from_points(origin + shift, center_line.point + shift).unit()\n    axis2 = Vector.from_points(origin + shift, zero_point + shift).unit()\n    axis2_coded = Vector.from_points(origin + shift, zero_coded + shift).unit()\n\n    # Get the transform that aligns us\n    rot, err, *_ = R.align_vectors(\n        np.vstack((axis1, axis2, axis2_coded)), np.vstack((AXIS1, AXIS2, AXIS2_CODED))\n    )\n    logger.info(\"\\t\\tError on bearing axis alignment: %f\", err)\n\n    shift = rot.apply(shift)\n    rot = np.array(rot.as_matrix(), dtype=np.float64).T\n    logger.debug(\"\\t\\tShift is %s mm\", str(shift))\n    logger.debug(\"\\t\\tRotation is %s deg\", str(np.rad2deg(decompose_rotation(rot))))\n\n    coords_transformed = apply_transform(inside_points.points, rot, shift)\n    data = {\n        label: coord for label, coord in zip(inside_points.labels, coords_transformed)\n    }\n\n    return DatasetPhotogrammetry(data), (rot, shift)\n</code></pre>"},{"location":"reference/bearing/#lat_alignment.bearing.partition_points","title":"<code>partition_points(dataset)</code>","text":"<p>Split up dataset into points on the bearing reference surface and inner surface. Also pulls out the bearing zero points.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>DatasetPhotogrammetry</code> <p>Photogrammetry dataset. Should already be aligned to the bearing referance points.</p> required <p>Returns:</p> Name Type Description <code>inside_points</code> <code>DatasetPhotogrammetry</code> <p>Points on the inner surface of the bearing. Only includes targets, codes are removed.</p> <code>face_points</code> <code>DatasetPhotogrammetry</code> <p>Points on face of the bearing that we use as a reference surface. Only includes targets, codes are removed.</p> <code>zero_point</code> <code>NDArray[float64]</code> <p>Array of size (3,) that gives the coordinates of the target we treat as the bearing's zero point.</p> <code>zero_code</code> <code>NDArray[float64]</code> <p>Array of size (3,) that gives the coordinates of the coded target we use to identify the bearing's zero point.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the zero point of the bearing is not found or there are less than four points found on the inner surface or face fo the bearing.</p> Source code in <code>lat_alignment/bearing.py</code> <pre><code>def partition_points(\n    dataset: DatasetPhotogrammetry,\n) -&gt; tuple[\n    DatasetPhotogrammetry,\n    DatasetPhotogrammetry,\n    NDArray[np.float64],\n    NDArray[np.float64],\n]:\n    \"\"\"\n    Split up dataset into points on the bearing reference surface and inner surface.\n    Also pulls out the bearing zero points.\n\n    Parameters\n    ----------\n    dataset : DatasetPhotogrammetry\n        Photogrammetry dataset.\n        Should already be aligned to the bearing referance points.\n\n    Returns\n    -------\n    inside_points : DatasetPhotogrammetry\n        Points on the inner surface of the bearing.\n        Only includes targets, codes are removed.\n    face_points : DatasetPhotogrammetry\n        Points on face of the bearing that we use as a reference surface.\n        Only includes targets, codes are removed.\n    zero_point : NDArray[np.float64]\n        Array of size (3,) that gives the coordinates of the target we treat\n        as the bearing's zero point.\n    zero_code: NDArray[np.float64]\n        Array of size (3,) that gives the coordinates of the coded target we use\n        to identify the bearing's zero point.\n\n    Raises\n    ------\n    ValueError\n        When the zero point of the bearing is not found or there are less than four\n        points found on the inner surface or face fo the bearing.\n    \"\"\"\n    if ZERO_CODE not in dataset.code_labels:\n        raise ValueError(\"Can't find zero point of bearing! Coded target not found!\")\n    zero_coded = dataset[ZERO_CODE]\n    dist = np.linalg.norm(dataset.targets - zero_coded, axis=-1)\n    zero_point = dataset.targets[np.argmin(dist)]\n    if np.min(dist) &gt; 100:\n        raise ValueError(\"Can't find zero point of bearing!\")\n\n    inside_msk = (dataset.targets[:, 1] &gt; ORIGIN[1] - 100) * (\n        dataset.targets[:, 1] &lt; ORIGIN[1] - 10\n    )\n    inside_points = DatasetPhotogrammetry(\n        {\n            l: p\n            for l, p in zip(\n                dataset.target_labels[inside_msk], dataset.targets[inside_msk]\n            )\n        }\n    )\n    if len(inside_points) &lt; 4:\n        raise ValueError(\"Not enough points on inner bearing surface found!\")\n\n    face_origin = np.mean(\n        np.vstack(\n            [\n                dataset[label]\n                for label in [\"CODE91\", \"CODE92\", \"CODE93\", \"CODE94\"]\n                if label in dataset\n            ]\n        ),\n        axis=0,\n    )\n    face_msk = (dataset.points[:, 1] &gt; face_origin[1] - FACE_TOL) * (\n        dataset.points[:, 1] &lt; face_origin[1] + FACE_TOL\n    )\n    face_points = DatasetPhotogrammetry(\n        {l: p for l, p in zip(dataset.labels[face_msk], dataset.points[face_msk])}\n    )\n    if len(face_points) &lt; 4:\n        raise ValueError(\"Not enough points on bearing face surface found!\")\n\n    return inside_points, face_points, zero_point, zero_coded\n</code></pre>"},{"location":"reference/data_alignment/","title":"data_alignment","text":"<p>Functions for aligning datasets to a well defined reference frame.</p>"},{"location":"reference/data_alignment/#lat_alignment.data_alignment.align_photo","title":"<code>align_photo(dataset, reference, kill_refs, element='primary', scale=True, blind_search=-1, *, plot=True, max_dist=100.0, rms_thresh=1.0)</code>","text":"<p>Align photogrammetry data and then put it into mirror coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>DatasetPhotogrammetry</code> <p>The photogrammetry data to align.</p> required <code>reference</code> <code>dict</code> <p>Reference dictionary. Should contain a key called <code>coords</code> that specifies the coordinate system that the reference points are in. The rest of the keys should be optical elements (ie: \"primary\") pointing to a list of reference points to use. Each point given should be a tuple with two elements. The first element is a tuple with the (x, y, z) coordinates of the point in the global coordinate system. The second is a list of nearby coded targets that can be used to identify the point. Each item in the list of coded targets should be a tuple containing the label of the code and the (x, y, z) coordinate of the coded target.</p> required <code>kill_refs</code> <code>bool</code> <p>If True remove reference points from the dataset.</p> required <code>element</code> <code>str</code> <p>The element that these points belong to. Should be either: 'primary', 'secondary', 'bearing', 'receiver', or 'all'.</p> <code>'primary'</code> <code>scale</code> <code>bool</code> <p>If True also compute a scale factor from the reference points.</p> <code>True</code> <code>blind_search</code> <code>float</code> <p>Perform a blind search for the reference points. This is not implemented yet...</p> <code>-1</code> <code>plot</code> <code>bool</code> <p>If True show a diagnostic plot of how well the reference points are aligned.</p> <code>True</code> <code>max_dist</code> <code>float</code> <p>Max distance in mm that the reference poing can be from the target point used to locate it.</p> <code>100</code> <code>rms_thresh</code> <code>float</code> <p>RMS is mm above which we will attempt to cut points.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>aligned</code> <code>DatasetPhotogrammetry</code> <p>The photogrammetry data aligned to the reference points.</p> <code>alignment</code> <code>tuple[NDArray[float64], NDArray[float64]]</code> <p>The transformation that aligned the points. The first element is a rotation matrix and the second is the shift.</p> Source code in <code>lat_alignment/data_alignment.py</code> <pre><code>def align_photo(\n    dataset: DatasetPhotogrammetry,\n    reference: dict,\n    kill_refs: bool,\n    element: str = \"primary\",\n    scale: bool = True,\n    blind_search: float = -1,\n    *,\n    plot: bool = True,\n    max_dist: float = 100.0,\n    rms_thresh: float = 1.0,\n) -&gt; tuple[\n    DatasetPhotogrammetry,\n    tuple[NDArray[np.float64], NDArray[np.float64]],\n]:\n    \"\"\"\n    Align photogrammetry data and then put it into mirror coordinates.\n\n    Parameters\n    ----------\n    dataset : DatasetPhotogrammetry\n        The photogrammetry data to align.\n    reference : dict\n        Reference dictionary.\n        Should contain a key called `coords` that specifies the\n        coordinate system that the reference points are in.\n        The rest of the keys should be optical elements (ie: \"primary\")\n        pointing to a list of reference points to use.\n        Each point given should be a tuple with two elements.\n        The first element is a tuple with the (x, y, z) coordinates\n        of the point in the global coordinate system.\n        The second is a list of nearby coded targets that can be used\n        to identify the point.\n        Each item in the list of coded targets should be a tuple containing\n        the label of the code and the (x, y, z) coordinate of the coded target.\n    kill_refs : bool\n        If True remove reference points from the dataset.\n    element : str, default: 'primary'\n        The element that these points belong to.\n        Should be either: 'primary', 'secondary', 'bearing', 'receiver', or 'all'.\n    scale : bool, default: True\n        If True also compute a scale factor from the reference points.\n    blind_search : float, default: -1\n        Perform a blind search for the reference points.\n        This is not implemented yet...\n    plot : bool, default: True\n        If True show a diagnostic plot of how well the reference points\n        are aligned.\n    max_dist : float, default: 100\n        Max distance in mm that the reference poing can be from the target\n        point used to locate it.\n    rms_thresh : float, default: 1\n        RMS is mm above which we will attempt to cut points.\n\n    Returns\n    -------\n    aligned : DatasetPhotogrammetry\n        The photogrammetry data aligned to the reference points.\n    alignment : tuple[NDArray[np.float64], NDArray[np.float64]]\n        The transformation that aligned the points.\n        The first element is a rotation matrix and\n        the second is the shift.\n    \"\"\"\n    logger.info(\"\\tAligning with reference points for %s\", element)\n    elements = [\"primary\", \"secondary\", \"bearing\", \"receiver\"]\n    # import ipdb; ipdb.set_trace()\n    if element not in elements and element != \"all\":\n        raise ValueError(f\"Invalid element: {element}\")\n    if len(reference) == 0:\n        raise ValueError(\"Invalid or empty reference\")\n    if element not in reference and element != \"all\":\n        raise ValueError(\"Element not found in reference dict\")\n    if \"coords\" not in reference:\n        raise ValueError(\"Reference coordinate system not specified\")\n    if element == \"primary\":\n        transform = partial(\n            coord_transform, cfrom=reference[\"coords\"], cto=\"opt_primary\"\n        )\n    elif element == \"secondary\":\n        transform = partial(\n            coord_transform, cfrom=reference[\"coords\"], cto=\"opt_secondary\"\n        )\n    else:\n        transform = partial(\n            coord_transform, cfrom=reference[\"coords\"], cto=\"opt_global\"\n        )\n    if element == \"all\":\n        all_refs = {}\n        for el in elements:\n            if el not in reference:\n                continue\n            all_refs = all_refs | reference[el]\n        reference[\"all\"] = all_refs\n\n    # Lets find the points we can use\n    ref = []\n    pts = []\n    invars = []\n    ref_coded = []\n    found_coded = []\n    logger.info(\"Looking for reference points\")\n    for pname, (rpoint, codes) in reference[element].items():\n        logger.info(\"\\tFinding point %s\", pname)\n        code_l = np.array([l for l, _ in codes])\n        code_p = np.array([p for _, p in codes])\n        have = np.isin(code_l, dataset.code_labels)\n        logger.info(\"\\t\\tFound %d associated codes\", np.sum(have))\n        if np.sum(have) == 0:\n            continue\n        # Save the coded we have just in case\n        ref_coded += [code_p[have]]\n        found_coded += [dataset[l] for l in code_l[have]]\n\n        # Use the first found coded as reference\n        coded = dataset[code_l[have][0]]\n        # Find the closest point\n        dist = np.linalg.norm(dataset.targets - coded, axis=-1)\n        if np.min(dist) &gt; max_dist:\n            logger.warning(\"\\t\\tFailed to find point %s\", pname)\n            continue\n        label = dataset.target_labels[np.argmin(dist)]\n        ref += [rpoint]\n        pts += [dataset[label]]\n        invars += [label]\n        logger.info(\"\\t\\tAssociated %s with %s\", label, pname)\n    if blind_search &gt; 0:\n        raise NotImplementedError(\"Blind search not implemented yet!\")\n    # Set 12\n    # ref = [rpoint for rpoint, _ in reference[element]]\n    # ref = np.array(ref)[[True, True, False, True]]\n    # invars = [\"TARGET35\", \"TARGET4\", \"TARGET484\"] #, \"TARGET421\"]\n    # pts = [dataset[label] for label in invars]\n    # print(invars)\n    if len(ref) &lt; 3:\n        logger.warning(f\"Only {len(ref)} reference points found!\")\n        logger.warning(f\"Adding reference codes\")\n        pts += found_coded\n        ref += ref_coded\n    if len(ref) &lt; 3:\n        raise ValueError(\n            f\"Only {len(ref)} reference points found including codes! Can't align!\"\n        )\n    logger.debug(\n        \"\\t\\tFound %d reference points in measurements with labels:\\n\\t\\t\\t%s\",\n        len(pts),\n        str(invars),\n    )\n    pts = np.vstack(pts)\n    ref = np.vstack(ref)\n    pts = np.vstack((pts, np.mean(pts, 0)))\n    ref = np.vstack((ref, np.mean(ref, 0)))\n    ref = transform(ref)\n    logger.debug(\"\\t\\tReference points in element coords:\\n%s\", str(ref))\n\n    msk = np.ones(len(ref), bool)\n    scale_fac = 1\n    rot = None\n    sft = None\n    rms = np.inf\n    for _ in range(len(ref) - 4):\n        rot, sft = get_rigid(pts[msk], ref[msk], method=\"mean\")\n        if scale:\n            triu_idx = np.triu_indices(len(pts[msk]), 1)\n            scale_fac = np.nanmedian(\n                make_edm(ref[msk])[triu_idx] / make_edm(pts[msk])[triu_idx]\n            )\n        pts_scaled = pts * scale_fac\n        logger.debug(\"\\t\\tScale factor of %f applied\", scale_fac)\n\n        new_rot, new_sft = get_rigid(pts_scaled[msk], ref[msk], method=\"mean\")\n        pts_t = apply_transform(pts_scaled[msk], new_rot, new_sft)\n        if plot:\n            fig = plt.figure()\n            ax = fig.add_subplot(projection=\"3d\")\n            ax.scatter(pts[:, 0], pts[:, 1], pts[:, 2], color=\"g\")\n            ax.scatter(pts_t[:, 0], pts_t[:, 1], pts_t[:, 2], color=\"b\")\n            ax.scatter(ref[:, 0], ref[:, 1], ref[:, 2], color=\"r\", marker=\"X\")\n            plt.show()\n        diff = pts_t - ref[msk]\n        new_rms = np.sqrt(np.mean((diff) ** 2))\n        diff = np.linalg.norm(diff, axis=1)\n        if new_rms &gt; rms:\n            logger.info(\"\\t\\tNew RMS is worse, accepting last try\")\n            break\n        rms = new_rms\n        rot = new_rot\n        sft = new_sft\n        logger.info(\n            \"\\t\\tRMS of reference points after alignment: %f\",\n            rms,\n        )\n        if rms &lt;= rms_thresh:\n            break\n        logger.info(\"\\t\\tRMS over thresh, trying cutting worst point\")\n        to_cut = np.argmax(np.abs(diff))\n        _msk = msk[msk].copy()\n        _msk[to_cut] = False\n        msk[msk] = _msk\n\n    if rot is None or sft is None:\n        raise ValueError(\"Transformation is None\")\n\n    coords_transformed = apply_transform(dataset.points * scale_fac, rot, sft)\n    labels = dataset.labels\n\n    if kill_refs:\n        msk = ~np.isin(dataset.labels, invars)\n        labels = labels[msk]\n        coords_transformed = coords_transformed[msk]\n\n    data = {label: coord for label, coord in zip(labels, coords_transformed)}\n    transformed = DatasetPhotogrammetry(data)\n\n    logger.debug(\"\\t\\tShift is %s mm\", str(sft))\n    logger.debug(\"\\t\\tRotation is %s deg\", str(np.rad2deg(decompose_rotation(rot))))\n    scale_fac = np.eye(3) * scale_fac\n    rot @= scale_fac\n\n    if plot:\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=\"3d\")\n        ax.scatter(\n            transformed.targets[:, 0],\n            transformed.targets[:, 1],\n            transformed.targets[:, 2],\n            marker=\"x\",\n        )\n        plt.show()\n\n    return transformed, (rot, sft)\n</code></pre>"},{"location":"reference/data_alignment/#lat_alignment.data_alignment.align_tracker","title":"<code>align_tracker(dataset, tracker_yaml, element='primary', scale=True, *, plot=True)</code>","text":"<p>Align photogrammetry data and then put it into mirror coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The photogrammetry data to align.</p> required <code>tracker_yaml</code> <code>str</code> <p>The path to the yaml file with measuerments of the reference points.</p> required <code>element</code> <code>str</code> <p>The element that these points belong to. Should be either: 'primary', 'secondary', 'bearing', 'receiver', or 'all'.</p> <code>'primary'</code> <code>scale</code> <code>bool</code> <p>If True also compute a scale factor from the reference points.</p> <code>True</code> <code>plot</code> <code>bool</code> <p>If True show a diagnostic plot of how well the reference points are aligned.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>aligned</code> <code>Dataset</code> <p>The data aligned to the reference points.</p> <code>alignment</code> <code>tuple[NDArray[float64], NDArray[float64]]</code> <p>The transformation that aligned the points. The first element is a rotation matrix and the second is the shift.</p> Source code in <code>lat_alignment/data_alignment.py</code> <pre><code>def align_tracker(\n    dataset: Dataset,\n    tracker_yaml: str,\n    element: str = \"primary\",\n    scale: bool = True,\n    *,\n    plot: bool = True,\n) -&gt; tuple[\n    Dataset,\n    tuple[NDArray[np.float64], NDArray[np.float64]],\n]:\n    \"\"\"\n    Align photogrammetry data and then put it into mirror coordinates.\n\n    Parameters\n    ----------\n    dataset : Dataset\n        The photogrammetry data to align.\n    tracker_yaml : str\n        The path to the yaml file with measuerments of the reference points.\n    element : str, default: 'primary'\n        The element that these points belong to.\n        Should be either: 'primary', 'secondary', 'bearing', 'receiver', or 'all'.\n    scale : bool, default: True\n        If True also compute a scale factor from the reference points.\n    plot : bool, default: True\n        If True show a diagnostic plot of how well the reference points\n        are aligned.\n\n    Returns\n    -------\n    aligned : Dataset\n        The data aligned to the reference points.\n    alignment : tuple[NDArray[np.float64], NDArray[np.float64]]\n        The transformation that aligned the points.\n        The first element is a rotation matrix and\n        the second is the shift.\n    \"\"\"\n    logger.info(\"\\tAligning with reference points for %s\", element)\n    elements = [\"primary\", \"secondary\", \"bearing\", \"receiver\"]\n    if element not in elements and element != \"all\":\n        raise ValueError(f\"Invalid element: {element}\")\n    reference = cast(DatasetReference, io.load_tracker(tracker_yaml))\n    if len(reference) == 0:\n        raise ValueError(\"Invalid or empty reference\")\n    if element not in reference.elem_names and element != \"all\":\n        raise ValueError(\"Element not found in reference dict\")\n    if element == \"primary\":\n        transform = partial(coord_transform, cfrom=\"opt_global\", cto=\"opt_primary\")\n    elif element == \"secondary\":\n        transform = partial(coord_transform, cfrom=\"opt_global\", cto=\"opt_secondary\")\n    else:\n        transform = partial(coord_transform, cfrom=\"opt_global\", cto=\"opt_global\")\n    if element == \"all\":\n        for el in elements:\n            if el not in reference.elem_names:\n                continue\n            for pt in reference.elem_labels[el]:\n                reference[f\"all_{pt}\"] = reference[pt]\n                reference[f\"all_{pt}_err\"] = reference[f\"{pt}_err\"]\n                reference[f\"all_{pt}_ref\"] = reference[f\"{pt}_ref\"]\n\n    # Lets find the points we can use\n    pts = reference.elements[element]\n    ref = reference.reference[element]\n    if len(ref) &lt; 3:\n        raise ValueError(f\"Only {len(ref)} reference points found! Can't align!\")\n    ref = transform(ref)\n    logger.debug(\"\\t\\tReference points in element coords:\\n%s\", str(ref))\n\n    msk = np.ones(len(ref), bool)\n    scale_fac = 1\n    rot = None\n    sft = None\n    rot, sft = get_rigid(pts[msk], ref[msk], method=\"mean\")\n    if scale:\n        triu_idx = np.triu_indices(len(pts[msk]), 1)\n        scale_fac = np.nanmedian(\n            make_edm(ref[msk])[triu_idx] / make_edm(pts[msk])[triu_idx]\n        )\n    pts_scaled = pts * scale_fac\n    logger.debug(\"\\t\\tScale factor of %f applied\", scale_fac)\n\n    new_rot, new_sft = get_rigid(pts_scaled[msk], ref[msk], method=\"mean\")\n    pts_t = apply_transform(pts_scaled[msk], new_rot, new_sft)\n    if plot:\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=\"3d\")\n        ax.scatter(pts[:, 0], pts[:, 1], pts[:, 2], color=\"g\")\n        ax.scatter(pts_t[:, 0], pts_t[:, 1], pts_t[:, 2], color=\"b\")\n        ax.scatter(ref[:, 0], ref[:, 1], ref[:, 2], color=\"r\", marker=\"X\")\n        plt.show()\n    diff = pts_t - ref[msk]\n    rms = np.sqrt(np.mean((diff) ** 2))\n    logger.info(\n        \"\\t\\tRMS of reference points after alignment: %f\",\n        rms,\n    )\n\n    coords_transformed = apply_transform(dataset.points * scale_fac, rot, sft)\n    labels = dataset.labels\n\n    data = {label: coord for label, coord in zip(labels, coords_transformed)}\n    transformed = Dataset(data)\n\n    logger.debug(\"\\t\\tShift is %s mm\", str(sft))\n    logger.debug(\"\\t\\tRotation is %s deg\", str(np.rad2deg(decompose_rotation(rot))))\n    scale_fac = np.eye(3) * scale_fac\n    rot @= scale_fac\n\n    if plot:\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=\"3d\")\n        ax.scatter(\n            transformed.targets[:, 0],\n            transformed.targets[:, 1],\n            transformed.targets[:, 2],\n            marker=\"x\",\n        )\n        plt.show()\n\n    return transformed, (rot, sft)\n</code></pre>"},{"location":"reference/dataset/","title":"dataset","text":"<p>Dataclasses for storing datasets.</p>"},{"location":"reference/dataset/#lat_alignment.dataset.Dataset","title":"<code>Dataset</code>  <code>dataclass</code>","text":"<p>Container class for photogrammetry and laser tracker dataset. Provides a dict like interface for accessing points by their labels.</p> <p>Attributes:</p> Name Type Description <code>data_dict</code> <code>dict[str, NDArray[float64]]</code> <p>Dict of data points. You should genrally not touch this directly.</p> Source code in <code>lat_alignment/dataset.py</code> <pre><code>@dataclass\nclass Dataset:\n    \"\"\"\n    Container class for photogrammetry and laser tracker dataset.\n    Provides a dict like interface for accessing points by their labels.\n\n    Attributes\n    ----------\n    data_dict : dict[str, NDArray[np.float64]]\n        Dict of data points.\n        You should genrally not touch this directly.\n    \"\"\"\n\n    data_dict: dict[str, NDArray[np.float64]]\n\n    def _clear_cache(self):\n        self.__dict__.pop(\"points\", None)\n        self.__dict__.pop(\"labels\", None)\n        self.__dict__.pop(\"target\", None)\n        self.__dict__.pop(\"target_labels\", None)\n\n    def __setattr__(self, name, value):\n        if name == \"data_dict\":\n            self._clear_cache()\n        return super().__setattr__(name, value)\n\n    def __setitem__(self, key, item):\n        self._clear_cache()\n        self.data_dict[key] = item\n\n    def __getitem__(self, key):\n        return self.data_dict[key]\n\n    def __repr__(self):\n        return repr(self.data_dict)\n\n    def __len__(self):\n        return len(self.data_dict)\n\n    def __delitem__(self, key):\n        self._clear_cache()\n        del self.data_dict[key]\n\n    def __contains__(self, item):\n        return item in self.data_dict\n\n    def __iter__(self):\n        return iter(self.data_dict)\n\n    @cached_property\n    def points(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get all points in the dataset as an array.\n        This is cached.\n        \"\"\"\n        return np.array(list(self.data_dict.values()))\n\n    @cached_property\n    def labels(self) -&gt; NDArray[np.str_]:\n        \"\"\"\n        Get all labels in the dataset as an array.\n        This is cached.\n        \"\"\"\n        return np.array(list(self.data_dict.keys()))\n\n    @cached_property\n    def targets(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get all target points in the dataset as an array.\n        This is cached.\n        \"\"\"\n        msk = np.char.find(self.labels, \"TARGET\") &gt;= 0\n        return self.points[msk]\n\n    @cached_property\n    def target_labels(self) -&gt; NDArray[np.str_]:\n        \"\"\"\n        Get all target labels in the dataset as an array.\n        This is cached.\n        \"\"\"\n        msk = np.char.find(self.labels, \"TARGET\") &gt;= 0\n        return self.labels[msk]\n\n    def copy(self) -&gt; Self:\n        \"\"\"\n        Make a deep copy of the dataset.\n\n        Returns\n        -------\n        copy : Dataset\n            A deep copy of this dataset.\n        \"\"\"\n        return deepcopy(self)\n</code></pre>"},{"location":"reference/dataset/#lat_alignment.dataset.Dataset.labels","title":"<code>labels</code>  <code>cached</code> <code>property</code>","text":"<p>Get all labels in the dataset as an array. This is cached.</p>"},{"location":"reference/dataset/#lat_alignment.dataset.Dataset.points","title":"<code>points</code>  <code>cached</code> <code>property</code>","text":"<p>Get all points in the dataset as an array. This is cached.</p>"},{"location":"reference/dataset/#lat_alignment.dataset.Dataset.target_labels","title":"<code>target_labels</code>  <code>cached</code> <code>property</code>","text":"<p>Get all target labels in the dataset as an array. This is cached.</p>"},{"location":"reference/dataset/#lat_alignment.dataset.Dataset.targets","title":"<code>targets</code>  <code>cached</code> <code>property</code>","text":"<p>Get all target points in the dataset as an array. This is cached.</p>"},{"location":"reference/dataset/#lat_alignment.dataset.Dataset.copy","title":"<code>copy()</code>","text":"<p>Make a deep copy of the dataset.</p> <p>Returns:</p> Name Type Description <code>copy</code> <code>Dataset</code> <p>A deep copy of this dataset.</p> Source code in <code>lat_alignment/dataset.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"\n    Make a deep copy of the dataset.\n\n    Returns\n    -------\n    copy : Dataset\n        A deep copy of this dataset.\n    \"\"\"\n    return deepcopy(self)\n</code></pre>"},{"location":"reference/dataset/#lat_alignment.dataset.DatasetPhotogrammetry","title":"<code>DatasetPhotogrammetry</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dataset</code></p> <p>Container class for photogrammetry dataset. Provides a dict like interface for accessing points by their labels.</p> <p>Attributes:</p> Name Type Description <code>data_dict</code> <code>dict[str, NDArray[float64]]</code> <p>Dict of photogrammetry points. You should genrally not touch this directly.</p> Source code in <code>lat_alignment/dataset.py</code> <pre><code>@dataclass\nclass DatasetPhotogrammetry(Dataset):\n    \"\"\"\n    Container class for photogrammetry dataset.\n    Provides a dict like interface for accessing points by their labels.\n\n    Attributes\n    ----------\n    data_dict : dict[str, NDArray[np.float64]]\n        Dict of photogrammetry points.\n        You should genrally not touch this directly.\n    \"\"\"\n\n    def _clear_cache(self):\n        self.__dict__.pop(\"points\", None)\n        self.__dict__.pop(\"labels\", None)\n        self.__dict__.pop(\"codes\", None)\n        self.__dict__.pop(\"code_labels\", None)\n        self.__dict__.pop(\"target\", None)\n        self.__dict__.pop(\"target_labels\", None)\n\n    def __setattr__(self, name, value):\n        if name == \"data_dict\":\n            self._clear_cache()\n        return super().__setattr__(name, value)\n\n    @cached_property\n    def codes(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get all coded points in the dataset as an array.\n        This is cached.\n        \"\"\"\n        msk = np.char.find(self.labels, \"CODE\") &gt;= 0\n        return self.points[msk]\n\n    @cached_property\n    def code_labels(self) -&gt; NDArray[np.str_]:\n        \"\"\"\n        Get all coded labels in the dataset as an array.\n        This is cached.\n        \"\"\"\n        msk = np.char.find(self.labels, \"CODE\") &gt;= 0\n        return self.labels[msk]\n\n    def copy(self) -&gt; Self:\n        \"\"\"\n        Make a deep copy of the dataset.\n\n        Returns\n        -------\n        copy : Dataset\n            A deep copy of this dataset.\n        \"\"\"\n        return deepcopy(self)\n</code></pre>"},{"location":"reference/dataset/#lat_alignment.dataset.DatasetPhotogrammetry.code_labels","title":"<code>code_labels</code>  <code>cached</code> <code>property</code>","text":"<p>Get all coded labels in the dataset as an array. This is cached.</p>"},{"location":"reference/dataset/#lat_alignment.dataset.DatasetPhotogrammetry.codes","title":"<code>codes</code>  <code>cached</code> <code>property</code>","text":"<p>Get all coded points in the dataset as an array. This is cached.</p>"},{"location":"reference/dataset/#lat_alignment.dataset.DatasetPhotogrammetry.copy","title":"<code>copy()</code>","text":"<p>Make a deep copy of the dataset.</p> <p>Returns:</p> Name Type Description <code>copy</code> <code>Dataset</code> <p>A deep copy of this dataset.</p> Source code in <code>lat_alignment/dataset.py</code> <pre><code>def copy(self) -&gt; Self:\n    \"\"\"\n    Make a deep copy of the dataset.\n\n    Returns\n    -------\n    copy : Dataset\n        A deep copy of this dataset.\n    \"\"\"\n    return deepcopy(self)\n</code></pre>"},{"location":"reference/dataset/#lat_alignment.dataset.DatasetReference","title":"<code>DatasetReference</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Dataset</code></p> <p>Container class for dataset that only contains reference points and their errors. Provides a dict like interface for accessing points by their labels. Note that this class doesn't cover edge cases from misuse, use at your own risk.</p> <p>Attributes:</p> Name Type Description <code>data_dict</code> <code>dict[str, NDArray[float64]]</code> <p>Dict of data points. You should genrally not touch this directly.</p> Source code in <code>lat_alignment/dataset.py</code> <pre><code>@dataclass\nclass DatasetReference(Dataset):\n    \"\"\"\n    Container class for dataset that only contains reference points and their errors.\n    Provides a dict like interface for accessing points by their labels.\n    Note that this class doesn't cover edge cases from misuse, use at your own risk.\n\n    Attributes\n    ----------\n    data_dict : dict[str, NDArray[np.float64]]\n        Dict of data points.\n        You should genrally not touch this directly.\n    \"\"\"\n\n    def _clear_cache(self):\n        self.__dict__.pop(\"points\", None)\n        self.__dict__.pop(\"labels\", None)\n        self.__dict__.pop(\"elem_names\", None)\n        self.__dict__.pop(\"elem_labels\", None)\n        self.__dict__.pop(\"ref_labels\", None)\n        self.__dict__.pop(\"err_labels\", None)\n        self.__dict__.pop(\"elements\", None)\n        self.__dict__.pop(\"reference\", None)\n        self.__dict__.pop(\"errors\", None)\n\n    def __setattr__(self, name, value):\n        if name == \"data_dict\":\n            self._clear_cache()\n        return super().__setattr__(name, value)\n\n    def __setitem__(self, key, item):\n        if key in self.elem_names:\n            if item.shape != self.elements[key].shape:\n                raise ValueError(\n                    \"Can't set {key} with shape {item.shape} when original shape is {self.elements[key]}\"\n                )\n            for i, l in enumerate(self.elem_labels[key]):\n                self.data_dict[l] = item[i]\n        elif key[:-4] in self.elem_names and \"_ref\" in key:\n            if item.shape != self.reference[key[:-4]].shape:\n                raise ValueError(\n                    \"Can't set {key} with shape {item.shape} when original shape is {self.reference[key]}\"\n                )\n            for i, l in enumerate(self.ref_labels[key[:-4]]):\n                self.data_dict[l] = item[i]\n        elif key[:-4] in self.elem_names and \"_err\" in key:\n            if item.shape != self.errors[key[:-4]].shape:\n                raise ValueError(\n                    \"Can't set {key} with shape {item.shape} when original shape is {self.error[key]}\"\n                )\n            for i, l in enumerate(self.err_labels[key[:-4]]):\n                self.data_dict[l] = item[i]\n        else:\n            self.data_dict[key] = item\n        self._clear_cache()\n\n    @cached_property\n    def elem_names(self) -&gt; list[str]:\n        return np.unique([k.split(\"_\")[0] for k in self.labels]).tolist()\n\n    @cached_property\n    def elem_labels(self) -&gt; dict[str, list[str]]:\n        return {\n            e: [\n                k\n                for k in self.labels\n                if (e in k and k[-4:] != \"_ref\" and k[-4:] != \"_err\")\n            ]\n            for e in self.elem_names\n        }\n\n    @cached_property\n    def elements(self) -&gt; dict[str, NDArray[np.float64]]:\n        return {\n            e: np.array([self.data_dict[k] for k in self.elem_labels[e]])\n            for e in self.elem_names\n        }\n\n    @cached_property\n    def ref_labels(self) -&gt; dict[str, list[str]]:\n        return {\n            e: [k for k in self.labels if (e in k and k[-4:] == \"_ref\")]\n            for e in self.elem_names\n        }\n\n    @cached_property\n    def reference(self) -&gt; dict[str, NDArray[np.float64]]:\n        return {\n            e: np.array([self.data_dict[k] for k in self.ref_labels[e]])\n            for e in self.elem_names\n        }\n\n    @cached_property\n    def err_labels(self) -&gt; dict[str, list[str]]:\n        return {\n            e: [k for k in self.labels if (e in k and k[-4:] == \"_err\")]\n            for e in self.elem_names\n        }\n\n    @cached_property\n    def errors(self) -&gt; dict[str, NDArray[np.float64]]:\n        return {\n            e: np.array([self.data_dict[k] for k in self.err_labels[e]])\n            for e in self.elem_names\n        }\n</code></pre>"},{"location":"reference/error/","title":"error","text":"<p>Script for calculating HWFE and pointing error. Also tells you how to move whatever elements are included.</p>"},{"location":"reference/error/#lat_alignment.error.get_hwfe","title":"<code>get_hwfe(data, get_transform, add_err=False)</code>","text":"<p>Get the HWFE errors based on the mirror and receiver positions. This calculation is from Parshely et al.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DatasetReference</code> <p>This dataset must at least contain the primary mirror.</p> required <code>get_transform</code> <code>Callable[[NDArray[float64], NDArray[float64]], tuple[NDArray[float64], NDArray[float64]]]</code> <p>Function that takes in two point clouds and returns an affine matrix and a shift to align them.</p> required <code>add_err</code> <code>bool</code> <p>If True add the error term to the data.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>hwfe</code> <code>float</code> <p>The HWFE in um-rms.</p> Source code in <code>lat_alignment/error.py</code> <pre><code>def get_hwfe(\n    data: DatasetReference,\n    get_transform: Callable[\n        [NDArray[np.float64], NDArray[np.float64]],\n        tuple[NDArray[np.float64], NDArray[np.float64]],\n    ],\n    add_err: bool = False,\n) -&gt; float:\n    \"\"\"\n    Get the HWFE errors based on the mirror and receiver positions.\n    This calculation is from Parshely et al.\n\n    Parameters\n    ----------\n    data : DatasetReference\n        This dataset must at least contain the primary mirror.\n    get_transform : Callable[[NDArray[np.float64], NDArray[np.float64]], tuple[NDArray[np.float64], NDArray[np.float64]]]\n        Function that takes in two point clouds and returns an affine matrix and a shift to align them.\n    add_err : bool, default: False\n        If True add the error term to the data.\n\n    Returns\n    -------\n    hwfe : float\n        The HWFE in um-rms.\n    \"\"\"\n    # Put everything in M1 coordinates\n    data_m1 = data.copy()\n    for element in elements:\n        dat = np.array(data_m1.elements[element], np.float64)\n        if add_err:\n            dat += np.nan_to_num(data_m1.errors[element])\n        data_m1[element] = coord_transform(dat, \"opt_global\", \"opt_primary\")\n        data_m1[f\"{element}_ref\"] = coord_transform(\n            data_m1.reference[element], \"opt_global\", \"opt_primary\"\n        )\n\n    # Transform for M1 perfect\n    aff_m1, sft_m1 = get_transform(\n        data_m1.elements[\"primary\"],\n        data_m1.reference[\"primary\"],\n    )\n\n    hwfe = 0\n    for element in hwfe_factors.keys():\n        src = data_m1.elements[element]\n        dst = data_m1.reference[element]\n\n        # Apply the transform to align M1\n        src = apply_transform(src, aff_m1, sft_m1)\n\n        # Get the new transform\n        aff, sft = get_transform(src, dst)\n        _, _, rot = decompose_affine(aff)\n        rot = decompose_rotation(rot)\n\n        # compute HWFE\n        vals = np.hstack([sft * mm_to_um, rot * rad_to_arcsec]).ravel()\n        hwfe += float(np.sum((np.array(hwfe_factors[element]) * vals) ** 2))\n    return np.sqrt(hwfe)\n</code></pre>"},{"location":"reference/error/#lat_alignment.error.get_pointing_error","title":"<code>get_pointing_error(data, get_transform, add_err=False, thresh=0.01)</code>","text":"<p>Get the pointing error based on the mirror and receiver positions.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DatasetReference</code> <p>Dataset of measured reference points.</p> required <code>get_transform</code> <code>Callable[[NDArray[float64], NDArray[float64]], tuple[NDArray[float64], NDArray[float64]]]</code> <p>Function that takes in two point clouds and returns an affine matrix and a shift to align them.</p> required <code>add_err</code> <code>bool</code> <p>If True add the error term to the data.</p> <code>False</code> <code>thresh</code> <code>float</code> <p>The threshold in arcsecs to discard a rotation.</p> <code>.01</code> <p>Returns:</p> Name Type Description <code>pe</code> <code>float</code> <p>The pointing error in arcsecs.</p> Source code in <code>lat_alignment/error.py</code> <pre><code>def get_pointing_error(\n    data: DatasetReference,\n    get_transform: Callable[\n        [NDArray[np.float64], NDArray[np.float64]],\n        tuple[NDArray[np.float64], NDArray[np.float64]],\n    ],\n    add_err: bool = False,\n    thresh: float = 0.01,\n) -&gt; float:\n    \"\"\"\n    Get the pointing error based on the mirror and receiver positions.\n\n    Parameters\n    ----------\n    data : DatasetReference\n        Dataset of measured reference points.\n    get_transform : Callable[[NDArray[np.float64], NDArray[np.float64]], tuple[NDArray[np.float64], NDArray[np.float64]]]\n        Function that takes in two point clouds and returns an affine matrix and a shift to align them.\n    add_err : bool, default: False\n        If True add the error term to the data.\n    thresh : float, default: .01\n        The threshold in arcsecs to discard a rotation.\n\n    Returns\n    -------\n    pe : float\n        The pointing error in arcsecs.\n    \"\"\"\n    thresh = np.deg2rad(thresh / 3600)\n    rots = np.zeros((2, 3))\n    # Get rotations\n    for i, (element, factor) in enumerate([(\"primary\", 1), (\"secondary\", 2)]):\n        src = np.array(data.elements[element])\n        if add_err:\n            src += np.nan_to_num(data.errors[element])\n        # Put things in the local coords\n        src = coord_transform(src, \"opt_global\", f\"opt_{element}\")\n        dst = coord_transform(\n            np.array(data.reference[element]), \"opt_global\", f\"opt_{element}\"\n        )\n        # Get rotation\n        aff, _ = get_transform(src, dst)\n        *_, rot = decompose_affine(aff)\n        rot = decompose_rotation(rot)\n        rot[abs(rot) &lt; thresh] = 0  # Help prevent float errors\n        rot[-1] = 0  # clocking doesn't matter\n        # Put into global coords\n        aff = R.from_euler(\"xyz\", rot, False).as_matrix()\n        aff, _ = affine_basis_transform(\n            aff, np.zeros(3, np.float64), f\"opt_{element}\", \"opt_global\"\n        )\n        *_, rot = decompose_affine(aff)\n        rot = decompose_rotation(rot)\n        rot[abs(rot) &lt; thresh] = 0\n        rots[i] = rot * factor\n    tot_rot = np.linalg.norm(np.sum(rots, 0))\n    return 3600 * np.rad2deg(tot_rot)\n</code></pre>"},{"location":"reference/fitting/","title":"fitting","text":"<p>Functions for fitting against the mirror surface.</p>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_fit","title":"<code>mirror_fit(points, a, compensate=0, to_points=True, **kwargs)</code>","text":"<p>Fit points against the mirror surface. Ideally the points should be in the mirror's local coordinate system.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[floating]</code> <p>Array of points to compare against the mirror. Should have shape (npoint, 3).</p> required <code>a</code> <code>NDArray[floating]</code> <p>Coeffecients of the mirror function. Use a_primary for the primary mirror and a_secondary for the secondary.</p> required <code>compensate</code> <code>float</code> <p>Amount to compensate the mirror surface by. This is useful to model things like the surface traced out by an SMR.</p> <code>0.0</code> <code>to_points</code> <code>bool</code> <p>If True, the transform will be inverted to align the model to the points.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments to pass on to scipy.optimize.minimize.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>transform_pars</code> <code>NDArray[floating]</code> <p>Flattened affine transform and shift, has to be 1d for use with minimizers. Will have shape (12,) where the first 9 elements are the flattened affine transform, and the last 3 are the shift in (x, y, z) applied after the affine transform.</p> <code>rms</code> <code>float</code> <p>The RMS error between the transformed points and the model.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_fit(\n    points: NDArray[np.floating],\n    a: NDArray[np.floating],\n    compensate: float = 0,\n    to_points: bool = True,\n    **kwargs,\n) -&gt; tuple[NDArray[np.floating], float]:\n    \"\"\"\n    Fit points against the mirror surface.\n    Ideally the points should be in the mirror's local coordinate system.\n\n    Parameters\n    ----------\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n    a : NDArray[np.floating]\n        Coeffecients of the mirror function.\n        Use a_primary for the primary mirror and a_secondary for the secondary.\n    compensate : float, default: 0.0\n        Amount to compensate the mirror surface by.\n        This is useful to model things like the surface traced out by an SMR.\n    to_points : bool, default: True\n        If True, the transform will be inverted to align the model to the points.\n    **kwargs\n        Additional arguments to pass on to scipy.optimize.minimize.\n\n    Returns\n    -------\n    transform_pars : NDArray[np.floating]\n        Flattened affine transform and shift, has to be 1d for use with minimizers.\n        Will have shape (12,) where the first 9 elements are the flattened affine transform,\n        and the last 3 are the shift in (x, y, z) applied after the affine transform.\n    rms : float\n        The RMS error between the transformed points and the model.\n    \"\"\"\n\n    def _fit_func(transform_pars, points, a, compensate):\n        points_transformed = mirror_transform(transform_pars, points)\n        chisq = mirror_objective(points_transformed, a, compensate)\n        return chisq\n\n    x0 = np.concatenate((np.eye(3).ravel(), np.zeros(3)))\n    res = opt.minimize(_fit_func, x0, args=(points, a, compensate), **kwargs)\n\n    transform_pars = res.x\n    transformed = mirror_transform(transform_pars, points)\n    z = mr.mirror(transformed[:, 0], transformed[:, 1], a, compensate)\n    rms = np.sqrt(np.mean((z - transformed[:, 2]) ** 2))\n\n    if to_points:\n        aff = transform_pars[:9].reshape((3, 3))\n        sft = transform_pars[9:]\n        aff = np.linalg.inv(aff)\n        sft = (-1 * sft) @ aff\n        transform_pars = np.concatenate((aff.ravel(), sft))\n\n    return transform_pars, rms\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_objective","title":"<code>mirror_objective(points, a, compensate=0)</code>","text":"<p>Objective function to minimize when fitting to mirror surface. Essentially just a curvature weighted chisq.</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>NDArray[floating]</code> <p>Array of points to compare against the mirror. Should have shape (npoint, 3).</p> required <code>a</code> <code>NDArray[floating]</code> <p>Coeffecients of the mirror function. Use a_primary for the primary mirror and a_secondary for the secondary.</p> required <code>compensate</code> <code>float</code> <p>Amount to compensate the mirror surface by. This is useful to model things like the surface traced out by an SMR.</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>chisq</code> <code>float</code> <p>The value to minimize when fitting to.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_objective(\n    points: NDArray[np.floating], a: NDArray[np.floating], compensate: float = 0\n) -&gt; float:\n    \"\"\"\n    Objective function to minimize when fitting to mirror surface.\n    Essentially just a curvature weighted chisq.\n\n    Parameters\n    ----------\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n    a : NDArray[np.floating]\n        Coeffecients of the mirror function.\n        Use a_primary for the primary mirror and a_secondary for the secondary.\n    compensate : float, default: 0.0\n        Amount to compensate the mirror surface by.\n        This is useful to model things like the surface traced out by an SMR.\n\n    Returns\n    -------\n    chisq : float\n        The value to minimize when fitting to.\n    \"\"\"\n    surface = mr.mirror(points[:, 0], points[:, 1], a, compensate)\n    norm = mr.mirror_norm(points[:, 0], points[:, 1], a)\n    res = (points[:, 2] - surface) * (norm[2] ** 2)\n\n    return res @ res.T\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.mirror_transform","title":"<code>mirror_transform(transform_pars, points)</code>","text":"<p>Function to apply an affine transform to the mirror. This is the transform we are fitting for.</p> <p>Parameters:</p> Name Type Description Default <code>transform_pars</code> <code>NDArray[floating]</code> <p>Flattened affine transform and shift, has to be 1d for use with minimizers. Should have shape (12,) where the first 9 elements are the flattened affine transform, and the last 3 are the shift in (x, y, z) applied after the affine transform.</p> required <code>points</code> <code>NDArray[floating]</code> <p>Array of points to compare against the mirror. Should have shape (npoint, 3).</p> required <p>Returns:</p> Name Type Description <code>points_transformed</code> <code>NDArray[floating]</code> <p>Array of transformed points. Will have shape (npoint, 3).</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def mirror_transform(\n    transform_pars: NDArray[np.floating], points: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Function to apply an affine transform to the mirror.\n    This is the transform we are fitting for.\n\n    Parameters\n    ----------\n    transform_pars : NDArray[np.floating]\n        Flattened affine transform and shift, has to be 1d for use with minimizers.\n        Should have shape (12,) where the first 9 elements are the flattened affine transform,\n        and the last 3 are the shift in (x, y, z) applied after the affine transform.\n    points : NDArray[np.floating]\n        Array of points to compare against the mirror.\n        Should have shape (npoint, 3).\n\n    Returns\n    -------\n    points_transformed : NDArray[np.floating]\n        Array of transformed points.\n        Will have shape (npoint, 3).\n    \"\"\"\n    aff = transform_pars[:9].reshape((3, 3))\n    sft = transform_pars[9:]\n    return points @ aff + sft\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.res_auto_corr","title":"<code>res_auto_corr(residuals)</code>","text":"<p>Compute auto correlation of residuals from fit.</p> <p>Parameters:</p> Name Type Description Default <code>residuals</code> <code>NDArray[floating]</code> <p>Residuals between measured point cloud and fit model.</p> required <p>Returns:</p> Name Type Description <code>ac</code> <code>NDArray[floating]</code> <p>Auto correlation, really just the deviations in mm at each distance scale.</p> <code>ac_dists</code> <code>NDArray[floating]</code> <p>Distance scale of each value in ac.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def res_auto_corr(\n    residuals: NDArray[np.floating],\n) -&gt; tuple[NDArray[np.floating], NDArray[np.floating]]:\n    \"\"\"\n    Compute auto correlation of residuals from fit.\n\n    Parameters\n    ----------\n    residuals : NDArray[np.floating]\n        Residuals between measured point cloud and fit model.\n\n    Returns\n    -------\n    ac : NDArray[np.floating]\n        Auto correlation, really just the deviations in mm at each distance scale.\n    ac_dists : NDArray[np.floating]\n        Distance scale of each value in ac.\n    \"\"\"\n    dists = np.zeros((len(residuals), len(residuals)))\n    res_diff = np.zeros((len(residuals), len(residuals)))\n\n    for i in range(len(residuals)):\n        res1 = residuals[i]\n        for j in range(i):\n            res2 = residuals[j]\n            dist = np.linalg.norm((res1[0] - res2[0], res1[1] - res2[1]))\n            dists[i, j] = dist\n            res_diff[i, j] = abs(res1[2] - res2[2])\n    tri_i = np.tril_indices(len(residuals), k=-1)\n    dists = dists[tri_i]\n    res_diff = res_diff[tri_i]\n    ac, bin_e, _ = binned_statistic(dists, res_diff, bins=100)\n    ac_dists = bin_e[:-1] + np.diff(bin_e) / 2.0\n\n    return ac, ac_dists\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.tension_fit","title":"<code>tension_fit(residuals, **kwargs)</code>","text":"<p>Fit a power law model of tension to a point cloud of residuals.</p> <p>Parameters:</p> Name Type Description Default <code>residuals</code> <code>NDArray[floating]</code> <p>Residuals between measured point cloud and fit model.</p> required <code>**kwargs</code> <p>Arguments to be passed to scipy.optimize.minimize</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tension_pars</code> <code>NDArray[floating]</code> <p>The fit parameters, see docstring of tension_model for details.</p> <code>rms</code> <code>float</code> <p>The rms between the input residuals and the fit model.</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def tension_fit(\n    residuals: NDArray[np.floating], **kwargs\n) -&gt; tuple[NDArray[np.floating], float]:\n    \"\"\"\n    Fit a power law model of tension to a point cloud of residuals.\n\n    Parameters\n    ----------\n    residuals : NDArray[np.floating]\n        Residuals between measured point cloud and fit model.\n    **kwargs\n        Arguments to be passed to scipy.optimize.minimize\n\n    Returns\n    -------\n    tension_pars : NDArray[np.floating]\n        The fit parameters, see docstring of tension_model for details.\n    rms : float\n        The rms between the input residuals and the fit model.\n    \"\"\"\n\n    def min_func(pars, residuals):\n        _z = tension_model(*pars[:5], residuals)\n        return np.sqrt(np.mean((residuals[:, 2] - _z) ** 2))\n\n    if \"bounds\" not in kwargs:\n        ptp = np.ptp(residuals[:, 2])\n        bounds = [\n            (np.min(residuals[:, 0]), np.max(residuals[:, 0])),\n            (np.min(residuals[:, 1]), np.max(residuals[:, 1])),\n            (-1 * ptp, ptp),\n            (1e-10, np.inf),\n            (0, np.inf),\n        ]\n        kwargs[\"bounds\"] = bounds\n    x0 = [np.mean(residuals[:, 0]), np.mean(residuals[:, 1]), 0, 1, 0]\n    res = opt.minimize(min_func, x0, (residuals,), **kwargs)\n    return res.x, res.fun\n</code></pre>"},{"location":"reference/fitting/#lat_alignment.fitting.tension_model","title":"<code>tension_model(x0, y0, t, a, b, points)</code>","text":"<p>Function to model incorrect panel tensioning. Currently the model used is a radial power law.</p> <p>Parameters:</p> Name Type Description Default <code>x0</code> <code>float</code> <p>Center of the power law in x.</p> required <code>y0</code> <code>float</code> <p>Center of the power law in y.</p> required <code>t</code> <code>float.</code> <p>Amplitude of power law, nominally the offset due to tensioning in the center of panel.</p> required <code>a</code> <code>float</code> <p>Base of power law.</p> required <code>b</code> <code>float</code> <p>Exponential scale factor of power law</p> required <code>points</code> <code>NDArray[floating]</code> <p>Points to compute power law at. Only the x and y coordinates are used (first two collumns). So should be (npoint, 2) but (npoint, ndim&gt;2) is also fine.</p> required <p>Returns:</p> Name Type Description <code>z</code> <code>NDArray[floating]</code> <p>Power law model at each xy. Will have shape (npoint,).</p> Source code in <code>lat_alignment/fitting.py</code> <pre><code>def tension_model(\n    x0: float, y0: float, t: float, a: float, b: float, points: NDArray[np.floating]\n) -&gt; NDArray[np.floating]:\n    \"\"\"\n    Function to model incorrect panel tensioning.\n    Currently the model used is a radial power law.\n\n\n    Parameters\n    ----------\n    x0 : float\n        Center of the power law in x.\n    y0 : float\n        Center of the power law in y.\n    t : float.\n        Amplitude of power law,\n        nominally the offset due to tensioning in the center of panel.\n    a : float\n        Base of power law.\n    b : float\n        Exponential scale factor of power law\n    points : NDArray[np.floating]\n        Points to compute power law at.\n        Only the x and y coordinates are used (first two collumns).\n        So should be (npoint, 2) but (npoint, ndim&gt;2) is also fine.\n\n    Returns\n    -------\n    z : NDArray[np.floating]\n        Power law model at each xy.\n        Will have shape (npoint,).\n    \"\"\"\n    # Avoid divide by 0 error\n    if a == 0:\n        return np.zeros(len(points))\n\n    # Compute radius at each point\n    r = np.sqrt((points[:, 0] - x0) ** 2 + (points[:, 1] - y0) ** 2)\n\n    # Return power law\n    return t * (a ** (-b * r))\n</code></pre>"},{"location":"reference/io/","title":"io","text":""},{"location":"reference/io/#lat_alignment.io.load_adjusters","title":"<code>load_adjusters(path, mirror)</code>","text":"<p>Get nominal adjuster locations from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the data file.</p> required <code>mirror</code> <code>str</code> <p>The mirror that these points belong to. Should be either: 'primary' or 'secondary'.</p> <code>'primary'</code> <p>Returns:</p> Name Type Description <code>adjusters</code> <code>dict[tuple[int, int], NDArray[float64]]</code> <p>Nominal adjuster locations. This is indexed by a (row, col) tuple. Each entry is <code>(5, 3)</code> array where each row is an adjuster.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_adjusters(\n    path: str, mirror: str\n) -&gt; dict[tuple[int, int], NDArray[np.float64]]:\n    \"\"\"\n    Get nominal adjuster locations from file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the data file.\n    mirror : str, default: 'primary'\n        The mirror that these points belong to.\n        Should be either: 'primary' or 'secondary'.\n\n    Returns\n    -------\n    adjusters : dict[tuple[int, int], NDArray[np.float64]]\n        Nominal adjuster locations.\n        This is indexed by a (row, col) tuple.\n        Each entry is `(5, 3)` array where each row is an adjuster.\n    \"\"\"\n    if mirror not in [\"primary\", \"secondary\"]:\n        raise ValueError(f\"Invalid mirror: {mirror}\")\n\n    def _transform(coords):\n        coords = np.atleast_2d(coords)\n        coords -= np.array([120, 0, 0])  # cancel out shift\n        return coord_transform(coords, \"va_global\", f\"opt_{mirror}\")\n\n    # TODO: cleaner transform call\n    adjusters = defaultdict(list)\n    c_points = np.genfromtxt(path, dtype=str)\n    for point in c_points:\n        row = point[0][6]\n        col = point[0][7]\n        adjusters[(row, col)] += [_transform(np.array(point[2:], dtype=np.float64))[0]]\n    adjusters = {rc: np.vstack(pts) for rc, pts in adjusters.items()}\n\n    return adjusters\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_corners","title":"<code>load_corners(path)</code>","text":"<p>Get panel corners from file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the data file.</p> required <p>Returns:</p> Name Type Description <code>corners</code> <code>dict[tuple[int, int], ndarray[float64]]</code> <p>The corners. This is indexed by a (row, col) tuple. Each entry is <code>(4, 3)</code> array where each row is a corner.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_corners(path: str) -&gt; dict[tuple[int, int], NDArray[np.float64]]:\n    \"\"\"\n    Get panel corners from file.\n\n    Parameters\n    ----------\n    path : str\n        Path to the data file.\n\n    Returns\n    -------\n    corners : dict[tuple[int, int], ndarray[np.float64]]\n        The corners. This is indexed by a (row, col) tuple.\n        Each entry is `(4, 3)` array where each row is a corner.\n    \"\"\"\n    with open(path) as file:\n        corners_raw = yaml.safe_load(file)\n\n    corners = {\n        (panel[7], panel[9]): np.vstack(\n            [np.array(coord.split(), np.float64) for coord in coords]\n        )\n        for panel, coords in corners_raw.items()\n    }\n    return corners\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_data","title":"<code>load_data(path, source='photo', **kwargs)</code>","text":"<p>Load a dataset from path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the data to load.</p> required <code>source</code> <code>str</code> <p>The data source. Current valid options are:</p> <ul> <li>photo</li> <li>tracker</li> </ul> <code>'photo'</code> <code>**kwargs</code> <p>Arguments to pass the relevent loader function. See <code>load_photo</code> and <code>load_tracker</code> for details.</p> <code>{}</code> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_data(path: str, source: str = \"photo\", **kwargs) -&gt; Dataset:\n    \"\"\"\n    Load a dataset from path.\n\n    Parameters\n    ----------\n    path : str\n        The path to the data to load.\n    source : str, default: 'photo'\n        The data source. Current valid options are:\n\n        * photo\n        * tracker\n    **kwargs\n        Arguments to pass the relevent loader function.\n        See `load_photo` and `load_tracker` for details.\n    \"\"\"\n    if source == \"photo\":\n        return load_photo(path, **kwargs)\n    elif source == \"tracker\":\n        return load_tracker(path)\n    raise ValueError(\"Invalid data source\")\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_photo","title":"<code>load_photo(path, err_thresh=2, doubles_dist=10, plot=True)</code>","text":"<p>Load photogrammetry data. Assuming first column is target names and next three are (x, y , z).</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the photogrammetry data.</p> required <code>err_thresh</code> <code>float</code> <p>How many times the median photogrammetry error a target need to have to be cut.</p> <code>2</code> <code>plot</code> <code>bool</code> <p>If True display a scatter plot of targets.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>data</code> <code>Dataset</code> <p>The photogrammetry data.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_photo(\n    path: str, err_thresh: float = 2, doubles_dist: float = 10, plot: bool = True\n) -&gt; Dataset:\n    \"\"\"\n    Load photogrammetry data.\n    Assuming first column is target names and next three are (x, y , z).\n\n    Parameters\n    ----------\n    path : str\n        The path to the photogrammetry data.\n    err_thresh : float, default: 2\n        How many times the median photogrammetry error\n        a target need to have to be cut.\n    plot: bool, default: True\n        If True display a scatter plot of targets.\n\n    Returns\n    -------\n    data : Dataset\n        The photogrammetry data.\n    \"\"\"\n    logger.info(\"Loading measurement data\")\n    labels = np.genfromtxt(path, dtype=str, delimiter=\",\", usecols=(0,))\n    coords = np.genfromtxt(path, dtype=np.float64, delimiter=\",\", usecols=(1, 2, 3))\n    errs = np.genfromtxt(path, dtype=np.float64, delimiter=\",\", usecols=(4, 5, 6))\n    msk = (np.char.find(labels, \"TARGET\") &gt;= 0) + (np.char.find(labels, \"CODE\") &gt;= 0)\n\n    labels, coords, errs = labels[msk], coords[msk], errs[msk]\n    err = np.linalg.norm(errs, axis=-1)\n    trg_msk = np.char.find(labels, \"TARGET\") &gt;= 0\n    code_msk = np.char.find(labels, \"CODE\") &gt;= 0\n\n    err_msk = (err &lt; err_thresh * np.median(err[trg_msk])) + code_msk\n    labels, coords, err = labels[err_msk], coords[err_msk], err[err_msk]\n    logger.info(\"\\t%d good points loaded\", len(coords))\n    logger.info(\"\\t%d high error points not loaded\", np.sum(~err_msk))\n\n    # Lets find and remove doubles\n    # Dumb brute force\n    trg_msk = np.char.find(labels, \"TARGET\") &gt;= 0\n    edm = make_edm(coords[trg_msk, :2])\n    np.fill_diagonal(edm, np.nan)\n    to_kill = []\n    for i in range(len(edm)):\n        if labels[trg_msk][i] in to_kill:\n            continue\n        imin = np.nanargmin(edm[i])\n        if edm[i][imin] &gt; doubles_dist:\n            continue\n        if err[trg_msk][i] &lt; err[trg_msk][imin]:\n            to_kill += [labels[trg_msk][imin]]\n        else:\n            to_kill += [labels[trg_msk][i]]\n    msk = ~np.isin(labels, to_kill)\n    logger.info(\"\\tFound and removed %d doubles\", len(to_kill))\n    labels, coords = labels[msk], coords[msk]\n\n    if plot:\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=\"3d\")\n        ax.scatter(coords[:, 0], coords[:, 1], coords[:, 2], marker=\"x\")\n        plt.show()\n\n    data = {label: coord for label, coord in zip(labels, coords)}\n    return DatasetPhotogrammetry(data)\n</code></pre>"},{"location":"reference/io/#lat_alignment.io.load_tracker","title":"<code>load_tracker(path)</code>","text":"<p>Load laser tracker data. TODO: This interface needs to be unified with <code>load_photo</code> so all code can use either datatype interchangibly</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the laser tracker data. The type of data will be infered from the extension.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>Dataset</code> <p>The tracker data. For txt or csv files this will be the base <code>Dataset</code> class. For yaml files this will be a <code>DatasetReference</code>.</p> Source code in <code>lat_alignment/io.py</code> <pre><code>def load_tracker(path: str) -&gt; Dataset:\n    \"\"\"\n    Load laser tracker data.\n    TODO: This interface needs to be unified with `load_photo` so all code can use either datatype interchangibly\n\n    Parameters\n    ----------\n    path : str\n        The path to the laser tracker data.\n        The type of data will be infered from the extension.\n\n    Returns\n    -------\n    data : Dataset\n        The tracker data.\n        For txt or csv files this will be the base `Dataset` class.\n        For yaml files this will be a `DatasetReference`.\n    \"\"\"\n    ext = os.path.splitext(path)[1]\n    if ext == \".yaml\":\n        return _load_tracker_yaml(path)\n    elif ext == \".txt\":\n        return _load_tracker_txt(path)\n    elif ext == \".csv\":\n        return _load_tracker_csv(path)\n    raise ValueError(f\"Invalid tracker data with extension {ext}\")\n</code></pre>"},{"location":"reference/ixb/","title":"ixb","text":"<p>Functions for integrating with the Atlas Copco IxB tool</p>"},{"location":"reference/ixb/#lat_alignment.ixb.close","title":"<code>close(sock, send)</code>","text":"<p>Disconnect from the tool.</p> <p>Parameters:</p> Name Type Description Default <code>sock</code> <code>SocketType</code> <p>A socket object connected to the tool.</p> required <code>send</code> <code>Callable[[str], None]</code> <p>A function to send a message to the tool with the connection information prepopulated.</p> required Source code in <code>lat_alignment/ixb.py</code> <pre><code>def close(sock: socket.SocketType, send: Callable[[str], None]):\n    \"\"\"\n    Disconnect from the tool.\n\n    Parameters\n    ----------\n    sock : socket.SocketType\n        A socket object connected to the tool.\n    send : Callable[[str], None]\n        A function to send a message to the tool with\n        the connection information prepopulated.\n    \"\"\"\n    send(MID3)\n    sock.close()\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.connect","title":"<code>connect(host, port=4545, timeout=5, cur_try=0, max_retry=5)</code>","text":"<p>Connect to the open protocol port in the tool.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The IP address of the IxB tool.</p> required <code>port</code> <code>int</code> <p>The port that open protocol is running at.</p> <code>4545</code> <code>timeout</code> <code>float</code> <p>The time in seconds to set the timeout on network operations when communicating.</p> <code>5</code> <code>cur_try</code> <code>int</code> <p>The attempt at connecting we are at.</p> <code>0</code> <code>max_retry</code> <code>int</code> <p>The maximum number of attempts to connect we should try.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>sock</code> <code>SocketType</code> <p>A socket object connected to the tool.</p> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def connect(\n    host: str,\n    port: int = 4545,\n    timeout: float = 5,\n    cur_try: int = 0,\n    max_retry: int = 5,\n) -&gt; socket.SocketType:\n    \"\"\"\n    Connect to the open protocol port in the tool.\n\n    Parameters\n    ----------\n    host : str\n        The IP address of the IxB tool.\n    port : int, default: 4545\n        The port that open protocol is running at.\n    timeout : float, default: 5\n        The time in seconds to set the timeout on\n        network operations when communicating.\n    cur_try : int, default: 0\n        The attempt at connecting we are at.\n    max_retry : int, default: 5\n        The maximum number of attempts to connect we should try.\n\n    Returns\n    -------\n    sock : socket.SocketType\n        A socket object connected to the tool.\n    \"\"\"\n    if cur_try &gt;= max_retry:\n        raise RecursionError(\"Maximum attemps to connect exceeded!\")\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(timeout)\n    try:\n        sock.connect((host, port))\n        return sock\n    except OSError:\n        sock.close()\n        return connect(host, port, cur_try + 1, max_retry)\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.construct_2500","title":"<code>construct_2500(pset, prog)</code>","text":"<p>Construct a message to update a program via MID 2500.</p> <p>Parameters:</p> Name Type Description Default <code>pset</code> <code>int</code> <p>The id of the program to update.</p> required <code>prog</code> <code>dict[str, Any]</code> <p>The program in dict form. This will be dumped to a yaml and sent.</p> required <p>Returns:</p> Name Type Description <code>message</code> <code>str</code> <p>The message to send to the tool.</p> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def construct_2500(pset: int, prog: dict[str, Any]) -&gt; str:\n    \"\"\"\n    Construct a message to update a program via MID 2500.\n\n    Parameters\n    ----------\n    pset : int\n        The id of the program to update.\n    prog : dict[str, Any]\n        The program in dict form.\n        This will be dumped to a yaml and sent.\n\n    Returns\n    -------\n    message : str\n        The message to send to the tool.\n    \"\"\"\n    prog_txt = json.dumps(prog, separators=(\",\", \":\"))\n    info = f\"20100101000004010000000{pset:04}{len(prog_txt):06}\"\n    mid = \"00002500002000000000\"\n    mid += f\"{info}{prog_txt}\"\n    mid = f\"{len(mid):04}\" + mid[4:]\n    return mid\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.construct_2501","title":"<code>construct_2501(pset)</code>","text":"<p>Construct a message to request MID 2501 via MID 0006.</p> <p>Parameters:</p> Name Type Description Default <code>pset</code> <code>int</code> <p>The id of the program you want.</p> required <p>Returns:</p> Name Type Description <code>message</code> <code>str</code> <p>The message to send to the tool.</p> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def construct_2501(pset: int) -&gt; str:\n    \"\"\"\n    Construct a message to request MID 2501 via MID 0006.\n\n    Parameters\n    ----------\n    pset : int\n        The id of the program you want.\n\n    Returns\n    -------\n    message : str\n        The message to send to the tool.\n    \"\"\"\n    mid = f\"003400060010    00  \"\n    mid += f\"250100207{pset:04}2\"\n    return mid\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.decode0002","title":"<code>decode0002(mid, message)</code>","text":"<p>Decode a message from MID 0002.</p> <p>Parameters:</p> Name Type Description Default <code>mid</code> <code>str</code> <p>The MID string. This should be '0002' or '0004'.</p> required <code>message</code> <code>str</code> <p>The data returned by <code>recv</code> after sending MID1.</p> required <p>Returns:</p> Name Type Description <code>rep</code> <code>str</code> <p>A printable string describing the message.</p> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def decode0002(mid, message):\n    \"\"\"\n    Decode a message from MID 0002.\n\n    Parameters\n    ----------\n    mid : str\n        The MID string.\n        This should be '0002' or '0004'.\n    message : str\n        The data returned by `recv` after\n        sending MID1.\n\n    Returns\n    -------\n    rep : str\n        A printable string describing the message.\n    \"\"\"\n    if mid == \"0004\":\n        return decode0004(message)\n    elif mid != \"0002\":\n        raise ValueError(\"Expected MID 0002 or 0004 but got MID \" + mid)\n    rep = f\"Connected to tool {message[10:35]}\"\n    return rep\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.decode0004","title":"<code>decode0004(message)</code>","text":"<p>Decode an error message from MID 0004.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to decode.</p> required <p>Returns:</p> Name Type Description <code>rep</code> <code>str</code> <p>A printable string describing the error.</p> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def decode0004(message: str) -&gt; str:\n    \"\"\"\n    Decode an error message from MID 0004.\n\n    Parameters\n    ----------\n    message : str\n        The message to decode.\n\n    Returns\n    -------\n    rep : str\n        A printable string describing the error.\n    \"\"\"\n    mid = message[:4]\n    err = message[4:]\n    rep = f\"MID {mid} failed with error {err}\"\n    return rep\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.decode0041","title":"<code>decode0041(mid, message)</code>","text":"<p>Decode a message from MID 0041.</p> <p>Parameters:</p> Name Type Description Default <code>mid</code> <code>str</code> <p>The MID string. This should be '0041' or '0004'.</p> required <code>message</code> <code>str</code> <p>The data returned by <code>recv</code> after sending MID40.</p> required <p>Returns:</p> Name Type Description <code>rep</code> <code>str</code> <p>A printable string describing the message.</p> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def decode0041(mid, message):\n    \"\"\"\n    Decode a message from MID 0041.\n\n    Parameters\n    ----------\n    mid : str\n        The MID string.\n        This should be '0041' or '0004'.\n    message : str\n        The data returned by `recv` after\n        sending MID40.\n\n    Returns\n    -------\n    rep : str\n        A printable string describing the message.\n    \"\"\"\n    if mid == \"0004\":\n        return decode0004(message)\n    elif mid != \"0041\":\n        raise ValueError(\"Expected MID 0041 or 0004 but got MID \" + mid)\n    serial = message[:14]\n    tightenings = message[16:26]\n    cal_date = message[28:38]\n    cont_serial = message[49:59]\n    cal = float(message[62:67]) / 100\n    service = message[69:79]\n    tightenings_since = message[91:100]\n    firmware = message[115:134]\n\n    rep = f\"Tool info:\\n\\tSerial: {serial}\\n\\tTotal Tightenings: {tightenings}\\n\\tLast Calibration: {cal_date}\\n\\tController Serial: {cont_serial}\\n\\tCalibration: {cal}\\n\\tLast Service: {service}\\n\\tTightenings Since Service: {tightenings_since}\\n\\tFirmware: {firmware}\"\n    return rep\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.decode2501","title":"<code>decode2501(mid, message)</code>","text":"<p>Decode a message from MID 2501.</p> <p>Parameters:</p> Name Type Description Default <code>mid</code> <code>str</code> <p>The MID string. This should be '2501' or '0004'.</p> required <code>message</code> <code>str</code> <p>The data returned by <code>recv</code> after sending MID2501 via MID6.</p> required <p>Returns:</p> Name Type Description <code>info</code> <code>str</code> <p>If MID 2501 was received then this is the non json info returned. If MID 0004 was received then this is a printable error message.</p> <code>prog</code> <code>dict[str, Any]</code> <p>A dict generated from the json of the program. If MID 0004 was received then an empty dict is returned.</p> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def decode2501(mid, message) -&gt; tuple[str, dict[str, Any]]:\n    \"\"\"\n    Decode a message from MID 2501.\n\n    Parameters\n    ----------\n    mid : str\n        The MID string.\n        This should be '2501' or '0004'.\n    message : str\n        The data returned by `recv` after\n        sending MID2501 via MID6.\n\n    Returns\n    -------\n    info : str\n        If MID 2501 was received then this is the non json info returned.\n        If MID 0004 was received then this is a printable error message.\n    prog : dict[str, Any]\n        A dict generated from the json of the program.\n        If MID 0004 was received then an empty dict is returned.\n    \"\"\"\n    if mid == \"0004\":\n        return decode0004(message), {}\n    elif mid != \"2501\":\n        raise ValueError(\"Expected MID 2501 or 0004 but got MID \" + mid)\n    idx = message.find(\"{\")\n    if idx == -1:\n        raise ValueError(\"JSON not found in MID 2501 response!\")\n    info = message[:idx]\n    info = info[:-6]\n    prog_txt = message[idx:]\n    prog = json.loads(prog_txt)\n\n    return info, prog\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.get_adjs_names","title":"<code>get_adjs_names()</code>","text":"<p>Get the names of the adjusters in the order and format of the programs on the IxB tool.</p> <p>Returns:</p> Name Type Description <code>program_names</code> <code>list[str]</code> <p>The names of the programs in the order they will appear on the tool.</p> <code>part1</code> <code>list[str]</code> <p>The names of the adjusters in rows 1-4 of the mirror.</p> <code>part2</code> <code>list[str]</code> <p>The names of the adjusters in rows 5-9 of the mirror.</p> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def get_adjs_names() -&gt; tuple[list[str], list[str], list[str]]:\n    \"\"\"\n    Get the names of the adjusters in the order and format of the programs\n    on the IxB tool.\n\n    Returns\n    -------\n    program_names : list[str]\n        The names of the programs in the order they will appear on the tool.\n    part1 : list[str]\n        The names of the adjusters in rows 1-4 of the mirror.\n    part2 : list[str]\n        The names of the adjusters in rows 5-9 of the mirror.\n    \"\"\"\n    adjs = []\n    for r in range(1, 10):\n        for c in range(1, 10):\n            for a in range(1, 6):\n                adjs += [f\"P{r}{c}V{a}\"]\n\n    # There is a dumb 250 limit\n    # So we split the mirror into two parts\n    # Part 1 is rows 1-4 and part 2 5-9\n    split = 4 * 9 * 5  # 4 rows * 9 cols * 5 adjusters\n    part1 = adjs[:split].copy()\n    part2 = adjs[split:].copy()\n    adjs = [f\"{p1}_{p2}\" for p1, p2 in zip(part1, part2)] + part2[split:]\n\n    return adjs, part1, part2\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.init","title":"<code>init(host, port, **kwargs)</code>","text":"<p>Connect to the tool and print identifying information. Also generates convenience functions.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The IP address of the IxB tool.</p> required <code>port</code> <code>int</code> <p>The port that open protocol is running at.</p> <code>4545</code> <code>**kwargs</code> <p>Additional arguments to pass to <code>connect</code>.</p> <code>{}</code> <code>Returns</code> required <code>sock</code> <code>SocketType</code> <p>A socket object connected to the tool.</p> required <code>send</code> <code>Callable[[str], None]</code> <p>A function to send a message to the tool with the connection information prepopulated.</p> required <code>recd</code> <code>Callable[[], tuple[str, str, str, bool, bool]]</code> <p>A function to receive a message from the tool with the connection information prepopulated.</p> required Source code in <code>lat_alignment/ixb.py</code> <pre><code>def init(host: str, port: int, **kwargs) -&gt; tuple[\n    socket.SocketType,\n    Callable[[str], None],\n    Callable[[], tuple[str, str, str, bool, bool]],\n]:\n    \"\"\"\n    Connect to the tool and print identifying information.\n    Also generates convenience functions.\n\n    Parameters\n    ----------\n    host : str\n        The IP address of the IxB tool.\n    port : int, default: 4545\n        The port that open protocol is running at.\n    **kwargs\n        Additional arguments to pass to `connect`.\n\n    Returns:\n    sock : socket.SocketType\n        A socket object connected to the tool.\n    send : Callable[[str], None]\n        A function to send a message to the tool with\n        the connection information prepopulated.\n    recd : Callable[[], tuple[str, str, str, bool, bool]]\n        A function to receive a message from the tool with\n        the connection information prepopulated.\n    \"\"\"\n    sock = connect(host, port, **kwargs)\n    send = partial(send_mid, sock=sock, host=host, port=port)\n    recv = partial(recv_mid, sock=sock)\n    send(MID1)\n    mid, _, dat, _, _ = recv()\n    print(decode0002(mid, dat))\n    send(MID40)\n    mid, _, dat, _, _ = recv()\n    print(decode0041(mid, dat))\n    return sock, send, recv\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.recv_mid","title":"<code>recv_mid(sock)</code>","text":"<p>Receive a message from the tool.</p> <p>Parameters:</p> Name Type Description Default <code>sock</code> <code>SocketType</code> <p>Socket to communicate with the tool.</p> required <p>Returns:</p> Name Type Description <code>mid</code> <code>str</code> <p>The MID of the returned message.</p> <code>rev</code> <code>str</code> <p>The revision of the returned message's MID.</p> <code>data</code> <code>str</code> <p>The data in the returned message.</p> <code>disconnect</code> <code>bool</code> <p>True if a disconnect event was noticed.</p> <code>timeout</code> <code>bool</code> <p>True if a timeout event was noticed.</p> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def recv_mid(sock: socket.SocketType) -&gt; tuple[str, str, str, bool, bool]:\n    \"\"\"\n    Receive a message from the tool.\n\n    Parameters\n    ----------\n    sock : socket.SocketType\n        Socket to communicate with the tool.\n\n    Returns\n    -------\n    mid : str\n        The MID of the returned message.\n    rev : str\n        The revision of the returned message's MID.\n    data : str\n        The data in the returned message.\n    disconnect : bool\n        True if a disconnect event was noticed.\n    timeout : bool\n        True if a timeout event was noticed.\n    \"\"\"\n    keep_receiving = True\n    message = \"\"\n    timeout = False\n    disconnect = False\n    while keep_receiving:\n        chunk = \"\"\n        try:\n            chunk = sock.recv(1024).decode()\n        except socket.timeout:\n            timeout = True\n            break\n        if chunk == \"\":\n            disconnect = True\n            break\n        message += chunk\n        if chunk[-1:] == chr(0):\n            keep_receiving = False\n    if disconnect:\n        warnings.warn(\"Noticed a disconnect event, you may want to recconect!\")\n    if timeout:\n        warnings.warn(\"Noticed a timeout event, you may want to recconect!\")\n    if len(message) &lt; 12:\n        raise ValueError(\"Incomplete header! You may need to recconect!\")\n    return message[4:8], message[8:11], message[22:-1], disconnect, timeout\n</code></pre>"},{"location":"reference/ixb/#lat_alignment.ixb.send_mid","title":"<code>send_mid(message, sock=None, **kwargs)</code>","text":"<p>Send a message to the tool. One attempt at recconecting and sending the message is made.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to send. Should be formatted with the correct header for your MID.</p> required <code>sock</code> <code>Optional[SocketType]</code> <p>Socket to communicate with the tool. If <code>None</code> a new connection is made.</p> <code>None</code> <code>**kwargs</code> <p>Arguments to pass to <code>connect</code> in case we need to recconect.</p> <code>{}</code> Source code in <code>lat_alignment/ixb.py</code> <pre><code>def send_mid(message: str, sock: Optional[socket.SocketType] = None, **kwargs):\n    \"\"\"\n    Send a message to the tool.\n    One attempt at recconecting and sending the message is made.\n\n    Parameters\n    ----------\n    message : str\n        The message to send.\n        Should be formatted with the correct header for your MID.\n    sock : Optional[socket.SocketType], default: None\n        Socket to communicate with the tool.\n        If `None` a new connection is made.\n    **kwargs\n        Arguments to pass to `connect` in case we need to recconect.\n    \"\"\"\n    if sock is None:\n        sock = connect(**kwargs)\n    to_send = (message + chr(0)).encode()\n    try:\n        sock.sendall(to_send)\n    except BrokenPipeError:\n        connect(**kwargs)\n        sock.sendall(to_send)\n</code></pre>"},{"location":"reference/mirror/","title":"mirror","text":"<p>Functions to describe the mirror surface.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel","title":"<code>Panel</code>  <code>dataclass</code>","text":"<p>Dataclass for storing a mirror panel.</p> <p>Attributes:</p> Name Type Description <code>mirror</code> <code>str</code> <p>Which mirror this panel is for. Should be 'primary' or 'secondary'.</p> <code>row</code> <code>int</code> <p>The row of the panel.</p> <code>col</code> <code>int</code> <p>The column of the panel.</p> <code>corners</code> <code>NDArray[float64]</code> <p>Array of panel corners. Should have shape <code>(4, 3)</code>.</p> <code>measurements</code> <code>NDArray[float64]</code> <p>The measurement data for this panel. Should be in the mirror's internal coords. Should have shape <code>(npoint, 3)</code>.</p> <code>nom_adj</code> <code>NDArray[float64]</code> <p>The nominal position of the adjusters in the mirror internal coordinates. Should have shape <code>(5, 3)</code>.</p> <code>compensate</code> <code>float, default: 0</code> <p>The amount (in mm) to compensate the model surface by. This is to account for things like the Faro SMR.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>@dataclass\nclass Panel:\n    \"\"\"\n    Dataclass for storing a mirror panel.\n\n    Attributes\n    ----------\n    mirror : str\n        Which mirror this panel is for.\n        Should be 'primary' or 'secondary'.\n    row : int\n        The row of the panel.\n    col : int\n        The column of the panel.\n    corners : NDArray[np.float64]\n        Array of panel corners.\n        Should have shape `(4, 3)`.\n    measurements : NDArray[np.float64]\n        The measurement data for this panel.\n        Should be in the mirror's internal coords.\n        Should have shape `(npoint, 3)`.\n    nom_adj : NDArray[np.float64]\n        The nominal position of the adjusters in the mirror internal coordinates.\n        Should have shape `(5, 3)`.\n    compensate : float, default: 0\n        The amount (in mm) to compensate the model surface by.\n        This is to account for things like the Faro SMR.\n    \"\"\"\n\n    mirror: str\n    row: int\n    col: int\n    corners: NDArray[np.float64]\n    measurements: NDArray[np.float64]\n    nom_adj: NDArray[np.float64]\n    compensate: float = field(default=0.0)\n    adjuster_radius: float = field(default=50.0)\n\n    def __post_init__(self):\n        self.measurements = np.atleast_2d(self.measurements)\n\n    def __setattr__(self, name, value):\n        if (\n            name == \"nom_adj\"\n            or name == \"mirror\"\n            or name == \"measurements\"\n            or name == \"compensate\"\n        ):\n            self.__dict__.pop(\"can_surface\", None)\n            self.__dict__.pop(\"model\", None)\n            self.__dict__.pop(\"residuals\", None)\n            self.__dict__.pop(\"transformed_residuals\", None)\n            self.__dict__.pop(\"res_norm\", None)\n            self.__dict__.pop(\"rms\", None)\n            self.__dict__.pop(\"meas_surface\", None)\n            self.__dict__.pop(\"meas_adj\", None)\n            self.__dict__.pop(\"meas_adj_resid\", None)\n            self.__dict__.pop(\"adj_resid\", None)\n            self.__dict__.pop(\"model_transformed\", None)\n            self.__dict__.pop(\"_transform\", None)\n        elif name == \"adjuster_radius\":\n            self.__dict__.pop(\"meas_adj_resid\", None)\n        return super().__setattr__(name, value)\n\n    @cached_property\n    def model(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The modeled mirror surface at the locations of the measurementss.\n        \"\"\"\n        model = self.measurements.copy()\n        model[:, 2] = mirror_surface(model[:, 0], model[:, 1], a[self.mirror])\n        if self.compensate != 0.0:\n            compensation = self.compensate * mirror_norm(\n                model[:, 0], model[:0], a[self.mirror]\n            )\n            model += compensation\n        return model\n\n    @cached_property\n    def _transform(self) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n        return get_rigid(self.model, self.measurements, center_dst=True, method=\"mean\")\n\n    @property\n    def rot(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Rotation that aligns the model to the measurements.\n        \"\"\"\n        return self._transform[0]\n\n    @property\n    def shift(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Shift that aligns the model to the measurements.\n        \"\"\"\n        return self._transform[1]\n\n    @cached_property\n    def can_surface(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get the cannonical points to define the panel surface.\n        These are the adjuster positions projected only the mirror surface.\n        Note that this is in the nominal coordinates not the measured ones.\n        \"\"\"\n        can_z = mirror_surface(self.nom_adj[:, 0], self.nom_adj[:, 1], a[self.mirror])\n        points = self.nom_adj.copy()\n        points[:, 2] = can_z\n        return points\n\n    @cached_property\n    def meas_surface(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The cannonical surface transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.can_surface, self.rot, self.shift)\n\n    @cached_property\n    def meas_adj(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The adjuster points transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.nom_adj, self.rot, self.shift)\n\n    @cached_property\n    def meas_adj_resid(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        A correction that can be applied to `meas_adj` where we compute\n        the average residual of measured points from the transformed model\n        that are within `adjuster_radius` of the adjuster point in `xy`.\n        \"\"\"\n        resid = np.zeros(len(self.meas_adj))\n        for i, adj in enumerate(self.meas_adj):\n            dists = np.linalg.norm(self.measurements[:, :2] - adj[:2], axis=-1)\n            msk = dists &lt;= self.adjuster_radius\n            if np.sum(msk) == 0:\n                continue\n            resid[i] = np.mean(self.transformed_residuals[msk, 2])\n\n        return resid\n\n    @cached_property\n    def adj_resid(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        A correction that can be applied to `nom_adj` where we compute\n        the average residual of measured points from the model\n        that are within `adjuster_radius` of the adjuster point in `xy`.\n        \"\"\"\n        resid = np.zeros(len(self.meas_adj))\n        for i, adj in enumerate(self.meas_adj):\n            dists = np.linalg.norm(self.measurements[:, :2] - adj[:2], axis=-1)\n            msk = dists &lt;= self.adjuster_radius\n            if np.sum(msk) == 0:\n                continue\n            resid[i] = np.mean(self.residuals[msk, 2])\n\n        return resid\n\n    @property\n    def adj_msk(self) -&gt; NDArray[np.bool_]:\n        \"\"\"\n        Get a mask that only is True for measurements that are close to an adjustor.\n        \"\"\"\n        msk = np.zeros(len(self.measurements), dtype=bool)\n        if len(self.measurements) &lt; 4:\n            return msk\n        for adj in self.meas_adj:\n            dists = np.linalg.norm(self.measurements[:, :2] - adj[:2], axis=-1)\n            msk += dists &lt;= self.adjuster_radius\n        return msk\n\n    @cached_property\n    def model_transformed(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The model transformed to be in the measured coordinates.\n        \"\"\"\n        return apply_transform(self.model, self.rot, self.shift)\n\n    @cached_property\n    def residuals(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get residuals between model and measurements.\n        \"\"\"\n        return self.measurements - self.model\n\n    @cached_property\n    def transformed_residuals(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get residuals between transformed model and measurements.\n        \"\"\"\n        return self.measurements - self.model_transformed\n\n    @cached_property\n    def res_norm(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        Get norm of residuals between transformed model and measurements.\n        \"\"\"\n        return np.linalg.norm(self.residuals, axis=-1)\n\n    @cached_property\n    def rms(self) -&gt; float:\n        \"\"\"\n        Get rms between model and measurements.\n        \"\"\"\n        return np.sqrt(np.mean(self.residuals[:, 2].ravel() ** 2))\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.adj_msk","title":"<code>adj_msk</code>  <code>property</code>","text":"<p>Get a mask that only is True for measurements that are close to an adjustor.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.adj_resid","title":"<code>adj_resid</code>  <code>cached</code> <code>property</code>","text":"<p>A correction that can be applied to <code>nom_adj</code> where we compute the average residual of measured points from the model that are within <code>adjuster_radius</code> of the adjuster point in <code>xy</code>.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.can_surface","title":"<code>can_surface</code>  <code>cached</code> <code>property</code>","text":"<p>Get the cannonical points to define the panel surface. These are the adjuster positions projected only the mirror surface. Note that this is in the nominal coordinates not the measured ones.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_adj","title":"<code>meas_adj</code>  <code>cached</code> <code>property</code>","text":"<p>The adjuster points transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_adj_resid","title":"<code>meas_adj_resid</code>  <code>cached</code> <code>property</code>","text":"<p>A correction that can be applied to <code>meas_adj</code> where we compute the average residual of measured points from the transformed model that are within <code>adjuster_radius</code> of the adjuster point in <code>xy</code>.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.meas_surface","title":"<code>meas_surface</code>  <code>cached</code> <code>property</code>","text":"<p>The cannonical surface transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.model","title":"<code>model</code>  <code>cached</code> <code>property</code>","text":"<p>The modeled mirror surface at the locations of the measurementss.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.model_transformed","title":"<code>model_transformed</code>  <code>cached</code> <code>property</code>","text":"<p>The model transformed to be in the measured coordinates.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.res_norm","title":"<code>res_norm</code>  <code>cached</code> <code>property</code>","text":"<p>Get norm of residuals between transformed model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.residuals","title":"<code>residuals</code>  <code>cached</code> <code>property</code>","text":"<p>Get residuals between model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.rms","title":"<code>rms</code>  <code>cached</code> <code>property</code>","text":"<p>Get rms between model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.rot","title":"<code>rot</code>  <code>property</code>","text":"<p>Rotation that aligns the model to the measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.shift","title":"<code>shift</code>  <code>property</code>","text":"<p>Shift that aligns the model to the measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.Panel.transformed_residuals","title":"<code>transformed_residuals</code>  <code>cached</code> <code>property</code>","text":"<p>Get residuals between transformed model and measurements.</p>"},{"location":"reference/mirror/#lat_alignment.mirror.gen_panels","title":"<code>gen_panels(mirror, dataset, corners, adjusters, compensate=0.0, adjuster_radius=50.0)</code>","text":"<p>Use a set of measurements to generate panel objects.</p> <p>Parameters:</p> Name Type Description Default <code>mirror</code> <code>str</code> <p>The mirror these panels belong to. Should be 'primary' or 'secondary'.</p> required <code>dataset</code> <code>Dataset</code> <p>The photogrammetry data.</p> required <code>corners</code> <code>dict[tuple[int, int], ndarray[float64]]</code> <p>The corners. This is indexed by a (row, col) tuple. Each entry is <code>(4, 3)</code> array where each row is a corner.</p> required <code>adjusters</code> <code>dict[tuple[int, int], NDArray[float64]]</code> <p>Nominal adjuster locations. This is indexed by a (row, col) tuple. Each entry is <code>(5, 3)</code> array where each row is an adjuster.</p> required <code>compensate</code> <code>float</code> <p>Amount (in mm) to compensate the model surface by. This is to account for things like the faro SMR.</p> <code>0.0</code> <code>adjuster_radius</code> <code>float</code> <p>The radius in XY of points that an adjuster should use to compute a secondary correction on its position. Should be in mm.</p> <code>50.0</code> <p>Returns:</p> Name Type Description <code>panels</code> <code>list[Panels]</code> <p>A list of panels with the transforme initialized to the identity.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def gen_panels(\n    mirror: str,\n    dataset: Dataset,\n    corners: dict[tuple[int, int], NDArray[np.float64]],\n    adjusters: dict[tuple[int, int], NDArray[np.float64]],\n    compensate: float = 0.0,\n    adjuster_radius: float = 50.0,\n) -&gt; list[Panel]:\n    \"\"\"\n    Use a set of measurements to generate panel objects.\n\n    Parameters\n    ----------\n    mirror : str\n        The mirror these panels belong to.\n        Should be 'primary' or 'secondary'.\n    dataset : Dataset\n        The photogrammetry data.\n    corners : dict[tuple[int, int], ndarray[np.float64]]\n        The corners. This is indexed by a (row, col) tuple.\n        Each entry is `(4, 3)` array where each row is a corner.\n    adjusters : dict[tuple[int, int], NDArray[np.float64]]\n        Nominal adjuster locations.\n        This is indexed by a (row, col) tuple.\n        Each entry is `(5, 3)` array where each row is an adjuster.\n    compensate : float, default: 0.0\n        Amount (in mm) to compensate the model surface by.\n        This is to account for things like the faro SMR.\n    adjuster_radius : float, default: 50.0\n        The radius in XY of points that an adjuster should use to\n        compute a secondary correction on its position.\n        Should be in mm.\n\n    Returns\n    -------\n    panels : list[Panels]\n        A list of panels with the transforme initialized to the identity.\n    \"\"\"\n    points = defaultdict(list)\n    # dumb brute force\n    corr = np.arange(4, dtype=int)\n    for point in dataset.points:\n        for rc, crns in corners.items():\n            x = crns[:, 0] &gt; point[0]\n            y = crns[:, 1] &gt; point[1]\n            val = x.astype(int) + 2 * y.astype(int)\n            if np.array_equal(np.sort(val), corr):\n                points[rc] += [point]\n                break\n\n    # Now init the objects\n    panels = []\n    for (row, col), meas in points.items():\n        meas = np.vstack(meas, dtype=np.float64)\n        panel = Panel(\n            mirror,\n            row,\n            col,\n            corners[(row, col)],\n            meas,\n            adjusters[(row, col)],\n            compensate,\n            adjuster_radius,\n        )\n        panels += [panel]\n    return panels\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.mirror_norm","title":"<code>mirror_norm(x, y, a)</code>","text":"<p>Analytic form of the vector normal to the mirror surface.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float64]</code> <p>X positions to calculate at in mm.</p> required <code>y</code> <code>NDArray[float64]</code> <p>Y positions to calculate at in mm. Should have the same shape as <code>x</code>.</p> required <code>a</code> <code>NDArray[float64]</code> <p>Coeffecients of the mirror function. Use <code>a_primary</code> for the primary mirror. Use <code>a_secondary</code> for the secondary mirror.</p> required <p>Returns:</p> Name Type Description <code>normals</code> <code>NDArray[float64]</code> <p>Unit vector normal to the mirror surface at each input coordinate. Has shape <code>shape(x) + (3,)</code>.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def mirror_norm(\n    x: NDArray[np.float64], y: NDArray[np.float64], a: NDArray[np.float64]\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Analytic form of the vector normal to the mirror surface.\n\n    Parameters\n    ----------\n    x : NDArray[np.float64]\n        X positions to calculate at in mm.\n    y : NDArray[np.float64]\n        Y positions to calculate at in mm.\n        Should have the same shape as `x`.\n    a : NDArray[np.float64]\n        Coeffecients of the mirror function.\n        Use `a_primary` for the primary mirror.\n        Use `a_secondary` for the secondary mirror.\n\n    Returns\n    -------\n    normals : NDArray[np.float64]\n        Unit vector normal to the mirror surface at each input coordinate.\n        Has shape `shape(x) + (3,)`.\n    \"\"\"\n    Rn = 3000.0\n\n    x_n = np.zeros_like(x)\n    y_n = np.zeros_like(y)\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):\n            if i != 0:\n                x_n += a[i, j] * (x ** (i - 1)) / (Rn**i) * (y / Rn) ** j\n            if j != 0:\n                y_n += a[i, j] * (x / Rn) ** i * (y ** (j - 1)) / (Rn**j)\n\n    z_n = -1 * np.ones_like(x_n)\n    normals = np.array((x_n, y_n, z_n)).T\n    normals /= np.linalg.norm(normals, axis=-1)[:, np.newaxis]\n    return normals\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.mirror_surface","title":"<code>mirror_surface(x, y, a)</code>","text":"<p>Analytic form of the mirror surface.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float64]</code> <p>X positions to calculate at in mm.</p> required <code>y</code> <code>NDArray[float64]</code> <p>Y positions to calculate at in mm. Should have the same shape as <code>x</code>.</p> required <code>a</code> <code>NDArray[float64]</code> <p>Coeffecients of the mirror function. Use <code>a_primary</code> for the primary mirror. Use <code>a_secondary</code> for the secondary mirror.</p> required <p>Returns:</p> Name Type Description <code>z</code> <code>NDArray[float64]</code> <p>Z position of the mirror at each input coordinate. Has the same shape as <code>x</code>.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def mirror_surface(\n    x: NDArray[np.float64], y: NDArray[np.float64], a: NDArray[np.float64]\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Analytic form of the mirror surface.\n\n    Parameters\n    ----------\n    x : NDArray[np.float64]\n        X positions to calculate at in mm.\n    y : NDArray[np.float64]\n        Y positions to calculate at in mm.\n        Should have the same shape as `x`.\n    a : NDArray[np.float64]\n        Coeffecients of the mirror function.\n        Use `a_primary` for the primary mirror.\n        Use `a_secondary` for the secondary mirror.\n\n    Returns\n    -------\n    z : NDArray[np.float64]\n        Z position of the mirror at each input coordinate.\n        Has the same shape as `x`.\n    \"\"\"\n    z = np.zeros_like(x)\n    Rn = 3000.0\n    for i in range(a.shape[0]):\n        for j in range(a.shape[1]):\n            z += a[i, j] * (x / Rn) ** i * (y / Rn) ** j\n    return z\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.plot_panels","title":"<code>plot_panels(panels, title_str, vmax=None)</code>","text":"<p>Make a plot containing panel residuals and histogram. TODO: Correlation?</p> <p>Parameters:</p> Name Type Description Default <code>panels</code> <code>list[Panel]</code> <p>The panels to plot.</p> required <code>title_str</code> <code>str</code> <p>The title string, rms will me appended.</p> required <code>vmax</code> <code>Optional[float]</code> <p>The max of the colorbar. vmin will be -1 times this. Set to None to compute automatically. Should be in um.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>figure</code> <code>Figure</code> <p>The figure with panels plotted on it.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def plot_panels(\n    panels: list[Panel], title_str: str, vmax: Optional[float] = None\n) -&gt; Figure:\n    \"\"\"\n    Make a plot containing panel residuals and histogram.\n    TODO: Correlation?\n\n    Parameters\n    ----------\n    panels : list[Panel]\n        The panels to plot.\n    title_str : str\n        The title string, rms will me appended.\n    vmax : Optional[float], default: None\n        The max of the colorbar. vmin will be -1 times this.\n        Set to None to compute automatically.\n        Should be in um.\n\n    Returns\n    -------\n    figure : Figure\n        The figure with panels plotted on it.\n    \"\"\"\n    res_all = np.vstack([panel.residuals for panel in panels]) * 1000\n    model_all = np.vstack([panel.model for panel in panels])\n    if vmax is None:\n        vmax = np.max(np.abs(res_all[:, 2]))\n    if vmax is None:\n        raise ValueError(\"vmax still None?\")\n    gs = gridspec.GridSpec(2, 2, width_ratios=[20, 1], height_ratios=[2, 1])\n    fig = plt.figure()\n    ax0 = plt.subplot(gs[0])\n    cax = plt.subplot(gs[1])\n    ax1 = plt.subplot(gs[2:])\n    cb = None\n    for panel in panels:\n        if len(panel.model) &lt; 3:\n            logger.debug(\n                \"\\tCan't plot panel (%s, %s), not enough points\", panel.row, panel.col\n            )\n            continue\n        ax0.tricontourf(\n            panel.model[:, 0],\n            panel.model[:, 1],\n            panel.residuals[:, 2] * 1000,\n            vmin=-1 * vmax,\n            vmax=vmax,\n            cmap=\"coolwarm\",\n            alpha=0.6,\n        )\n        cb = ax0.scatter(\n            panel.model[:, 0],\n            panel.model[:, 1],\n            s=40,\n            c=panel.residuals[:, 2] * 1000,\n            vmin=-1 * vmax,\n            vmax=vmax,\n            cmap=\"coolwarm\",\n            marker=\"o\",\n            alpha=0.9,\n            linewidth=2,\n            edgecolor=\"black\",\n        )\n        ax0.scatter(\n            panel.meas_adj[:, 0],\n            panel.meas_adj[:, 1],\n            marker=\"x\",\n            linewidth=1,\n            color=\"black\",\n        )\n    ax0.tricontourf(\n        model_all[:, 0],\n        model_all[:, 1],\n        res_all[:, 2],\n        vmin=-1 * vmax,\n        vmax=vmax,\n        cmap=\"coolwarm\",\n        alpha=0.2,\n    )\n    ax0.set_xlabel(\"x (mm)\")\n    ax0.set_ylabel(\"y (mm)\")\n    ax0.set_xlim(-3300, 3300)  # ack hardcoded!\n    ax0.set_ylim(-3300, 3300)\n    if cb is not None:\n        fig.colorbar(cb, cax)\n    ax0.set_aspect(\"equal\")\n    for panel in panels:\n        ax0.add_patch(\n            Polygon(panel.corners[[0, 1, 3, 2], :2], fill=False, color=\"black\")\n        )\n\n    ax1.hist(res_all[:, 2], bins=len(panels))\n    ax1.set_xlabel(\"z residual (um)\")\n\n    points = np.array([len(panel.measurements) for panel in panels])\n    rms = np.array([panel.rms for panel in panels])\n    tot_rms = 1000 * np.sum(rms * points) / np.sum(points)\n    fig.suptitle(f\"{title_str}, RMS={tot_rms:.2f} um\")\n\n    plt.show()\n\n    return fig\n</code></pre>"},{"location":"reference/mirror/#lat_alignment.mirror.remove_cm","title":"<code>remove_cm(dataset, mirror, compensate=0, thresh=10, cut_thresh=50, niters=10)</code>","text":"<p>Fit for the common mode transformation from the model to the measurements of all panels and them remove it. Note that this will remove all coded targets from the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Dataset</code> <p>The photogrammetry data.</p> required <code>mirror</code> <code>str</code> <p>The mirror this data belong to. Should be 'primary' or 'secondary'.</p> required <code>compensate</code> <code>float</code> <p>Compensation to apply to model. This is to account for the radius of a Faro SMR.</p> <code>0</code> <code>thresh</code> <code>float</code> <p>How many times higher than the median residual a point needs to have to be considered an outlier.</p> <code>10</code> <code>niters</code> <code>int</code> <p>How many iterations of common mode fitting to do.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>kept_points</code> <code>Dataset</code> <p>The points that were successfully fit with the common mode removed.</p> <code>common_mode</code> <code>tuple[NDArray[float64], NDArray[float64]]</code> <p>The common mode that was removed. The first element is an affine matrix and the second is the shift.</p> Source code in <code>lat_alignment/mirror.py</code> <pre><code>def remove_cm(\n    dataset: Dataset,\n    mirror: str,\n    compensate: float = 0,\n    thresh: float = 10,\n    cut_thresh: float = 50,\n    niters: int = 10,\n) -&gt; tuple[Dataset, tuple[NDArray[np.float64], NDArray[np.float64]]]:\n    \"\"\"\n    Fit for the common mode transformation from the model to the measurements of all panels and them remove it.\n    Note that this will remove all coded targets from the dataset.\n\n    Parameters\n    ----------\n    dataset : Dataset\n        The photogrammetry data.\n    mirror : str\n        The mirror this data belong to.\n        Should be 'primary' or 'secondary'.\n    compensate : float, default: 0\n        Compensation to apply to model.\n        This is to account for the radius of a Faro SMR.\n    thresh : float, default: 10\n        How many times higher than the median residual a point needs to have to be\n        considered an outlier.\n    niters : int, default: 10\n        How many iterations of common mode fitting to do.\n\n    Returns\n    -------\n    kept_points: Dataset\n        The points that were successfully fit with the common mode removed.\n    common_mode : tuple[NDArray[np.float64], NDArray[np.float64]]\n        The common mode that was removed.\n        The first element is an affine matrix and\n        the second is the shift.\n    \"\"\"\n    logger.info(\"Removing common mode for %s\", mirror)\n\n    def _cm(x, panel):\n        panel.measurements[:] -= x[1:4]\n        rot = Rotation.from_euler(\"xyz\", x[4:])\n        panel.measurements = rot.apply(panel.measurements)\n        panel.measurements *= x[0]\n\n    def _opt(x, panel):\n        p2 = deepcopy(panel)\n        _cm(x, p2)\n        return p2.rms\n\n    # make a fake panel for the full mirror\n    corners = np.array(\n        ([-3300, -3300, 0], [-3300, 3300, 0], [3300, 3300, 0], [3300, -3300, 0])\n    )  # ack hardcoded\n    labels = dataset.target_labels\n    data = dataset.targets\n    corr = np.arange(4, dtype=int)\n    x = np.vstack([corners[:, 0] &gt; dat[0] for dat in data])\n    y = np.vstack([corners[:, 1] &gt; dat[1] for dat in data])\n    val = x.astype(int) + 2 * y.astype(int)\n    val = np.sort(val, axis=-1)\n    msk = (val == corr).all(-1)\n    msk *= abs(data[:, 2]) &lt; 500\n    data = data[msk]\n    labels = labels[msk]\n    panel = Panel(\n        mirror,\n        -1,\n        -1,\n        np.zeros((4, 3), \"float64\"),\n        data,\n        np.zeros((5, 3), \"float64\"),\n        compensate,\n    )\n    data = data.copy()\n    data_clean = data.copy()\n    logger.info(\"\\tRemoved %d points not on mirror surface\", np.sum(~msk))\n\n    x0 = np.hstack([np.ones(1), np.zeros(6)])\n    bounds = [(0.95, 1.05)] + [(-100, 100)] * 3 + [(0, 2 * np.pi)] * 3\n\n    for i in range(niters):\n        if len(panel.measurements) &lt; 3:\n            raise ValueError\n        logger.debug(\"\\titer %d for common mode fit\", i)\n        cut = panel.res_norm &gt; thresh * np.median(panel.res_norm)\n        if np.sum(cut) &gt; 0:\n            panel.measurements = panel.measurements[~cut]\n            data = data[~cut]\n\n        logger.debug(\"\\t\\tRemoving a naive common mode shift of %s\", str(panel.shift))\n        panel.measurements -= panel.shift\n        panel.measurements @= panel.rot.T\n\n        res = minimize(_opt, x0, (panel,), bounds=bounds)\n        logger.debug(\n            \"\\t\\tRemoving a fit common mode with scale %f, shift %s, and rotation %s\",\n            res.x[0],\n            str(res.x[1:4]),\n            str(res.x[4:]),\n        )\n        _cm(res.x, panel)\n\n        logger.debug(\n            \"\\t\\tRemoving a secondary common mode shift of %s and rotation of %s\",\n            str(panel.shift),\n            str(np.rad2deg(decompose_rotation(panel.rot))),\n        )\n        panel.measurements -= panel.shift\n        panel.measurements @= panel.rot.T\n\n    aff, sft = get_affine(\n        data, panel.measurements, method=\"mean\", weights=np.ones(len(data))\n    )\n    scale, shear, rot = decompose_affine(aff)\n    rot = decompose_rotation(rot)\n    logger.info(\n        \"\\tFull common mode is:\\n\\t\\t\\tshift = %s mm\\n\\t\\t\\tscale = %s\\n\\t\\t\\tshear = %s\\n\\t\\t\\trot = %s deg\",\n        str(sft),\n        str(scale),\n        str(shear),\n        str(np.rad2deg(rot)),\n    )\n\n    panel.measurements = apply_transform(data_clean, aff, sft)\n    cut = panel.res_norm &gt; cut_thresh * np.median(panel.res_norm)\n    if np.sum(cut) &gt; 0:\n        logger.info(\"\\tRemoving %d bad points from mirror\", np.sum(cut))\n        panel.measurements = panel.measurements[~cut]\n        labels = labels[~cut]\n    logger.info(\"\\tMirror has %d good points\", len(panel.measurements))\n\n    data = {l: d for l, d in zip(labels, panel.measurements)}\n    kept_points = dataset.copy()\n    kept_points.data_dict = data\n\n    return kept_points, (aff, sft)\n</code></pre>"},{"location":"reference/refpoint/","title":"refpoint","text":"<p>Functions and dataclasses to handle reference points.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefCollection","title":"<code>RefCollection</code>  <code>dataclass</code>","text":"<p>Dataclass for storing a collection of <code>RefElem</code>s with measurements taken together.</p> <p>Attributes:</p> Name Type Description <code>elems</code> <code>list[RefElem]</code> <p>The <code>RefElem</code>s in the collection.</p> Source code in <code>lat_alignment/refpoint.py</code> <pre><code>@dataclass\nclass RefCollection:\n    \"\"\"\n    Dataclass for storing a collection of `RefElem`s with measurements taken together.\n\n    Attributes\n    ----------\n    elems : list[RefElem]\n        The `RefElem`s in the collection.\n    \"\"\"\n\n    elems: list[RefElem]\n\n    def __setattr__(self, name, val):\n        self.__dict__[name] = val\n        if name == \"elems\":\n            self.__dict__.pop(\"meas_number\", None)\n            self.__dict__.pop(\"npoints\", None)\n            self.__dict__.pop(\"nelems\", None)\n            self.__dict__.pop(\"direction\", None)\n            self.__dict__.pop(\"angle\", None)\n            self.__dict__.pop(\"elem_names\", None)\n            self.__dict__.pop(\"_elem_dict\", None)\n            self._check()\n\n    @cached_property\n    def elem_names(self) -&gt; list[str]:\n        \"\"\"\n        The names of the `RefElem`s in the collection.\n        \"\"\"\n        return [e.name for e in self.elems]\n\n    @cached_property\n    def _elem_dict(self):\n        return {n: e for n, e in zip(self.elem_names, self.elems)}\n\n    def __getitem__(self, index):\n        return self._elem_dict[index]\n\n    def keys(self):\n        return self._elem_dict.keys()\n\n    def values(self):\n        return self._elem_dict.values()\n\n    def items(self):\n        return self._elem_dict.items()\n\n    @cached_property\n    def angle(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The angle for all the `RefElems`s in this element.\n        Will have shape `(npoint,)`.\n        \"\"\"\n        return self.elems[0].angle\n\n    @cached_property\n    def direction(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The direction for all the `RefElems`s in this element.\n        Will have shape `(npoint,)`.\n        \"\"\"\n        return self.elems[0].direction\n\n    @cached_property\n    def npoints(self) -&gt; int:\n        \"\"\"\n        The number of points in each `RefTOD`.\n        \"\"\"\n        return self.elems[0].npoints\n\n    @cached_property\n    def nelems(self) -&gt; int:\n        \"\"\"\n        The number of elems in each `RefElem`.\n        \"\"\"\n        return len(self.elems)\n\n    @cached_property\n    def meas_number(self) -&gt; NDArray[np.integer]:\n        \"\"\"\n        Array that indexes the TOD data (ie: sample number).\n        \"\"\"\n        return self.elems[0].meas_number\n\n    def _check(self):\n        for elem in self.values():\n            elem._check()\n            if not (np.isclose(elem.angle, self.angle) | np.isnan(elem.angle)).all():\n                raise ValueError(\"Angles don't agree!\")\n            if not (\n                np.isclose(elem.direction, self.direction) | np.isnan(elem.direction)\n            ).all():\n                raise ValueError(\"Directions don't agree!\")\n\n    @classmethod\n    def construct(\n        cls, data: dict[str, list[RefTOD]], logger: logging.Logger, pad: bool = False\n    ) -&gt; Self:\n        \"\"\"\n        Construct a `RefCollection` from `RefTOD`s.\n\n        Parameters\n        ----------\n        data : dict[str, list[RefTOD]]\n            The data to construct from.\n            Each item in the `dict` should be a list of `RefTOD`s that are from the same element,\n            with the key being the element name.\n        logger : logging.Logger\n            The logger object to use.\n        pad : bool, default: False\n            If True then attempt to pad the `RefTOD` so they agree on the angle and measurements number.\n\n        Returns\n        -------\n        collection : RefCollection\n            The constructed `RefCollection`.\n        \"\"\"\n        npoints = np.hstack(\n            [[point.npoints for point in data[elem]] for elem in data.keys()]\n        )\n        if not np.all(npoints == npoints[0]):\n            if not pad:\n                raise ValueError(\"Not all points have the same number of measurements!\")\n            logger.warning(\"\\tPadding data with nans\")\n            master_angle = [\n                [point.angle for point in data[elem]] for elem in data.keys()\n            ]\n            master_angle = reduce(operator.iconcat, master_angle, [])\n            nangs = np.array([len(ang) for ang in master_angle])\n            master_angle = master_angle[np.argmax(nangs)]\n            for elem in data.keys():\n                for i, point in enumerate(data[elem]):\n                    ang_pad, pad_msk = _pad_missing(master_angle, point.angle)\n                    dat_pad = np.zeros((len(ang_pad),) + point.data.shape[1:]) + np.nan\n                    dat_pad[~pad_msk] = point.data\n                    data[elem][i] = RefTOD(point.name, dat_pad, ang_pad)\n        elems = []\n        for elem in data.keys():\n            logger.info(\"\\tConstructing TOD for %s\", elem)\n            try:\n                relem = RefElem(elem, data[elem])\n                relem._check()\n            except ValueError as e:\n                logger.error(f\"\\t\\tFailed with error: {e}. Skipping...\")\n                continue\n            if relem.data.size == 0:\n                logger.info(\"\\t\\tNo data found! Not making TOD\")\n                continue\n            elems += [relem]\n\n        return cls(elems)\n</code></pre>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefCollection.angle","title":"<code>angle</code>  <code>cached</code> <code>property</code>","text":"<p>The angle for all the <code>RefElems</code>s in this element. Will have shape <code>(npoint,)</code>.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefCollection.direction","title":"<code>direction</code>  <code>cached</code> <code>property</code>","text":"<p>The direction for all the <code>RefElems</code>s in this element. Will have shape <code>(npoint,)</code>.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefCollection.elem_names","title":"<code>elem_names</code>  <code>cached</code> <code>property</code>","text":"<p>The names of the <code>RefElem</code>s in the collection.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefCollection.meas_number","title":"<code>meas_number</code>  <code>cached</code> <code>property</code>","text":"<p>Array that indexes the TOD data (ie: sample number).</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefCollection.nelems","title":"<code>nelems</code>  <code>cached</code> <code>property</code>","text":"<p>The number of elems in each <code>RefElem</code>.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefCollection.npoints","title":"<code>npoints</code>  <code>cached</code> <code>property</code>","text":"<p>The number of points in each <code>RefTOD</code>.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefCollection.construct","title":"<code>construct(data, logger, pad=False)</code>  <code>classmethod</code>","text":"<p>Construct a <code>RefCollection</code> from <code>RefTOD</code>s.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, list[RefTOD]]</code> <p>The data to construct from. Each item in the <code>dict</code> should be a list of <code>RefTOD</code>s that are from the same element, with the key being the element name.</p> required <code>logger</code> <code>Logger</code> <p>The logger object to use.</p> required <code>pad</code> <code>bool</code> <p>If True then attempt to pad the <code>RefTOD</code> so they agree on the angle and measurements number.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>collection</code> <code>RefCollection</code> <p>The constructed <code>RefCollection</code>.</p> Source code in <code>lat_alignment/refpoint.py</code> <pre><code>@classmethod\ndef construct(\n    cls, data: dict[str, list[RefTOD]], logger: logging.Logger, pad: bool = False\n) -&gt; Self:\n    \"\"\"\n    Construct a `RefCollection` from `RefTOD`s.\n\n    Parameters\n    ----------\n    data : dict[str, list[RefTOD]]\n        The data to construct from.\n        Each item in the `dict` should be a list of `RefTOD`s that are from the same element,\n        with the key being the element name.\n    logger : logging.Logger\n        The logger object to use.\n    pad : bool, default: False\n        If True then attempt to pad the `RefTOD` so they agree on the angle and measurements number.\n\n    Returns\n    -------\n    collection : RefCollection\n        The constructed `RefCollection`.\n    \"\"\"\n    npoints = np.hstack(\n        [[point.npoints for point in data[elem]] for elem in data.keys()]\n    )\n    if not np.all(npoints == npoints[0]):\n        if not pad:\n            raise ValueError(\"Not all points have the same number of measurements!\")\n        logger.warning(\"\\tPadding data with nans\")\n        master_angle = [\n            [point.angle for point in data[elem]] for elem in data.keys()\n        ]\n        master_angle = reduce(operator.iconcat, master_angle, [])\n        nangs = np.array([len(ang) for ang in master_angle])\n        master_angle = master_angle[np.argmax(nangs)]\n        for elem in data.keys():\n            for i, point in enumerate(data[elem]):\n                ang_pad, pad_msk = _pad_missing(master_angle, point.angle)\n                dat_pad = np.zeros((len(ang_pad),) + point.data.shape[1:]) + np.nan\n                dat_pad[~pad_msk] = point.data\n                data[elem][i] = RefTOD(point.name, dat_pad, ang_pad)\n    elems = []\n    for elem in data.keys():\n        logger.info(\"\\tConstructing TOD for %s\", elem)\n        try:\n            relem = RefElem(elem, data[elem])\n            relem._check()\n        except ValueError as e:\n            logger.error(f\"\\t\\tFailed with error: {e}. Skipping...\")\n            continue\n        if relem.data.size == 0:\n            logger.info(\"\\t\\tNo data found! Not making TOD\")\n            continue\n        elems += [relem]\n\n    return cls(elems)\n</code></pre>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefElem","title":"<code>RefElem</code>  <code>dataclass</code>","text":"<p>Dataclass for storing a collection of <code>RefTOD</code>s that belong to the same element (ie: primary, secondary, etc).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the element.</p> <code>tods</code> <code>list[RefTOD]</code> <p>The <code>RefTOD</code>s that make up this element. All these TODs must agree on the number of measurements as well as the angle at each measurements.</p> Source code in <code>lat_alignment/refpoint.py</code> <pre><code>@dataclass\nclass RefElem:\n    \"\"\"\n    Dataclass for storing a collection of `RefTOD`s that belong to the same element (ie: primary, secondary, etc).\n\n    Attributes\n    ----------\n    name : str\n        The name of the element.\n    tods : list[RefTOD]\n        The `RefTOD`s that make up this element.\n        All these TODs must agree on the number of measurements\n        as well as the angle at each measurements.\n    \"\"\"\n\n    name: str\n    tods: list[RefTOD]\n\n    def __setattr__(self, name, val):\n        self.__dict__[name] = val\n        if name == \"tods\":\n            self.__dict__.pop(\"meas_number\", None)\n            self.__dict__.pop(\"npoints\", None)\n            self.__dict__.pop(\"ntods\", None)\n            self.__dict__.pop(\"direction\", None)\n            self.__dict__.pop(\"angle\", None)\n            self.__dict__.pop(\"data\", None)\n            self.__dict__.pop(\"tod_names\", None)\n            self._check()\n\n    @cached_property\n    def data(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The data for all the `RefTOD`s in this element.\n        Will have shape `(npoint, ntod, ndim)`.\n        \"\"\"\n        data = np.swapaxes(\n            np.atleast_3d(np.array([e.data for e in self.tods])),\n            0,\n            1,\n        )\n        return data\n\n    @cached_property\n    def angle(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The angle for all the `RefTOD`s in this element.\n        Will have shape `(npoint,)`.\n        \"\"\"\n        return self.tods[0].angle\n\n    @cached_property\n    def direction(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The direction for all the `RefTOD`s in this element.\n        Will have shape `(npoint,)`.\n        \"\"\"\n        return self.tods[0].direction\n\n    @cached_property\n    def npoints(self) -&gt; int:\n        \"\"\"\n        The number of points in each `RefTOD`.\n        \"\"\"\n        return self.tods[0].npoints\n\n    @cached_property\n    def ntods(self) -&gt; int:\n        \"\"\"\n        The number of `RefTOD`s in this element.\n        \"\"\"\n        return len(self.tods)\n\n    @cached_property\n    def meas_number(self) -&gt; NDArray[np.integer]:\n        \"\"\"\n        Array that indexes the TOD data (ie: sample number).\n        \"\"\"\n        return self.tods[0].meas_number\n\n    @cached_property\n    def tod_names(self) -&gt; NDArray[np.str_]:\n        \"\"\"\n        The names of the `RefTOD`s in this element.\n        \"\"\"\n        return np.array([t.name for t in self.tods])\n\n    def _check(self):\n        if len(self.tods) == 0:\n            raise ValueError(\"Empty element!\")\n        if len(np.unique(self.tod_names)) != len(self.tods):\n            raise ValueError(\"TOD names not uniqe!\")\n        all_npoints = np.array([t.npoints for t in self.tods])\n        if np.any(all_npoints != self.npoints):\n            raise ValueError(\"Not all TODs have the same length!\")\n        all_ang = np.array([e.angle for e in self.tods])\n        if not (np.isclose(all_ang, self.angle) | np.isnan(all_ang)).all():\n            raise ValueError(\"Angles don't agree!\")\n        all_dir = np.array([e.direction for e in self.tods])\n        if not (np.isclose(all_dir, self.direction) | np.isnan(all_dir)).all():\n            raise ValueError(\"Directions don't agree!\")\n\n    def reorder(self, names: NDArray[np.str_], pad: bool = False) -&gt; Self:\n        \"\"\"\n        Reorder the `RefTOD`s in this element.\n\n        Parameters\n        ----------\n        names : NDArray[np.str_]\n            The names in the requested order.\n        pad : bool, default: False\n            If True then if there are names not found in this\n            element they will be added with `np.nan` for all data.\n\n        Returns\n        -------\n        reordered : Self\n            The reordered `RefElem`.\n            The object is also modified in place.\n\n        Raises\n        ------\n        ValueError\n            If the element has no TODs.\n            If `names` is not unique.\n            If we aren't padding and `names` isn't a subset of `self.tod_names`.\n        \"\"\"\n        if len(self.tods) == 0:\n            raise ValueError(\"Can't reorder empty element!\")\n        names = np.array(names)\n        if len(np.unique(names)) != len(names):\n            raise ValueError(\"Input names not unique\")\n        inself = np.isin(names, self.tod_names)\n        tods = self.tods\n        if np.sum(inself) != len(names):\n            if not pad:\n                names = names[inself]\n            else:\n                null_dat = np.zeros_like(tods[0].data, np.float64) + np.nan\n                tods += [\n                    RefTOD(n, null_dat.copy(), self.angle.copy())\n                    for n in names[~inself]\n                ]\n        tods = [t for t in tods if t.name in names]\n        if len(tods) != len(names):\n            raise ValueError(\"Can't find enough TODs with the input names!\")\n        tod_names = np.array([t.name for t in tods])\n        mapping = np.argsort(np.argsort(names))\n        nsrt = np.argsort(tod_names)\n        tods_srt = [tods[i] for i in nsrt]\n        tods_srt = [tods_srt[i] for i in mapping]\n\n        self.tods = tods_srt\n        return self\n</code></pre>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefElem.angle","title":"<code>angle</code>  <code>cached</code> <code>property</code>","text":"<p>The angle for all the <code>RefTOD</code>s in this element. Will have shape <code>(npoint,)</code>.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefElem.data","title":"<code>data</code>  <code>cached</code> <code>property</code>","text":"<p>The data for all the <code>RefTOD</code>s in this element. Will have shape <code>(npoint, ntod, ndim)</code>.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefElem.direction","title":"<code>direction</code>  <code>cached</code> <code>property</code>","text":"<p>The direction for all the <code>RefTOD</code>s in this element. Will have shape <code>(npoint,)</code>.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefElem.meas_number","title":"<code>meas_number</code>  <code>cached</code> <code>property</code>","text":"<p>Array that indexes the TOD data (ie: sample number).</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefElem.npoints","title":"<code>npoints</code>  <code>cached</code> <code>property</code>","text":"<p>The number of points in each <code>RefTOD</code>.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefElem.ntods","title":"<code>ntods</code>  <code>cached</code> <code>property</code>","text":"<p>The number of <code>RefTOD</code>s in this element.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefElem.tod_names","title":"<code>tod_names</code>  <code>cached</code> <code>property</code>","text":"<p>The names of the <code>RefTOD</code>s in this element.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefElem.reorder","title":"<code>reorder(names, pad=False)</code>","text":"<p>Reorder the <code>RefTOD</code>s in this element.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>NDArray[str_]</code> <p>The names in the requested order.</p> required <code>pad</code> <code>bool</code> <p>If True then if there are names not found in this element they will be added with <code>np.nan</code> for all data.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>reordered</code> <code>Self</code> <p>The reordered <code>RefElem</code>. The object is also modified in place.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the element has no TODs. If <code>names</code> is not unique. If we aren't padding and <code>names</code> isn't a subset of <code>self.tod_names</code>.</p> Source code in <code>lat_alignment/refpoint.py</code> <pre><code>def reorder(self, names: NDArray[np.str_], pad: bool = False) -&gt; Self:\n    \"\"\"\n    Reorder the `RefTOD`s in this element.\n\n    Parameters\n    ----------\n    names : NDArray[np.str_]\n        The names in the requested order.\n    pad : bool, default: False\n        If True then if there are names not found in this\n        element they will be added with `np.nan` for all data.\n\n    Returns\n    -------\n    reordered : Self\n        The reordered `RefElem`.\n        The object is also modified in place.\n\n    Raises\n    ------\n    ValueError\n        If the element has no TODs.\n        If `names` is not unique.\n        If we aren't padding and `names` isn't a subset of `self.tod_names`.\n    \"\"\"\n    if len(self.tods) == 0:\n        raise ValueError(\"Can't reorder empty element!\")\n    names = np.array(names)\n    if len(np.unique(names)) != len(names):\n        raise ValueError(\"Input names not unique\")\n    inself = np.isin(names, self.tod_names)\n    tods = self.tods\n    if np.sum(inself) != len(names):\n        if not pad:\n            names = names[inself]\n        else:\n            null_dat = np.zeros_like(tods[0].data, np.float64) + np.nan\n            tods += [\n                RefTOD(n, null_dat.copy(), self.angle.copy())\n                for n in names[~inself]\n            ]\n    tods = [t for t in tods if t.name in names]\n    if len(tods) != len(names):\n        raise ValueError(\"Can't find enough TODs with the input names!\")\n    tod_names = np.array([t.name for t in tods])\n    mapping = np.argsort(np.argsort(names))\n    nsrt = np.argsort(tod_names)\n    tods_srt = [tods[i] for i in nsrt]\n    tods_srt = [tods_srt[i] for i in mapping]\n\n    self.tods = tods_srt\n    return self\n</code></pre>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefTOD","title":"<code>RefTOD</code>  <code>dataclass</code>","text":"<p>Dataclass for storing the position of a point as a function of time.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the point.</p> <code>data</code> <code>NDArray[float64]</code> <p>The position of the point. Should be a <code>(npoint, ndim)</code> array.</p> <code>angle</code> <code>NDArray[float64]</code> <p>The angle of the relevent element for each data point. For example the corotator angle or elevation angle. Should have shape <code>(npoint,)</code>.</p> Source code in <code>lat_alignment/refpoint.py</code> <pre><code>@dataclass\nclass RefTOD:\n    \"\"\"\n    Dataclass for storing the position of a point as a function of time.\n\n    Attributes\n    ----------\n    name : str\n        The name of the point.\n    data : NDArray[np.float64]\n        The position of the point.\n        Should be a `(npoint, ndim)` array.\n    angle : NDArray[np.float64]\n        The angle of the relevent element for each data point.\n        For example the corotator angle or elevation angle.\n        Should have shape `(npoint,)`.\n    \"\"\"\n\n    name: str\n    data: NDArray[np.float64]\n    angle: NDArray[np.float64]\n\n    def __setattr__(self, name, val):\n        self.__dict__[name] = val\n        if name in [\"data\", \"angle\"]:\n            self.__dict__.pop(\"npoints\", None)\n            self.__dict__.pop(\"meas_number\", None)\n        if name == \"angle\":\n            self.__dict__.pop(\"direction\", None)\n\n    @cached_property\n    def npoints(self) -&gt; int:\n        \"\"\"\n        The number of points in the TOD.\n        Will throw and error if `data` and `angle` disagree on this.\n        \"\"\"\n        if len(self.data) != len(self.angle):\n            raise ValueError(\"Data and angle don't have same length!\")\n        return len(self.data)\n\n    @cached_property\n    def direction(self) -&gt; NDArray[np.float64]:\n        \"\"\"\n        The derivative of `self.angle`.\n        \"\"\"\n        direction = np.diff(self.angle)\n        direction = np.hstack((direction, [direction[-1]]))\n        return direction\n\n    @cached_property\n    def meas_number(self) -&gt; NDArray[np.integer]:\n        \"\"\"\n        Array that indexes the TOD data (ie: sample number).\n        \"\"\"\n        return np.arange(self.npoints)\n</code></pre>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefTOD.direction","title":"<code>direction</code>  <code>cached</code> <code>property</code>","text":"<p>The derivative of <code>self.angle</code>.</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefTOD.meas_number","title":"<code>meas_number</code>  <code>cached</code> <code>property</code>","text":"<p>Array that indexes the TOD data (ie: sample number).</p>"},{"location":"reference/refpoint/#lat_alignment.refpoint.RefTOD.npoints","title":"<code>npoints</code>  <code>cached</code> <code>property</code>","text":"<p>The number of points in the TOD. Will throw and error if <code>data</code> and <code>angle</code> disagree on this.</p>"},{"location":"reference/traj_plots/","title":"traj_plots","text":"<p>Helper module with plotting functions for the trajectory module.</p>"},{"location":"reference/traj_plots/#lat_alignment.traj_plots.plot_all_ax","title":"<code>plot_all_ax(x, dat, missing, xlab, ylab, title, plt_root)</code>","text":"<p>Plot data with dimensions as seperate lines on the same plot. This doesn't show the direction of motions on the plot. The plot will be saved to <code>plt_root/{title.lower().replace(' ' , '_')}.png</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float64]</code> <p>The x data to plot against. Should have shape <code>(npoint,)</code>.</p> required <code>dat</code> <code>NDArray[float64]</code> <p>The data to plot. Should have shape <code>(npoint, ndim)</code>.</p> required <code>missing</code> <code>list[int]</code> <p>A list of indices that will be flagged in the plot as only having partial data.</p> required <code>xlab</code> <code>str</code> <p>The x label to use in the plot.</p> required <code>ylab</code> <code>str</code> <p>The y label to use in the plot.</p> required <code>title</code> <code>str</code> <p>The title of the plot.</p> required <code>plt_root</code> <code>str</code> <p>The directory to save plots to.</p> required Source code in <code>lat_alignment/traj_plots.py</code> <pre><code>def plot_all_ax(\n    x: NDArray[np.float64],\n    dat: NDArray[np.float64],\n    missing: list[int],\n    xlab: str,\n    ylab: str,\n    title: str,\n    plt_root: str,\n):\n    \"\"\"\n    Plot data with dimensions as seperate lines on the same plot.\n    This doesn't show the direction of motions on the plot.\n    The plot will be saved to `plt_root/{title.lower().replace(' ' , '_')}.png`.\n\n    Parameters\n    ----------\n    x : NDArray[np.float64]\n        The x data to plot against.\n        Should have shape `(npoint,)`.\n    dat : NDArray[np.float64]\n        The data to plot.\n        Should have shape `(npoint, ndim)`.\n    missing : list[int]\n        A list of indices that will be flagged in the plot\n        as only having partial data.\n    xlab : str\n        The x label to use in the plot.\n    ylab : str\n        The y label to use in the plot.\n    title : str\n        The title of the plot.\n    plt_root : str\n        The directory to save plots to.\n    \"\"\"\n    plt.scatter(x, dat[:, 0], alpha=0.5, label=\"x\")\n    plt.scatter(x, dat[:, 1], alpha=0.5, label=\"y\")\n    plt.scatter(x, dat[:, 2], alpha=0.5, label=\"z\")\n    plt.scatter(x[missing], dat[missing, 0], color=\"gray\", marker=\"1\")\n    plt.scatter(x[missing], dat[missing, 1], color=\"gray\", marker=\"1\")\n    plt.scatter(x[missing], dat[missing, 2], color=\"gray\", marker=\"1\")\n    plt.legend()\n    plt.xlabel(xlab)\n    plt.ylabel(ylab)\n    plt.title(title)\n    plt.savefig(\n        os.path.join(plt_root, f\"{title.lower().replace(' ' , '_')}.png\"),\n        bbox_inches=\"tight\",\n    )\n    plt.close()\n</code></pre>"},{"location":"reference/traj_plots/#lat_alignment.traj_plots.plot_all_dir","title":"<code>plot_all_dir(x, dat, direction, missing, xlab, ylab, title, plt_root)</code>","text":"<p>Plot data with directions as seperate lines on the same plot. The plot will be saved to <code>plt_root/{title.lower().replace(' ' , '_')}.png</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float64]</code> <p>The x data to plot against. Should have shape <code>(npoint,)</code>.</p> required <code>dat</code> <code>NDArray[float64]</code> <p>The data to plot. Should have shape <code>(npoint,)</code>.</p> required <code>direction</code> <code>NDArray[float64]</code> <p>The direction of motion at each data point. Should have shape <code>(npoint,)</code>.</p> required <code>missing</code> <code>list[int]</code> <p>A list of indices that will be flagged in the plot as only having partial data.</p> required <code>xlab</code> <code>str</code> <p>The x label to use in the plot.</p> required <code>ylab</code> <code>str</code> <p>The y label to use in the plot.</p> required <code>title</code> <code>str</code> <p>The title of the plot.</p> required <code>plt_root</code> <code>str</code> <p>The directory to save plots to.</p> required Source code in <code>lat_alignment/traj_plots.py</code> <pre><code>def plot_all_dir(\n    x: NDArray[np.float64],\n    dat: NDArray[np.float64],\n    direction: NDArray[np.float64],\n    missing: list[int],\n    xlab: str,\n    ylab: str,\n    title: str,\n    plt_root: str,\n):\n    \"\"\"\n    Plot data with directions as seperate lines on the same plot.\n    The plot will be saved to `plt_root/{title.lower().replace(' ' , '_')}.png`.\n\n    Parameters\n    ----------\n    x : NDArray[np.float64]\n        The x data to plot against.\n        Should have shape `(npoint,)`.\n    dat : NDArray[np.float64]\n        The data to plot.\n        Should have shape `(npoint,)`.\n    direction : NDArray[np.float64]\n        The direction of motion at each data point.\n        Should have shape `(npoint,)`.\n    missing : list[int]\n        A list of indices that will be flagged in the plot\n        as only having partial data.\n    xlab : str\n        The x label to use in the plot.\n    ylab : str\n        The y label to use in the plot.\n    title : str\n        The title of the plot.\n    plt_root : str\n        The directory to save plots to.\n    \"\"\"\n    plt.scatter(\n        x[direction == 0],\n        dat[direction == 0],\n        color=\"black\",\n        alpha=0.5,\n        label=\"Stationary\",\n    )\n    plt.scatter(\n        x[direction &lt; 0],\n        dat[direction &lt; 0],\n        color=\"blue\",\n        alpha=0.5,\n        label=\"Decreasing\",\n    )\n    plt.scatter(\n        x[direction &gt; 0],\n        dat[direction &gt; 0],\n        color=\"red\",\n        alpha=0.5,\n        label=\"Increasing\",\n    )\n    plt.scatter(x[missing], dat[missing], color=\"gray\", alpha=1, marker=\"1\")\n    plt.legend()\n    plt.xlabel(xlab)\n    plt.ylabel(ylab)\n    plt.title(title)\n    plt.savefig(\n        os.path.join(plt_root, f\"{title.lower().replace(' ' , '_')}.png\"),\n        bbox_inches=\"tight\",\n    )\n    plt.close()\n</code></pre>"},{"location":"reference/traj_plots/#lat_alignment.traj_plots.plot_by_ax","title":"<code>plot_by_ax(x, dat, direction, missing, xax, xlab, ylab, title, plt_root)</code>","text":"<p>Plot data with seperate subplots for each dimension. The plot will be saved to <code>plt_root/{title.lower().replace(' ' , '_')}_{xax}.png</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>NDArray[float64]</code> <p>The x data to plot against. Should have shape <code>(npoint,)</code>.</p> required <code>dat</code> <code>NDArray[float64]</code> <p>The data to plot. Should have shape <code>(npoint, ndim)</code>.</p> required <code>direction</code> <code>NDArray[float64]</code> <p>The direction of motion at each data point. Should have shape <code>(npoint,)</code>.</p> required <code>missing</code> <code>list[int]</code> <p>A list of indices that will be flagged in the plot as only having partial data.</p> required <code>xax</code> <code>str</code> <p>A description of the x axis for the file name.</p> required <code>xlab</code> <code>str</code> <p>The x label to use in the plot.</p> required <code>ylab</code> <code>str</code> <p>The y label to use in the plot.</p> required <code>title</code> <code>str</code> <p>The title of the plot.</p> required <code>plt_root</code> <code>str</code> <p>The directory to save plots to.</p> required Source code in <code>lat_alignment/traj_plots.py</code> <pre><code>def plot_by_ax(\n    x: NDArray[np.float64],\n    dat: NDArray[np.float64],\n    direction: NDArray[np.float64],\n    missing: list[int],\n    xax: str,\n    xlab: str,\n    ylab: str,\n    title: str,\n    plt_root: str,\n):\n    \"\"\"\n    Plot data with seperate subplots for each dimension.\n    The plot will be saved to `plt_root/{title.lower().replace(' ' , '_')}_{xax}.png`.\n\n    Parameters\n    ----------\n    x : NDArray[np.float64]\n        The x data to plot against.\n        Should have shape `(npoint,)`.\n    dat : NDArray[np.float64]\n        The data to plot.\n        Should have shape `(npoint, ndim)`.\n    direction : NDArray[np.float64]\n        The direction of motion at each data point.\n        Should have shape `(npoint,)`.\n    missing : list[int]\n        A list of indices that will be flagged in the plot\n        as only having partial data.\n    xax : str\n        A description of the x axis for the file name.\n    xlab : str\n        The x label to use in the plot.\n    ylab : str\n        The y label to use in the plot.\n    title : str\n        The title of the plot.\n    plt_root : str\n        The directory to save plots to.\n    \"\"\"\n    _, axs = plt.subplots(3, 1, sharex=True)\n    for i, dim in enumerate([\"x\", \"y\", \"z\"]):\n        axs[i].scatter(\n            x[direction == 0],\n            dat[direction == 0, i],\n            color=\"black\",\n            marker=\"o\",\n            alpha=0.25,\n            label=\"Stationary\",\n        )\n        axs[i].scatter(\n            x[direction &lt; 0],\n            dat[direction &lt; 0, i],\n            color=\"blue\",\n            marker=\"x\",\n            alpha=0.25,\n            label=\"Decreasing\",\n        )\n        axs[i].scatter(\n            x[direction &gt; 0],\n            dat[direction &gt; 0, i],\n            color=\"red\",\n            marker=\"+\",\n            alpha=0.25,\n            label=\"Increasing\",\n        )\n        axs[i].scatter(x[missing], dat[missing, i], color=\"gray\", marker=\"1\")\n        axs[i].set_ylabel(f\"{dim} {ylab}\")\n    axs[0].legend()\n    axs[-1].set_xlabel(xlab)\n    plt.suptitle(title)\n    plt.savefig(\n        os.path.join(plt_root, f\"{title.lower().replace(' ' , '_')}_{xax}.png\"),\n        bbox_inches=\"tight\",\n    )\n    plt.close()\n</code></pre>"},{"location":"reference/traj_plots/#lat_alignment.traj_plots.plot_by_ax_point","title":"<code>plot_by_ax_point(names, x, dat, direction, missing, xax, xlab, title, plt_root)</code>","text":"<p>Plot data with subplots organized such that each row is a different dimension and each collumn is a different physical location that was measured. The plot will be saved to <code>plt_root/{title.lower().replace(' ' , '_')}_{xax}.png</code>.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>list[str] | NDArray[str_]</code> <p>The names of the physically measured locations.</p> required <code>x</code> <code>NDArray[float64]</code> <p>The x data to plot against. Should have shape <code>(npoint,)</code>.</p> required <code>dat</code> <code>NDArray[float64]</code> <p>The data to plot. Should have shape <code>(npoint, nloc, ndim)</code>.</p> required <code>direction</code> <code>NDArray[float64]</code> <p>The direction of motion at each data point. Should have shape <code>(npoint,)</code>.</p> required <code>missing</code> <code>list[int]</code> <p>A list of indices that will be flagged in the plot as only having partial data.</p> required <code>xax</code> <code>str</code> <p>A description of the x axis for the file name.</p> required <code>xlab</code> <code>str</code> <p>The x label to use in the plot.</p> required <code>title</code> <code>str</code> <p>The title of the plot.</p> required <code>plt_root</code> <code>str</code> <p>The directory to save plots to.</p> required Source code in <code>lat_alignment/traj_plots.py</code> <pre><code>def plot_by_ax_point(\n    names: list[str] | NDArray[np.str_],\n    x: NDArray[np.float64],\n    dat: NDArray[np.float64],\n    direction: NDArray[np.float64],\n    missing: list[int],\n    xax: str,\n    xlab: str,\n    title: str,\n    plt_root: str,\n):\n    \"\"\"\n    Plot data with subplots organized such that each row is a different dimension\n    and each collumn is a different physical location that was measured.\n    The plot will be saved to `plt_root/{title.lower().replace(' ' , '_')}_{xax}.png`.\n\n    Parameters\n    ----------\n    names : list[str] | NDArray[np.str_]\n        The names of the physically measured locations.\n    x : NDArray[np.float64]\n        The x data to plot against.\n        Should have shape `(npoint,)`.\n    dat : NDArray[np.float64]\n        The data to plot.\n        Should have shape `(npoint, nloc, ndim)`.\n    direction : NDArray[np.float64]\n        The direction of motion at each data point.\n        Should have shape `(npoint,)`.\n    missing : list[int]\n        A list of indices that will be flagged in the plot\n        as only having partial data.\n    xax : str\n        A description of the x axis for the file name.\n    xlab : str\n        The x label to use in the plot.\n    title : str\n        The title of the plot.\n    plt_root : str\n        The directory to save plots to.\n    \"\"\"\n    _, axs = plt.subplots(\n        3,\n        len(names),\n        sharex=True,\n        sharey=False,\n        figsize=(24, 20),\n        layout=\"constrained\",\n    )\n    axs = np.reshape(np.array(axs), (int(3), len(names)))\n    for i, point in enumerate(names):\n        for j, dim in enumerate([\"x\", \"y\", \"z\"]):\n            axs[j, i].scatter(\n                x[direction == 0],\n                dat[direction == 0, i, j],\n                color=\"black\",\n                marker=\"o\",\n                alpha=0.5,\n                label=\"Stationary\",\n            )\n            axs[j, i].scatter(\n                x[direction &lt; 0],\n                dat[direction &lt; 0, i, j],\n                color=\"blue\",\n                marker=\"x\",\n                alpha=0.5,\n                label=\"Decreasing\",\n            )\n            axs[j, i].scatter(\n                x[direction &gt; 0],\n                dat[direction &gt; 0, i, j],\n                color=\"red\",\n                marker=\"+\",\n                alpha=0.5,\n                label=\"Increasing\",\n            )\n            axs[j, i].scatter(x[missing], dat[missing, i, j], color=\"gray\", marker=\"1\")\n            axs[0, i].set_title(point)\n            axs[-1, i].set_xlabel(xlab)\n            axs[j, 0].set_ylabel(f\"{dim} (mm)\")\n    axs[-1, 0].legend()\n    plt.suptitle(title)\n    plt.savefig(\n        os.path.join(plt_root, f\"{title.lower().replace(' ' , '_')}_{xax}.png\"),\n        bbox_inches=\"tight\",\n    )\n    plt.close()\n</code></pre>"},{"location":"reference/traj_plots/#lat_alignment.traj_plots.plot_hist","title":"<code>plot_hist(dat, direction, xlab, title, plt_root)</code>","text":"<p>Plot a histogram of data with directions as seperate histograms on the same plot. The plot will be saved to <code>plt_root/{title.lower().replace(' ' , '_')}.png</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dat</code> <code>NDArray[float64]</code> <p>The data to plot. Should have shape <code>(npoint,)</code>.</p> required <code>direction</code> <code>NDArray[float64]</code> <p>The direction of motion at each data point. Should have shape <code>(npoint,)</code>.</p> required <code>xlab</code> <code>str</code> <p>The x label to use in the plot.</p> required <code>title</code> <code>str</code> <p>The title of the plot.</p> required <code>plt_root</code> <code>str</code> <p>The directory to save plots to.</p> required Source code in <code>lat_alignment/traj_plots.py</code> <pre><code>def plot_hist(\n    dat: NDArray[np.float64],\n    direction: NDArray[np.float64],\n    xlab: str,\n    title: str,\n    plt_root: str,\n):\n    \"\"\"\n    Plot a histogram of data with directions as seperate histograms on the same plot.\n    The plot will be saved to `plt_root/{title.lower().replace(' ' , '_')}.png`.\n\n    Parameters\n    ----------\n    dat : NDArray[np.float64]\n        The data to plot.\n        Should have shape `(npoint,)`.\n    direction : NDArray[np.float64]\n        The direction of motion at each data point.\n        Should have shape `(npoint,)`.\n    xlab : str\n        The x label to use in the plot.\n    title : str\n        The title of the plot.\n    plt_root : str\n        The directory to save plots to.\n    \"\"\"\n    if len(direction == 0) &gt; 0 and np.sum(np.isfinite(dat[direction == 0])) &gt; 0:\n        plt.hist(\n            dat[direction == 0],\n            bins=\"auto\",\n            color=\"black\",\n            alpha=0.5,\n            label=\"Stationary\",\n        )\n    if len(direction &lt; 0) &gt; 0 and np.sum(np.isfinite(dat[direction &lt; 0])) &gt; 0:\n        plt.hist(\n            dat[direction &lt; 0],\n            bins=\"auto\",\n            color=\"blue\",\n            alpha=0.5,\n            label=\"Decreasing\",\n        )\n    if len(direction &gt; 0) &gt; 0 and np.sum(np.isfinite(dat[direction &gt; 0])) &gt; 0:\n        plt.hist(\n            dat[direction &gt; 0],\n            bins=\"auto\",\n            color=\"red\",\n            alpha=0.5,\n            label=\"Increasing\",\n        )\n    plt.legend()\n    plt.xlabel(xlab)\n    plt.ylabel(\"Counts (#)\")\n    plt.title(title)\n    plt.savefig(\n        os.path.join(plt_root, f\"{title.lower().replace(' ' , '_')}.png\"),\n        bbox_inches=\"tight\",\n    )\n    plt.close()\n</code></pre>"},{"location":"reference/trajectory/","title":"trajectory","text":"<p>Script for analyzing trajectory of a point on optical elements.</p>"},{"location":"reference/trajectory/#lat_alignment.trajectory.correct_rot","title":"<code>correct_rot(src, angle, cent, off=0)</code>","text":"<p>Remove the rotation of an element from a point. For example undo corotation from a point on the LATR.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>NDArray[float64]</code> <p>The data to rotate. Should be <code>(npoint, ndim)</code>.</p> required <code>angle</code> <code>NDArray[float64]</code> <p>The angle in degrees of the element at each data point. Should by <code>(npoint,)</code>.</p> required <code>cent</code> <code>NDArray[float64]</code> <p>The center of rotation of the point. Should be <code>(ndim,)</code>.</p> required <p>Returns:</p> Name Type Description <code>src</code> <code>NDArray[float64]</code> <p>The data with the rotation removed. The input is also modified in place.</p> Source code in <code>lat_alignment/trajectory.py</code> <pre><code>def correct_rot(\n    src: NDArray[np.float64],\n    angle: NDArray[np.float64],\n    cent: NDArray[np.float64],\n    off: float = 0,\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Remove the rotation of an element from a point.\n    For example undo corotation from a point on the LATR.\n\n    Parameters\n    ----------\n    src : NDArray[np.float64]\n        The data to rotate.\n        Should be `(npoint, ndim)`.\n    angle : NDArray[np.float64]\n        The angle in degrees of the element at each data point.\n        Should by `(npoint,)`.\n    cent : NDArray[np.float64]\n        The center of rotation of the point.\n        Should be `(ndim,)`.\n\n    Returns\n    -------\n    src : NDArray[np.float64]\n        The data with the rotation removed.\n        The input is also modified in place.\n    \"\"\"\n    for i, (pt, ang) in enumerate(zip(src, angle)):\n        rot = Rotation.from_euler(\"Y\", -1 * (ang - off), degrees=True)\n        src[i] = rot.apply(pt - cent) + rot.apply(cent)\n    return src\n</code></pre>"},{"location":"reference/trajectory/#lat_alignment.trajectory.get_angle","title":"<code>get_angle(data, mode, start, sep, logger)</code>","text":"<p>Reconstruct the angle of an opitcal element from data of a point.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>NDArray[float64]</code> <p>A <code>(npoint, ndim)</code> array describing the motion of a point.</p> required <code>mode</code> <code>str</code> <p>The mode this data was taken in. Should be <code>continious</code> or <code>step</code>.</p> required <code>start</code> <code>float</code> <p>The angle of the element at the first data point. Should be in degrees.</p> required <code>sep</code> <code>float</code> <p>The seperation between measurements. If we are in <code>continious</code> mode this should be in mm. If we are in <code>step</code> mode this should be in deg.</p> required <code>logger</code> <code>Logger</code> <p>The logger object to use.</p> required <p>Returns:</p> Name Type Description <code>angle</code> <code>NDArray[float64]</code> <p>The reconstructed angle in degrees. Will be a <code>(npoint,)</code> array.</p> <code>center</code> <code>NDArray[float64]</code> <p>The center of rotation.</p> Source code in <code>lat_alignment/trajectory.py</code> <pre><code>def get_angle(\n    data: NDArray[np.float64],\n    mode: str,\n    start: float,\n    sep: float,\n    logger: logging.Logger,\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"\n    Reconstruct the angle of an opitcal element from data of a point.\n\n    Parameters\n    ----------\n    data : NDArray[np.float64]\n        A `(npoint, ndim)` array describing the motion of a point.\n    mode : str\n        The mode this data was taken in.\n        Should be `continious` or `step`.\n    start : float\n        The angle of the element at the first data point.\n        Should be in degrees.\n    sep : float\n        The seperation between measurements.\n        If we are in `continious` mode this should be in mm.\n        If we are in `step` mode this should be in deg.\n    logger : logging.Logger\n        The logger object to use.\n\n    Returns\n    -------\n    angle : NDArray[np.float64]\n        The reconstructed angle in degrees.\n        Will be a `(npoint,)` array.\n    center : NDArray[np.float64]\n        The center of rotation.\n    \"\"\"\n    logger.info(\n        \"\\tReconstructing angle in %s mode using a start of %f deg and a seperation of %f\",\n        mode,\n        start,\n        sep,\n    )\n    # Recover the angle\n    theta, sphere = _get_sphere_and_angle(data, start, logger)\n\n    # Convert delta to an angle delta\n    if mode == \"continious\":\n        logger.warning(\n            \"\\t\\tReconstructing angle from continious data, this is approximate and should not be used for pointing corrections! Trajectory Errors will also only be approximate!\"\n        )\n        dtheta = np.rad2deg(sep / sphere.radius) / 32.0\n    elif mode == \"step\":\n        dtheta = sep\n    else:\n        raise ValueError(f\"Invalid mode: {mode}\")\n\n    # Quantize\n    theta_corr = _quantize_angle(theta, dtheta, start)\n\n    return theta_corr, np.array(sphere.point, np.float64)\n</code></pre>"},{"location":"reference/transforms/","title":"transforms","text":"<p>Functions for coordinate transforms.</p> <p>There are 6 relevant coordinate systems here, belonging to two sets of three. Each set is a global, a primary, and a secondary coordinate system; where primary and secondary are internal to those mirrors. The two sets of coordinates are the optical coordinates and the coordinates used by vertex. We denote these six coordinate systems as follows:</p> <pre><code>- opt_global\n- opt_primary\n- opt_secondary\n- va_global\n- va_primary\n- va_secondary\n</code></pre>"},{"location":"reference/transforms/#lat_alignment.transforms.affine_basis_transform","title":"<code>affine_basis_transform(aff, sft, cfrom, cto)</code>","text":"<p>Take an affine transform defined in one coordinate system and move it to another. The valid coordinate systems are the same as in <code>coord_transform</code>.</p> <p>Parameters:</p> Name Type Description Default <code>aff</code> <code>NDArray[float64]</code> <p>Affine matrix to tranform. Should be a <code>(3, 3)</code> array.</p> required <code>sft</code> <code>NDArray[float64]</code> <p>Shift vector to tranform. Should be a <code>(3,)</code> array.</p> required <code>cfrom</code> <code>str</code> <p>The coordinate system that <code>aff</code> and <code>sft</code> is currently in.</p> required <code>cto</code> <code>str</code> <p>The coordinate system to put <code>aff</code> and <code>sft</code> into.</p> required <p>Returns:</p> Name Type Description <code>aff_transformed</code> <code>NDArray[float64]</code> <p><code>aff</code> transformed into <code>cto</code>.</p> <code>sft_transformed</code> <code>NDArray[float64]</code> <p><code>sft</code> transformed into <code>cto</code>.</p> Source code in <code>lat_alignment/transforms.py</code> <pre><code>def affine_basis_transform(\n    aff: NDArray[np.float64],\n    sft: NDArray[np.float64],\n    cfrom: str,\n    cto: str,\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"\n    Take an affine transform defined in one coordinate system and move it to another.\n    The valid coordinate systems are the same as in `coord_transform`.\n\n    Parameters\n    ----------\n    aff : NDArray[np.float64]\n        Affine matrix to tranform.\n        Should be a `(3, 3)` array.\n    sft : NDArray[np.float64]\n        Shift vector to tranform.\n        Should be a `(3,)` array.\n    cfrom : str\n        The coordinate system that `aff` and `sft` is currently in.\n    cto : str\n        The coordinate system to put `aff` and `sft` into.\n\n    Returns\n    -------\n    aff_transformed : NDArray[np.float64]\n        `aff` transformed into `cto`.\n    sft_transformed : NDArray[np.float64]\n        `sft` transformed into `cto`.\n    \"\"\"\n    # Make a grid of reference points\n    line = np.array((-1, 0, 1), np.float64)\n    x, y, z = np.meshgrid(line, line, line)\n    xyz = np.column_stack((x.ravel(), y.ravel(), z.ravel()))\n\n    # Apply the affine transform\n    xyz_transformed = apply_transform(xyz, aff, sft)\n\n    # Move to the new coordinate system\n    xyz = coord_transform(xyz, cfrom, cto)\n    xyz_transformed = coord_transform(xyz_transformed, cfrom, cto)\n\n    # Get the new affine transform\n    aff, sft = get_affine(xyz, xyz_transformed)\n\n    return aff, sft\n</code></pre>"},{"location":"reference/transforms/#lat_alignment.transforms.coord_transform","title":"<code>coord_transform(coords, cfrom, cto)</code>","text":"<p>Transform between the six defined mirror coordinates:</p> <pre><code>- opt_global\n- opt_primary\n- opt_secondary\n- va_global\n- va_primary\n- va_secondary\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>NDArray[float64]</code> <p>Coordinates to transform. Should be a <code>(npoint, 3)</code> array.</p> required <code>cfrom</code> <code>str</code> <p>The coordinate system that <code>coords</code> is currently in.</p> required <code>cto</code> <code>str</code> <p>The coordinate system to put <code>coords</code> into.</p> required <p>Returns:</p> Name Type Description <code>coords_transformed</code> <code>NDArray[float64]</code> <p><code>coords</code> transformed into <code>cto</code>.</p> Source code in <code>lat_alignment/transforms.py</code> <pre><code>def coord_transform(\n    coords: NDArray[np.float64], cfrom: str, cto: str\n) -&gt; NDArray[np.float64]:\n    \"\"\"\n    Transform between the six defined mirror coordinates:\n\n        - opt_global\n        - opt_primary\n        - opt_secondary\n        - va_global\n        - va_primary\n        - va_secondary\n\n    Parameters\n    ----------\n    coords : NDArray[np.float64]\n        Coordinates to transform.\n        Should be a `(npoint, 3)` array.\n    cfrom : str\n        The coordinate system that `coords` is currently in.\n    cto : str\n        The coordinate system to put `coords` into.\n\n    Returns\n    -------\n    coords_transformed : NDArray[np.float64]\n        `coords` transformed into `cto`.\n    \"\"\"\n    if cfrom == cto:\n        return coords\n    match f\"{cfrom}-{cto}\":\n        case \"opt_global-opt_primary\":\n            return _opt_global_to_opt_primary(coords).astype(np.float64)\n        case \"opt_global-opt_secondary\":\n            return _opt_global_to_opt_secondary(coords).astype(np.float64)\n        case \"opt_primary-opt_global\":\n            return _opt_primary_to_opt_global(coords).astype(np.float64)\n        case \"opt_secondary-opt_global\":\n            return _opt_secondary_to_opt_global(coords).astype(np.float64)\n        case \"opt_primary-opt_secondary\":\n            return _opt_primary_to_opt_secondary(coords).astype(np.float64)\n        case \"opt_secondary-opt_primary\":\n            return _opt_secondary_to_opt_primary(coords).astype(np.float64)\n        case \"va_global-va_primary\":\n            return _va_global_to_va_primary(coords).astype(np.float64)\n        case \"va_global-va_secondary\":\n            return _va_global_to_va_secondary(coords).astype(np.float64)\n        case \"va_primary-va_global\":\n            return _va_primary_to_va_global(coords).astype(np.float64)\n        case \"va_secondary-va_global\":\n            return _va_secondary_to_va_global(coords).astype(np.float64)\n        case \"va_primary-va_secondary\":\n            return _va_primary_to_va_secondary(coords).astype(np.float64)\n        case \"va_secondary-va_primary\":\n            return _va_secondary_to_va_primary(coords).astype(np.float64)\n        case \"opt_global-va_global\":\n            return _opt_global_to_va_global(coords).astype(np.float64)\n        case \"opt_global-va_primary\":\n            return _opt_global_to_va_primary(coords).astype(np.float64)\n        case \"opt_global-va_secondary\":\n            return _opt_global_to_va_secondary(coords).astype(np.float64)\n        case \"opt_primary-va_global\":\n            return _opt_primary_to_va_global(coords).astype(np.float64)\n        case \"opt_primary-va_primary\":\n            return _opt_primary_to_va_primary(coords).astype(np.float64)\n        case \"opt_primary-va_secondary\":\n            return _opt_primary_to_va_secondary(coords).astype(np.float64)\n        case \"opt_secondary-va_global\":\n            return _opt_secondary_to_va_global(coords).astype(np.float64)\n        case \"opt_secondary-va_primary\":\n            return _opt_secondary_to_va_primary(coords).astype(np.float64)\n        case \"opt_secondary-va_secondary\":\n            return _opt_secondary_to_va_secondary(coords).astype(np.float64)\n        case \"va_global-opt_global\":\n            return _va_global_to_opt_global(coords).astype(np.float64)\n        case \"va_global-opt_primary\":\n            return _va_global_to_opt_primary(coords).astype(np.float64)\n        case \"va_global-opt_secondary\":\n            return _va_global_to_opt_secondary(coords).astype(np.float64)\n        case \"va_primary-opt_global\":\n            return _va_primary_to_opt_global(coords).astype(np.float64)\n        case \"va_primary-opt_primary\":\n            return _va_primary_to_opt_primary(coords).astype(np.float64)\n        case \"va_primary-opt_secondary\":\n            return _va_primary_to_opt_secondary(coords).astype(np.float64)\n        case \"va_secondary-opt_global\":\n            return _va_secondary_to_opt_global(coords).astype(np.float64)\n        case \"va_secondary-opt_primary\":\n            return _va_secondary_to_opt_primary(coords).astype(np.float64)\n        case \"va_secondary-opt_secondary\":\n            return _va_secondary_to_opt_secondary(coords).astype(np.float64)\n        case _:\n            raise ValueError(\"Invalid coordinate system provided!\")\n</code></pre>"}]}